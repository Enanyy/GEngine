
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>libuv documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/badge_only.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  
<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://docs.libuv.org/en/v1.x/" />

<link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = 'index'
</script>

<script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-analytics.js"></script>

<!-- end RTD <extrahead> -->
</head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">libuv 1.20.4-dev documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-the-libuv-documentation">
<h1>Welcome to the libuv documentation<a class="headerlink" href="#welcome-to-the-libuv-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>libuv is a multi-platform support library with a focus on asynchronous I/O. It
was primarily developed for use by <a class="reference external" href="http://nodejs.org">Node.js</a>, but it’s also used by <a class="reference external" href="http://luvit.io">Luvit</a>,
<a class="reference external" href="http://julialang.org">Julia</a>, <a class="reference external" href="https://github.com/saghul/pyuv">pyuv</a>, and <a class="reference external" href="https://github.com/libuv/libuv/wiki/Projects-that-use-libuv">others</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In case you find errors in this documentation you can help by sending
<a class="reference external" href="https://github.com/libuv/libuv">pull requests</a>!</p>
</div>
</div>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Full-featured event loop backed by epoll, kqueue, IOCP, event ports.</li>
<li>Asynchronous TCP and UDP sockets</li>
<li>Asynchronous DNS resolution</li>
<li>Asynchronous file and file system operations</li>
<li>File system events</li>
<li>ANSI escape code controlled TTY</li>
<li>IPC with socket sharing, using Unix domain sockets or named pipes (Windows)</li>
<li>Child processes</li>
<li>Thread pool</li>
<li>Signal handling</li>
<li>High resolution clock</li>
<li>Threading and synchronization primitives</li>
</ul>
</div>
<div class="section" id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-design"></span><div class="section" id="design-overview">
<span id="design"></span><h3>Design overview<a class="headerlink" href="#design-overview" title="Permalink to this headline">¶</a></h3>
<p>libuv is cross-platform support library which was originally written for NodeJS. It’s designed
around the event-driven asynchronous I/O model.</p>
<p>The library provides much more than a simple abstraction over different I/O polling mechanisms:
‘handles’ and ‘streams’ provide a high level abstraction for sockets and other entities;
cross-platform file I/O and threading functionality is also provided, amongst other things.</p>
<p>Here is a diagram illustrating the different parts that compose libuv and what subsystem they
relate to:</p>
<a class="reference internal image-reference" href="_images/architecture.png"><img alt="_images/architecture.png" class="align-center" src="_images/architecture.png" style="width: 765.0px; height: 369.75px;" /></a>
<div class="section" id="handles-and-requests">
<h4>Handles and requests<a class="headerlink" href="#handles-and-requests" title="Permalink to this headline">¶</a></h4>
<p>libuv provides users with 2 abstractions to work with, in combination with the event loop:
handles and requests.</p>
<p>Handles represent long-lived objects capable of performing certain operations while active. Some examples:</p>
<ul class="simple">
<li>A prepare handle gets its callback called once every loop iteration when active.</li>
<li>A TCP server handle that gets its connection callback called every time there is a new connection.</li>
</ul>
<p>Requests represent (typically) short-lived operations. These operations can be performed over a
handle: write requests are used to write data on a handle; or standalone: getaddrinfo requests
don’t need a handle they run directly on the loop.</p>
</div>
<div class="section" id="the-i-o-loop">
<h4>The I/O loop<a class="headerlink" href="#the-i-o-loop" title="Permalink to this headline">¶</a></h4>
<p>The I/O (or event) loop is the central part of libuv. It establishes the content for all I/O
operations, and it’s meant to be tied to a single thread. One can run multiple event loops
as long as each runs in a different thread. The libuv event loop (or any other API involving
the loop or handles, for that matter) <strong>is not thread-safe</strong> except where stated otherwise.</p>
<p>The event loop follows the rather usual single threaded asynchronous I/O approach: all (network)
I/O is performed on non-blocking sockets which are polled using the best mechanism available
on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP
on Windows. As part of a loop iteration the loop will block waiting for I/O activity on sockets
which have been added to the poller and callbacks will be fired indicating socket conditions
(readable, writable hangup) so handles can read, write or perform the desired I/O operation.</p>
<p>In order to better understand how the event loop operates, the following diagram illustrates all
stages of a loop iteration:</p>
<a class="reference internal image-reference" href="_images/loop_iteration.png"><img alt="_images/loop_iteration.png" class="align-center" src="_images/loop_iteration.png" style="width: 391.5px; height: 555.0px;" /></a>
<ol class="arabic">
<li><p class="first">The loop concept of ‘now’ is updated. The event loop caches the current time at the start of
the event loop tick in order to reduce the number of time-related system calls.</p>
</li>
<li><p class="first">If the loop is <em>alive</em>  an iteration is started, otherwise the loop will exit immediately. So,
when is a loop considered to be <em>alive</em>? If a loop has active and ref’d handles, active
requests or closing handles it’s considered to be <em>alive</em>.</p>
</li>
<li><p class="first">Due timers are run. All active timers scheduled for a time before the loop’s concept of <em>now</em>
get their callbacks called.</p>
</li>
<li><p class="first">Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the
most part. There are cases, however, in which calling such a callback is deferred for the next
loop iteration. If the previous iteration deferred any I/O callback it will be run at this point.</p>
</li>
<li><p class="first">Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every
loop iteration, if they are active.</p>
</li>
<li><p class="first">Prepare handle callbacks are called. Prepare handles get their callbacks called right before
the loop will block for I/O.</p>
</li>
<li><p class="first">Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should
block. These are the rules when calculating the timeout:</p>
<blockquote>
<div><ul class="simple">
<li>If the loop was run with the <code class="docutils literal notranslate"><span class="pre">UV_RUN_NOWAIT</span></code> flag, the timeout is 0.</li>
<li>If the loop is going to be stopped (<a class="reference internal" href="index.html#c.uv_stop" title="uv_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_stop()</span></code></a> was called), the timeout is 0.</li>
<li>If there are no active handles or requests, the timeout is 0.</li>
<li>If there are any idle handles active, the timeout is 0.</li>
<li>If there are any handles pending to be closed, the timeout is 0.</li>
<li>If none of the above cases matches, the timeout of the closest timer is taken, or
if there are no active timers, infinity.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated
in the previous step. All I/O related handles that were monitoring a given file descriptor
for a read or write operation get their callbacks called at this point.</p>
</li>
<li><p class="first">Check handle callbacks are called. Check handles get their callbacks called right after the
loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles.</p>
</li>
<li><p class="first">Close callbacks are called. If a handle was closed by calling <a class="reference internal" href="index.html#c.uv_close" title="uv_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_close()</span></code></a> it will
get the close callback called.</p>
</li>
<li><p class="first">Special case in case the loop was run with <code class="docutils literal notranslate"><span class="pre">UV_RUN_ONCE</span></code>, as it implies forward progress.
It’s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed
so there might be timers which are due, those timers get their callbacks called.</p>
</li>
<li><p class="first">Iteration ends. If the loop was run with <code class="docutils literal notranslate"><span class="pre">UV_RUN_NOWAIT</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_RUN_ONCE</span></code> modes the
iteration ends and <a class="reference internal" href="index.html#c.uv_run" title="uv_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_run()</span></code></a> will return. If the loop was run with <code class="docutils literal notranslate"><span class="pre">UV_RUN_DEFAULT</span></code>
it will continue from the start if it’s still <em>alive</em>, otherwise it will also end.</p>
</li>
</ol>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">libuv uses a thread pool to make asynchronous file I/O operations possible, but
network I/O is <strong>always</strong> performed in a single thread, each loop’s thread.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While the polling mechanism is different, libuv makes the execution model consistent
across Unix systems and Windows.</p>
</div>
</div>
<div class="section" id="file-i-o">
<h4>File I/O<a class="headerlink" href="#file-i-o" title="Permalink to this headline">¶</a></h4>
<p>Unlike network I/O, there are no platform-specific file I/O primitives libuv could rely on,
so the current approach is to run blocking file I/O operations in a thread pool.</p>
<p>For a thorough explanation of the cross-platform file I/O landscape, checkout
<a class="reference external" href="http://blog.libtorrent.org/2012/10/asynchronous-disk-io/">this post</a>.</p>
<p>libuv currently uses a global thread pool on which all loops can queue work on. 3 types of
operations are currently run on this pool:</p>
<blockquote>
<div><ul class="simple">
<li>File system operations</li>
<li>DNS functions (getaddrinfo and getnameinfo)</li>
<li>User specified code via <a class="reference internal" href="index.html#c.uv_queue_work" title="uv_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_queue_work()</span></code></a></li>
</ul>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">See the <a class="reference internal" href="index.html#threadpool"><span class="std std-ref">Thread pool work scheduling</span></a> section for more details, but keep in mind the thread pool size
is quite limited.</p>
</div>
</div>
</div>
<span id="document-api"></span><div class="section" id="api-documentation">
<span id="api"></span><h3>API documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-errors"></span><div class="section" id="error-handling">
<span id="errors"></span><h4>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h4>
<p>In libuv errors are negative numbered constants. As a rule of thumb, whenever
there is a status parameter, or an API functions returns an integer, a negative
number will imply an error.</p>
<p>When a function which takes a callback returns an error, the callback will never
be called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Implementation detail: on Unix error codes are the negated <cite>errno</cite> (or <cite>-errno</cite>), while on
Windows they are defined by libuv to arbitrary negative numbers.</p>
</div>
<div class="section" id="error-constants">
<h5>Error constants<a class="headerlink" href="#error-constants" title="Permalink to this headline">¶</a></h5>
<dl class="macro">
<dt id="c.UV_E2BIG">
<code class="descname">UV_E2BIG</code><a class="headerlink" href="#c.UV_E2BIG" title="Permalink to this definition">¶</a></dt>
<dd><p>argument list too long</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EACCES">
<code class="descname">UV_EACCES</code><a class="headerlink" href="#c.UV_EACCES" title="Permalink to this definition">¶</a></dt>
<dd><p>permission denied</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EADDRINUSE">
<code class="descname">UV_EADDRINUSE</code><a class="headerlink" href="#c.UV_EADDRINUSE" title="Permalink to this definition">¶</a></dt>
<dd><p>address already in use</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EADDRNOTAVAIL">
<code class="descname">UV_EADDRNOTAVAIL</code><a class="headerlink" href="#c.UV_EADDRNOTAVAIL" title="Permalink to this definition">¶</a></dt>
<dd><p>address not available</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAFNOSUPPORT">
<code class="descname">UV_EAFNOSUPPORT</code><a class="headerlink" href="#c.UV_EAFNOSUPPORT" title="Permalink to this definition">¶</a></dt>
<dd><p>address family not supported</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAGAIN">
<code class="descname">UV_EAGAIN</code><a class="headerlink" href="#c.UV_EAGAIN" title="Permalink to this definition">¶</a></dt>
<dd><p>resource temporarily unavailable</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_ADDRFAMILY">
<code class="descname">UV_EAI_ADDRFAMILY</code><a class="headerlink" href="#c.UV_EAI_ADDRFAMILY" title="Permalink to this definition">¶</a></dt>
<dd><p>address family not supported</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_AGAIN">
<code class="descname">UV_EAI_AGAIN</code><a class="headerlink" href="#c.UV_EAI_AGAIN" title="Permalink to this definition">¶</a></dt>
<dd><p>temporary failure</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_BADFLAGS">
<code class="descname">UV_EAI_BADFLAGS</code><a class="headerlink" href="#c.UV_EAI_BADFLAGS" title="Permalink to this definition">¶</a></dt>
<dd><p>bad ai_flags value</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_BADHINTS">
<code class="descname">UV_EAI_BADHINTS</code><a class="headerlink" href="#c.UV_EAI_BADHINTS" title="Permalink to this definition">¶</a></dt>
<dd><p>invalid value for hints</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_CANCELED">
<code class="descname">UV_EAI_CANCELED</code><a class="headerlink" href="#c.UV_EAI_CANCELED" title="Permalink to this definition">¶</a></dt>
<dd><p>request canceled</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_FAIL">
<code class="descname">UV_EAI_FAIL</code><a class="headerlink" href="#c.UV_EAI_FAIL" title="Permalink to this definition">¶</a></dt>
<dd><p>permanent failure</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_FAMILY">
<code class="descname">UV_EAI_FAMILY</code><a class="headerlink" href="#c.UV_EAI_FAMILY" title="Permalink to this definition">¶</a></dt>
<dd><p>ai_family not supported</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_MEMORY">
<code class="descname">UV_EAI_MEMORY</code><a class="headerlink" href="#c.UV_EAI_MEMORY" title="Permalink to this definition">¶</a></dt>
<dd><p>out of memory</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_NODATA">
<code class="descname">UV_EAI_NODATA</code><a class="headerlink" href="#c.UV_EAI_NODATA" title="Permalink to this definition">¶</a></dt>
<dd><p>no address</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_NONAME">
<code class="descname">UV_EAI_NONAME</code><a class="headerlink" href="#c.UV_EAI_NONAME" title="Permalink to this definition">¶</a></dt>
<dd><p>unknown node or service</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_OVERFLOW">
<code class="descname">UV_EAI_OVERFLOW</code><a class="headerlink" href="#c.UV_EAI_OVERFLOW" title="Permalink to this definition">¶</a></dt>
<dd><p>argument buffer overflow</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_PROTOCOL">
<code class="descname">UV_EAI_PROTOCOL</code><a class="headerlink" href="#c.UV_EAI_PROTOCOL" title="Permalink to this definition">¶</a></dt>
<dd><p>resolved protocol is unknown</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_SERVICE">
<code class="descname">UV_EAI_SERVICE</code><a class="headerlink" href="#c.UV_EAI_SERVICE" title="Permalink to this definition">¶</a></dt>
<dd><p>service not available for socket type</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EAI_SOCKTYPE">
<code class="descname">UV_EAI_SOCKTYPE</code><a class="headerlink" href="#c.UV_EAI_SOCKTYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>socket type not supported</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EALREADY">
<code class="descname">UV_EALREADY</code><a class="headerlink" href="#c.UV_EALREADY" title="Permalink to this definition">¶</a></dt>
<dd><p>connection already in progress</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EBADF">
<code class="descname">UV_EBADF</code><a class="headerlink" href="#c.UV_EBADF" title="Permalink to this definition">¶</a></dt>
<dd><p>bad file descriptor</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EBUSY">
<code class="descname">UV_EBUSY</code><a class="headerlink" href="#c.UV_EBUSY" title="Permalink to this definition">¶</a></dt>
<dd><p>resource busy or locked</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ECANCELED">
<code class="descname">UV_ECANCELED</code><a class="headerlink" href="#c.UV_ECANCELED" title="Permalink to this definition">¶</a></dt>
<dd><p>operation canceled</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ECHARSET">
<code class="descname">UV_ECHARSET</code><a class="headerlink" href="#c.UV_ECHARSET" title="Permalink to this definition">¶</a></dt>
<dd><p>invalid Unicode character</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ECONNABORTED">
<code class="descname">UV_ECONNABORTED</code><a class="headerlink" href="#c.UV_ECONNABORTED" title="Permalink to this definition">¶</a></dt>
<dd><p>software caused connection abort</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ECONNREFUSED">
<code class="descname">UV_ECONNREFUSED</code><a class="headerlink" href="#c.UV_ECONNREFUSED" title="Permalink to this definition">¶</a></dt>
<dd><p>connection refused</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ECONNRESET">
<code class="descname">UV_ECONNRESET</code><a class="headerlink" href="#c.UV_ECONNRESET" title="Permalink to this definition">¶</a></dt>
<dd><p>connection reset by peer</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EDESTADDRREQ">
<code class="descname">UV_EDESTADDRREQ</code><a class="headerlink" href="#c.UV_EDESTADDRREQ" title="Permalink to this definition">¶</a></dt>
<dd><p>destination address required</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EEXIST">
<code class="descname">UV_EEXIST</code><a class="headerlink" href="#c.UV_EEXIST" title="Permalink to this definition">¶</a></dt>
<dd><p>file already exists</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EFAULT">
<code class="descname">UV_EFAULT</code><a class="headerlink" href="#c.UV_EFAULT" title="Permalink to this definition">¶</a></dt>
<dd><p>bad address in system call argument</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EFBIG">
<code class="descname">UV_EFBIG</code><a class="headerlink" href="#c.UV_EFBIG" title="Permalink to this definition">¶</a></dt>
<dd><p>file too large</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EHOSTUNREACH">
<code class="descname">UV_EHOSTUNREACH</code><a class="headerlink" href="#c.UV_EHOSTUNREACH" title="Permalink to this definition">¶</a></dt>
<dd><p>host is unreachable</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EINTR">
<code class="descname">UV_EINTR</code><a class="headerlink" href="#c.UV_EINTR" title="Permalink to this definition">¶</a></dt>
<dd><p>interrupted system call</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EINVAL">
<code class="descname">UV_EINVAL</code><a class="headerlink" href="#c.UV_EINVAL" title="Permalink to this definition">¶</a></dt>
<dd><p>invalid argument</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EIO">
<code class="descname">UV_EIO</code><a class="headerlink" href="#c.UV_EIO" title="Permalink to this definition">¶</a></dt>
<dd><p>i/o error</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EISCONN">
<code class="descname">UV_EISCONN</code><a class="headerlink" href="#c.UV_EISCONN" title="Permalink to this definition">¶</a></dt>
<dd><p>socket is already connected</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EISDIR">
<code class="descname">UV_EISDIR</code><a class="headerlink" href="#c.UV_EISDIR" title="Permalink to this definition">¶</a></dt>
<dd><p>illegal operation on a directory</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ELOOP">
<code class="descname">UV_ELOOP</code><a class="headerlink" href="#c.UV_ELOOP" title="Permalink to this definition">¶</a></dt>
<dd><p>too many symbolic links encountered</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EMFILE">
<code class="descname">UV_EMFILE</code><a class="headerlink" href="#c.UV_EMFILE" title="Permalink to this definition">¶</a></dt>
<dd><p>too many open files</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EMSGSIZE">
<code class="descname">UV_EMSGSIZE</code><a class="headerlink" href="#c.UV_EMSGSIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>message too long</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENAMETOOLONG">
<code class="descname">UV_ENAMETOOLONG</code><a class="headerlink" href="#c.UV_ENAMETOOLONG" title="Permalink to this definition">¶</a></dt>
<dd><p>name too long</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENETDOWN">
<code class="descname">UV_ENETDOWN</code><a class="headerlink" href="#c.UV_ENETDOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>network is down</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENETUNREACH">
<code class="descname">UV_ENETUNREACH</code><a class="headerlink" href="#c.UV_ENETUNREACH" title="Permalink to this definition">¶</a></dt>
<dd><p>network is unreachable</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENFILE">
<code class="descname">UV_ENFILE</code><a class="headerlink" href="#c.UV_ENFILE" title="Permalink to this definition">¶</a></dt>
<dd><p>file table overflow</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOBUFS">
<code class="descname">UV_ENOBUFS</code><a class="headerlink" href="#c.UV_ENOBUFS" title="Permalink to this definition">¶</a></dt>
<dd><p>no buffer space available</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENODEV">
<code class="descname">UV_ENODEV</code><a class="headerlink" href="#c.UV_ENODEV" title="Permalink to this definition">¶</a></dt>
<dd><p>no such device</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOENT">
<code class="descname">UV_ENOENT</code><a class="headerlink" href="#c.UV_ENOENT" title="Permalink to this definition">¶</a></dt>
<dd><p>no such file or directory</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOMEM">
<code class="descname">UV_ENOMEM</code><a class="headerlink" href="#c.UV_ENOMEM" title="Permalink to this definition">¶</a></dt>
<dd><p>not enough memory</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENONET">
<code class="descname">UV_ENONET</code><a class="headerlink" href="#c.UV_ENONET" title="Permalink to this definition">¶</a></dt>
<dd><p>machine is not on the network</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOPROTOOPT">
<code class="descname">UV_ENOPROTOOPT</code><a class="headerlink" href="#c.UV_ENOPROTOOPT" title="Permalink to this definition">¶</a></dt>
<dd><p>protocol not available</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOSPC">
<code class="descname">UV_ENOSPC</code><a class="headerlink" href="#c.UV_ENOSPC" title="Permalink to this definition">¶</a></dt>
<dd><p>no space left on device</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOSYS">
<code class="descname">UV_ENOSYS</code><a class="headerlink" href="#c.UV_ENOSYS" title="Permalink to this definition">¶</a></dt>
<dd><p>function not implemented</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOTCONN">
<code class="descname">UV_ENOTCONN</code><a class="headerlink" href="#c.UV_ENOTCONN" title="Permalink to this definition">¶</a></dt>
<dd><p>socket is not connected</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOTDIR">
<code class="descname">UV_ENOTDIR</code><a class="headerlink" href="#c.UV_ENOTDIR" title="Permalink to this definition">¶</a></dt>
<dd><p>not a directory</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOTEMPTY">
<code class="descname">UV_ENOTEMPTY</code><a class="headerlink" href="#c.UV_ENOTEMPTY" title="Permalink to this definition">¶</a></dt>
<dd><p>directory not empty</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOTSOCK">
<code class="descname">UV_ENOTSOCK</code><a class="headerlink" href="#c.UV_ENOTSOCK" title="Permalink to this definition">¶</a></dt>
<dd><p>socket operation on non-socket</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENOTSUP">
<code class="descname">UV_ENOTSUP</code><a class="headerlink" href="#c.UV_ENOTSUP" title="Permalink to this definition">¶</a></dt>
<dd><p>operation not supported on socket</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EPERM">
<code class="descname">UV_EPERM</code><a class="headerlink" href="#c.UV_EPERM" title="Permalink to this definition">¶</a></dt>
<dd><p>operation not permitted</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EPIPE">
<code class="descname">UV_EPIPE</code><a class="headerlink" href="#c.UV_EPIPE" title="Permalink to this definition">¶</a></dt>
<dd><p>broken pipe</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EPROTO">
<code class="descname">UV_EPROTO</code><a class="headerlink" href="#c.UV_EPROTO" title="Permalink to this definition">¶</a></dt>
<dd><p>protocol error</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EPROTONOSUPPORT">
<code class="descname">UV_EPROTONOSUPPORT</code><a class="headerlink" href="#c.UV_EPROTONOSUPPORT" title="Permalink to this definition">¶</a></dt>
<dd><p>protocol not supported</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EPROTOTYPE">
<code class="descname">UV_EPROTOTYPE</code><a class="headerlink" href="#c.UV_EPROTOTYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>protocol wrong type for socket</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ERANGE">
<code class="descname">UV_ERANGE</code><a class="headerlink" href="#c.UV_ERANGE" title="Permalink to this definition">¶</a></dt>
<dd><p>result too large</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EROFS">
<code class="descname">UV_EROFS</code><a class="headerlink" href="#c.UV_EROFS" title="Permalink to this definition">¶</a></dt>
<dd><p>read-only file system</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ESHUTDOWN">
<code class="descname">UV_ESHUTDOWN</code><a class="headerlink" href="#c.UV_ESHUTDOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>cannot send after transport endpoint shutdown</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ESPIPE">
<code class="descname">UV_ESPIPE</code><a class="headerlink" href="#c.UV_ESPIPE" title="Permalink to this definition">¶</a></dt>
<dd><p>invalid seek</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ESRCH">
<code class="descname">UV_ESRCH</code><a class="headerlink" href="#c.UV_ESRCH" title="Permalink to this definition">¶</a></dt>
<dd><p>no such process</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ETIMEDOUT">
<code class="descname">UV_ETIMEDOUT</code><a class="headerlink" href="#c.UV_ETIMEDOUT" title="Permalink to this definition">¶</a></dt>
<dd><p>connection timed out</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ETXTBSY">
<code class="descname">UV_ETXTBSY</code><a class="headerlink" href="#c.UV_ETXTBSY" title="Permalink to this definition">¶</a></dt>
<dd><p>text file is busy</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EXDEV">
<code class="descname">UV_EXDEV</code><a class="headerlink" href="#c.UV_EXDEV" title="Permalink to this definition">¶</a></dt>
<dd><p>cross-device link not permitted</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_UNKNOWN">
<code class="descname">UV_UNKNOWN</code><a class="headerlink" href="#c.UV_UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>unknown error</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EOF">
<code class="descname">UV_EOF</code><a class="headerlink" href="#c.UV_EOF" title="Permalink to this definition">¶</a></dt>
<dd><p>end of file</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_ENXIO">
<code class="descname">UV_ENXIO</code><a class="headerlink" href="#c.UV_ENXIO" title="Permalink to this definition">¶</a></dt>
<dd><p>no such device or address</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_EMLINK">
<code class="descname">UV_EMLINK</code><a class="headerlink" href="#c.UV_EMLINK" title="Permalink to this definition">¶</a></dt>
<dd><p>too many links</p>
</dd></dl>

</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_strerror">
const char* <code class="descname">uv_strerror</code><span class="sig-paren">(</span>int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_strerror" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the error message for the given error code.  Leaks a few bytes
of memory when you call it with an unknown error code.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_err_name">
const char* <code class="descname">uv_err_name</code><span class="sig-paren">(</span>int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_err_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the error name for the given error code.  Leaks a few bytes
of memory when you call it with an unknown error code.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_translate_sys_error">
int <code class="descname">uv_translate_sys_error</code><span class="sig-paren">(</span>int<em>&nbsp;sys_errno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_translate_sys_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the libuv error code equivalent to the given platform dependent error
code: POSIX error codes on Unix (the ones stored in <cite>errno</cite>), and Win32 error
codes on Windows (those returned by <cite>GetLastError()</cite> or <cite>WSAGetLastError()</cite>).</p>
<p>If <cite>sys_errno</cite> is already a libuv error, it is simply returned.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.10.0: </span>function declared public.</p>
</div>
</dd></dl>

</div>
</div>
<span id="document-version"></span><div class="section" id="version-checking-macros-and-functions">
<span id="version"></span><h4>Version-checking macros and functions<a class="headerlink" href="#version-checking-macros-and-functions" title="Permalink to this headline">¶</a></h4>
<p>Starting with version 1.0.0 libuv follows the <a class="reference external" href="http://semver.org">semantic versioning</a>
scheme. This means that new APIs can be introduced throughout the lifetime of
a major release. In this section you’ll find all macros and functions that
will allow you to write or compile code conditionally, in order to work with
multiple libuv versions.</p>
<div class="section" id="macros">
<h5>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h5>
<dl class="macro">
<dt id="c.UV_VERSION_MAJOR">
<code class="descname">UV_VERSION_MAJOR</code><a class="headerlink" href="#c.UV_VERSION_MAJOR" title="Permalink to this definition">¶</a></dt>
<dd><p>libuv version’s major number.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_VERSION_MINOR">
<code class="descname">UV_VERSION_MINOR</code><a class="headerlink" href="#c.UV_VERSION_MINOR" title="Permalink to this definition">¶</a></dt>
<dd><p>libuv version’s minor number.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_VERSION_PATCH">
<code class="descname">UV_VERSION_PATCH</code><a class="headerlink" href="#c.UV_VERSION_PATCH" title="Permalink to this definition">¶</a></dt>
<dd><p>libuv version’s patch number.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_VERSION_IS_RELEASE">
<code class="descname">UV_VERSION_IS_RELEASE</code><a class="headerlink" href="#c.UV_VERSION_IS_RELEASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Set to 1 to indicate a release version of libuv, 0 for a development
snapshot.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_VERSION_SUFFIX">
<code class="descname">UV_VERSION_SUFFIX</code><a class="headerlink" href="#c.UV_VERSION_SUFFIX" title="Permalink to this definition">¶</a></dt>
<dd><p>libuv version suffix. Certain development releases such as Release Candidates
might have a suffix such as “rc”.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_VERSION_HEX">
<code class="descname">UV_VERSION_HEX</code><a class="headerlink" href="#c.UV_VERSION_HEX" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the libuv version packed into a single integer. 8 bits are used for
each component, with the patch number stored in the 8 least significant
bits. E.g. for libuv 1.2.3 this would be 0x010203.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="functions">
<h5>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_version">
unsigned int <code class="descname">uv_version</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <a class="reference internal" href="#c.UV_VERSION_HEX" title="UV_VERSION_HEX"><code class="xref c c-macro docutils literal notranslate"><span class="pre">UV_VERSION_HEX</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_version_string">
const char* <code class="descname">uv_version_string</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_version_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the libuv version number as a string. For non-release versions the
version suffix is included.</p>
</dd></dl>

</div>
</div>
<span id="document-loop"></span><div class="section" id="uv-loop-t-event-loop">
<span id="loop"></span><h4><a class="reference internal" href="#c.uv_loop_t" title="uv_loop_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_loop_t</span></code></a> — Event loop<a class="headerlink" href="#uv-loop-t-event-loop" title="Permalink to this headline">¶</a></h4>
<p>The event loop is the central part of libuv’s functionality. It takes care
of polling for i/o and scheduling callbacks to be run based on different sources
of events.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_loop_t">
<code class="descname">uv_loop_t</code><a class="headerlink" href="#c.uv_loop_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_run_mode">
<code class="descname">uv_run_mode</code><a class="headerlink" href="#c.uv_run_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode used to run the loop with <a class="reference internal" href="#c.uv_run" title="uv_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_run()</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">UV_RUN_DEFAULT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">UV_RUN_ONCE</span><span class="p">,</span>
    <span class="n">UV_RUN_NOWAIT</span>
<span class="p">}</span> <span class="n">uv_run_mode</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_walk_cb">
void <code class="descname">(*uv_walk_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, void*<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_walk_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_walk" title="uv_walk"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_walk()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_loop_t.data">
void* <code class="descname">uv_loop_t.data</code><a class="headerlink" href="#c.uv_loop_t.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Space for user-defined arbitrary data. libuv does not use and does not
touch this field.</p>
</dd></dl>

</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_loop_init">
int <code class="descname">uv_loop_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the given <cite>uv_loop_t</cite> structure.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_configure">
int <code class="descname">uv_loop_configure</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, uv_loop_option<em>&nbsp;option</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_configure" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">New in version 1.0.2.</span></p>
</div>
<p>Set additional loop options.  You should normally call this before the
first call to <a class="reference internal" href="#c.uv_run" title="uv_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_run()</span></code></a> unless mentioned otherwise.</p>
<p>Returns 0 on success or a UV_E* error code on failure.  Be prepared to
handle UV_ENOSYS; it means the loop option is not supported by the platform.</p>
<p>Supported options:</p>
<ul>
<li><p class="first">UV_LOOP_BLOCK_SIGNAL: Block a signal when polling for new events.  The
second argument to <a class="reference internal" href="#c.uv_loop_configure" title="uv_loop_configure"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_loop_configure()</span></code></a> is the signal number.</p>
<p>This operation is currently only implemented for SIGPROF signals,
to suppress unnecessary wakeups when using a sampling profiler.
Requesting other signals will fail with UV_EINVAL.</p>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_close">
int <code class="descname">uv_loop_close</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases all internal loop resources. Call this function only when the loop
has finished executing and all open handles and requests have been closed,
or it will return UV_EBUSY. After this function returns, the user can free
the memory allocated for the loop.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_default_loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_default_loop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_default_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the initialized default loop. It may return NULL in case of
allocation failure.</p>
<p>This function is just a convenient way for having a global loop throughout
an application, the default loop is in no way different than the ones
initialized with <a class="reference internal" href="#c.uv_loop_init" title="uv_loop_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_loop_init()</span></code></a>. As such, the default loop can (and
should) be closed with <a class="reference internal" href="#c.uv_loop_close" title="uv_loop_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_loop_close()</span></code></a> so the resources associated
with it are freed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is not thread safe.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_run">
int <code class="descname">uv_run</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_run_mode" title="uv_run_mode">uv_run_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_run" title="Permalink to this definition">¶</a></dt>
<dd><p>This function runs the event loop. It will act differently depending on the
specified mode:</p>
<ul class="simple">
<li>UV_RUN_DEFAULT: Runs the event loop until there are no more active and
referenced handles or requests. Returns non-zero if <a class="reference internal" href="#c.uv_stop" title="uv_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_stop()</span></code></a>
was called and there are still active handles or requests.  Returns
zero in all other cases.</li>
<li>UV_RUN_ONCE: Poll for i/o once. Note that this function blocks if
there are no pending callbacks. Returns zero when done (no active handles
or requests left), or non-zero if more callbacks are expected (meaning
you should run the event loop again sometime in the future).</li>
<li>UV_RUN_NOWAIT: Poll for i/o once but don’t block if there are no
pending callbacks. Returns zero if done (no active handles
or requests left), or non-zero if more callbacks are expected (meaning
you should run the event loop again sometime in the future).</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_alive">
int <code class="descname">uv_loop_alive</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_alive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if there are referenced active handles, active
requests or closing handles in the loop.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_stop">
void <code class="descname">uv_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the event loop, causing <a class="reference internal" href="#c.uv_run" title="uv_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_run()</span></code></a> to end as soon as
possible. This will happen not sooner than the next loop iteration.
If this function was called before blocking for i/o, the loop won’t block
for i/o on this iteration.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_size">
size_t <code class="descname">uv_loop_size</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the <cite>uv_loop_t</cite> structure. Useful for FFI binding
writers who don’t want to know the structure layout.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_backend_fd">
int <code class="descname">uv_backend_fd</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_backend_fd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get backend file descriptor. Only kqueue, epoll and event ports are
supported.</p>
<p>This can be used in conjunction with <cite>uv_run(loop, UV_RUN_NOWAIT)</cite> to
poll in one thread and run the event loop’s callbacks in another see
test/test-embed.c for an example.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Embedding a kqueue fd in another kqueue pollset doesn’t work on all platforms. It’s not
an error to add the fd but it never generates events.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_backend_timeout">
int <code class="descname">uv_backend_timeout</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_backend_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the poll timeout. The return value is in milliseconds, or -1 for no
timeout.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_now">
uint64_t <code class="descname">uv_now</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_now" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current timestamp in milliseconds. The timestamp is cached at
the start of the event loop tick, see <a class="reference internal" href="#c.uv_update_time" title="uv_update_time"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_update_time()</span></code></a> for details
and rationale.</p>
<p>The timestamp increases monotonically from some arbitrary point in time.
Don’t make assumptions about the starting point, you will only get
disappointed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use <a class="reference internal" href="index.html#c.uv_hrtime" title="uv_hrtime"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_hrtime()</span></code></a> if you need sub-millisecond granularity.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_update_time">
void <code class="descname">uv_update_time</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_update_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the event loop’s concept of “now”. Libuv caches the current time
at the start of the event loop tick in order to reduce the number of
time-related system calls.</p>
<p>You won’t normally need to call this function unless you have callbacks
that block the event loop for longer periods of time, where “longer” is
somewhat subjective but probably on the order of a millisecond or more.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_walk">
void <code class="descname">uv_walk</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_walk_cb" title="uv_walk_cb">uv_walk_cb</a><em>&nbsp;walk_cb</em>, void*<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Walk the list of handles: <cite>walk_cb</cite> will be executed with the given <cite>arg</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_fork">
int <code class="descname">uv_loop_fork</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_fork" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<p>Reinitialize any kernel state necessary in the child process after
a <a class="reference external" href="http://linux.die.net/man/2/fork">fork(2)</a> system call.</p>
<p>Previously started watchers will continue to be started in the
child process.</p>
<p>It is necessary to explicitly call this function on every event
loop created in the parent process that you plan to continue to
use in the child, including the default loop (even if you don’t
continue to use it in the parent). This function must be called
before calling <a class="reference internal" href="#c.uv_run" title="uv_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_run()</span></code></a> or any other API function using
the loop in the child. Failure to do so will result in undefined
behaviour, possibly including duplicate events delivered to both
parent and child or aborting the child process.</p>
<p>When possible, it is preferred to create a new loop in the child
process instead of reusing a loop created in the parent. New loops
created in the child process after the fork should not use this
function.</p>
<p>This function is not implemented on Windows, where it returns <code class="docutils literal notranslate"><span class="pre">UV_ENOSYS</span></code>.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">This function is experimental. It may contain bugs, and is subject to
change or removal. API and ABI stability is not guaranteed.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Mac OS X, if directory FS event handles were in use in the
parent process <em>for any event loop</em>, the child process will no
longer be able to use the most efficient FSEvent
implementation. Instead, uses of directory FS event handles in
the child will fall back to the same implementation used for
files and on other kqueue-based systems.</p>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">On AIX and SunOS, FS event handles that were already started in
the parent process at the time of forking will <em>not</em> deliver
events in the child process; they must be closed and restarted.
On all other platforms, they will continue to work normally
without any further intervention.</p>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Any previous value returned from <a class="reference internal" href="#c.uv_backend_fd" title="uv_backend_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_backend_fd()</span></code></a> is now
invalid. That function must be called again to determine the
correct backend file descriptor.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_get_data">
void* <code class="descname">uv_loop_get_data</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>loop-&gt;data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_loop_set_data">
void* <code class="descname">uv_loop_set_data</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, void*<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loop_set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <cite>loop-&gt;data</cite> to <cite>data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

</div>
</div>
<span id="document-handle"></span><div class="section" id="uv-handle-t-base-handle">
<span id="handle"></span><h4><a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> — Base handle<a class="headerlink" href="#uv-handle-t-base-handle" title="Permalink to this headline">¶</a></h4>
<p><cite>uv_handle_t</cite> is the base type for all libuv handle types.</p>
<p>Structures are aligned so that any libuv handle can be cast to <cite>uv_handle_t</cite>.
All API functions defined here work with any handle type.</p>
<p>Libuv handles are not movable. Pointers to handle structures passed to
functions must remain valid for the duration of the requested operation. Take
care when using stack allocated handles.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_handle_t">
<code class="descname">uv_handle_t</code><a class="headerlink" href="#c.uv_handle_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The base libuv handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_handle_type">
<code class="descname">uv_handle_type</code><a class="headerlink" href="#c.uv_handle_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The kind of the libuv handle.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
  <span class="n">UV_UNKNOWN_HANDLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">UV_ASYNC</span><span class="p">,</span>
  <span class="n">UV_CHECK</span><span class="p">,</span>
  <span class="n">UV_FS_EVENT</span><span class="p">,</span>
  <span class="n">UV_FS_POLL</span><span class="p">,</span>
  <span class="n">UV_HANDLE</span><span class="p">,</span>
  <span class="n">UV_IDLE</span><span class="p">,</span>
  <span class="n">UV_NAMED_PIPE</span><span class="p">,</span>
  <span class="n">UV_POLL</span><span class="p">,</span>
  <span class="n">UV_PREPARE</span><span class="p">,</span>
  <span class="n">UV_PROCESS</span><span class="p">,</span>
  <span class="n">UV_STREAM</span><span class="p">,</span>
  <span class="n">UV_TCP</span><span class="p">,</span>
  <span class="n">UV_TIMER</span><span class="p">,</span>
  <span class="n">UV_TTY</span><span class="p">,</span>
  <span class="n">UV_UDP</span><span class="p">,</span>
  <span class="n">UV_SIGNAL</span><span class="p">,</span>
  <span class="n">UV_FILE</span><span class="p">,</span>
  <span class="n">UV_HANDLE_TYPE_MAX</span>
<span class="p">}</span> <span class="n">uv_handle_type</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_any_handle">
<code class="descname">uv_any_handle</code><a class="headerlink" href="#c.uv_any_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Union of all handle types.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_alloc_cb">
void <code class="descname">(*uv_alloc_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, size_t<em>&nbsp;suggested_size</em>, <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a>*<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_alloc_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="index.html#c.uv_read_start" title="uv_read_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_read_start()</span></code></a> and
<a class="reference internal" href="index.html#c.uv_udp_recv_start" title="uv_udp_recv_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_recv_start()</span></code></a>. The user must allocate memory and fill the supplied
<a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_buf_t</span></code></a> structure. If NULL is assigned as the buffer’s base or 0 as its length,
a <code class="docutils literal notranslate"><span class="pre">UV_ENOBUFS</span></code> error will be triggered in the <a class="reference internal" href="index.html#c.uv_udp_recv_cb" title="uv_udp_recv_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_udp_recv_cb</span></code></a> or the
<a class="reference internal" href="index.html#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_read_cb</span></code></a> callback.</p>
<p>A suggested size (65536 at the moment in most cases) is provided, but it’s just an indication,
not related in any way to the pending data to be read. The user is free to allocate the amount
of memory they decide.</p>
<p>As an example, applications with custom allocation schemes such as using freelists, allocation
pools or slab based allocators may decide to use a different size which matches the memory
chunks they already have.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">my_alloc_cb</span><span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">suggested_size</span><span class="p">,</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">suggested_size</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="nb">len</span> <span class="o">=</span> <span class="n">suggested_size</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_close_cb">
void <code class="descname">(*uv_close_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_close_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_close" title="uv_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_close()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_handle_t.loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_handle_t.loop</code><a class="headerlink" href="#c.uv_handle_t.loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the <a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_loop_t</span></code></a> where the handle is running on. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_handle_t.type">
<a class="reference internal" href="index.html#c.uv_handle_type" title="uv_handle_type">uv_handle_type</a> <code class="descname">uv_handle_t.type</code><a class="headerlink" href="#c.uv_handle_t.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#c.uv_handle_type" title="uv_handle_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_type</span></code></a>, indicating the type of the underlying handle. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_handle_t.data">
void* <code class="descname">uv_handle_t.data</code><a class="headerlink" href="#c.uv_handle_t.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Space for user-defined arbitrary data. libuv does not use this field.</p>
</dd></dl>

</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_is_active">
int <code class="descname">uv_is_active</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if the handle is active, zero if it’s inactive. What
“active” means depends on the type of handle:</p>
<ul class="simple">
<li>A uv_async_t handle is always active and cannot be deactivated, except
by closing it with uv_close().</li>
<li>A uv_pipe_t, uv_tcp_t, uv_udp_t, etc. handle - basically any handle that
deals with i/o - is active when it is doing something that involves i/o,
like reading, writing, connecting, accepting new connections, etc.</li>
<li>A uv_check_t, uv_idle_t, uv_timer_t, etc. handle is active when it has
been started with a call to uv_check_start(), uv_idle_start(), etc.</li>
</ul>
<p>Rule of thumb: if a handle of type <cite>uv_foo_t</cite> has a <cite>uv_foo_start()</cite>
function, then it’s active from the moment that function is called.
Likewise, <cite>uv_foo_stop()</cite> deactivates the handle again.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_closing">
int <code class="descname">uv_is_closing</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if the handle is closing or closed, zero otherwise.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function should only be used between the initialization of the handle and the
arrival of the close callback.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_close">
void <code class="descname">uv_close</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_close_cb" title="uv_close_cb">uv_close_cb</a><em>&nbsp;close_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Request handle to be closed. <cite>close_cb</cite> will be called asynchronously after
this call. This MUST be called on each handle before memory is released.</p>
<p>Handles that wrap file descriptors are closed immediately but
<cite>close_cb</cite> will still be deferred to the next iteration of the event loop.
It gives you a chance to free up any resources associated with the handle.</p>
<p>In-progress requests, like uv_connect_t or uv_write_t, are cancelled and
have their callbacks called asynchronously with status=UV_ECANCELED.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_ref">
void <code class="descname">uv_ref</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Reference the given handle. References are idempotent, that is, if a handle
is already referenced calling this function again will have no effect.</p>
<p>See <a class="reference internal" href="#refcount"><span class="std std-ref">Reference counting</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_unref">
void <code class="descname">uv_unref</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-reference the given handle. References are idempotent, that is, if a handle
is not referenced calling this function again will have no effect.</p>
<p>See <a class="reference internal" href="#refcount"><span class="std std-ref">Reference counting</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_has_ref">
int <code class="descname">uv_has_ref</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_has_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns non-zero if the handle referenced, zero otherwise.</p>
<p>See <a class="reference internal" href="#refcount"><span class="std std-ref">Reference counting</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_size">
size_t <code class="descname">uv_handle_size</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_type" title="uv_handle_type">uv_handle_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the given handle type. Useful for FFI binding writers
who don’t want to know the structure layout.</p>
</dd></dl>

</div>
<div class="section" id="miscellaneous-api-functions">
<h5>Miscellaneous API functions<a class="headerlink" href="#miscellaneous-api-functions" title="Permalink to this headline">¶</a></h5>
<p>The following API functions take a <a class="reference internal" href="#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> argument but they work
just for some handle types.</p>
<dl class="function">
<dt id="c.uv_send_buffer_size">
int <code class="descname">uv_send_buffer_size</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, int*<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_send_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets or sets the size of the send buffer that the operating
system uses for the socket.</p>
<p>If <cite>*value</cite> == 0, it will return the current send buffer size,
otherwise it will use <cite>*value</cite> to set the new send buffer size.</p>
<p>This function works for TCP, pipe and UDP handles on Unix and for TCP and
UDP handles on Windows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linux will set double the size and return double the size of the original set value.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_recv_buffer_size">
int <code class="descname">uv_recv_buffer_size</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, int*<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_recv_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets or sets the size of the receive buffer that the operating
system uses for the socket.</p>
<p>If <cite>*value</cite> == 0, it will return the current receive buffer size,
otherwise it will use <cite>*value</cite> to set the new receive buffer size.</p>
<p>This function works for TCP, pipe and UDP handles on Unix and for TCP and
UDP handles on Windows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Linux will set double the size and return double the size of the original set value.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fileno">
int <code class="descname">uv_fileno</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_os_fd_t" title="uv_os_fd_t">uv_os_fd_t</a>*<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the platform dependent file descriptor equivalent.</p>
<p>The following handles are supported: TCP, pipes, TTY, UDP and poll. Passing
any other handle type will fail with <cite>UV_EINVAL</cite>.</p>
<p>If a handle doesn’t have an attached file descriptor yet or the handle
itself has been closed, this function will return <cite>UV_EBADF</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be very careful when using this function. libuv assumes it’s in control of the file
descriptor so any change to it may lead to malfunction.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_get_loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_handle_get_loop</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_get_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;loop</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_get_data">
void* <code class="descname">uv_handle_get_data</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_set_data">
void* <code class="descname">uv_handle_set_data</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em>, void*<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <cite>handle-&gt;data</cite> to <cite>data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_get_type">
<a class="reference internal" href="index.html#c.uv_handle_type" title="uv_handle_type">uv_handle_type</a> <code class="descname">uv_handle_get_type</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t">uv_handle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;type</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_handle_type_name">
const char* <code class="descname">uv_handle_type_name</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_handle_type" title="uv_handle_type">uv_handle_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_handle_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name for the equivalent struct for a given handle type,
e.g. <cite>“pipe”</cite> (as in <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_pipe_t</span></code></a>) for <cite>UV_NAMED_PIPE</cite>.</p>
<p>If no such handle type exists, this returns <cite>NULL</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="reference-counting">
<span id="refcount"></span><h5>Reference counting<a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h5>
<p>The libuv event loop (if run in the default mode) will run until there are no
active <cite>and</cite> referenced handles left. The user can force the loop to exit early
by unreferencing handles which are active, for example by calling <a class="reference internal" href="#c.uv_unref" title="uv_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_unref()</span></code></a>
after calling <a class="reference internal" href="index.html#c.uv_timer_start" title="uv_timer_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_timer_start()</span></code></a>.</p>
<p>A handle can be referenced or unreferenced, the refcounting scheme doesn’t use
a counter, so both operations are idempotent.</p>
<p>All handles are referenced when active by default, see <a class="reference internal" href="#c.uv_is_active" title="uv_is_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_is_active()</span></code></a>
for a more detailed explanation on what being <cite>active</cite> involves.</p>
</div>
</div>
<span id="document-request"></span><div class="section" id="uv-req-t-base-request">
<span id="request"></span><h4><a class="reference internal" href="#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> — Base request<a class="headerlink" href="#uv-req-t-base-request" title="Permalink to this headline">¶</a></h4>
<p><cite>uv_req_t</cite> is the base type for all libuv request types.</p>
<p>Structures are aligned so that any libuv request can be cast to <cite>uv_req_t</cite>.
All API functions defined here work with any request type.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_req_t">
<code class="descname">uv_req_t</code><a class="headerlink" href="#c.uv_req_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The base libuv request structure.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_any_req">
<code class="descname">uv_any_req</code><a class="headerlink" href="#c.uv_any_req" title="Permalink to this definition">¶</a></dt>
<dd><p>Union of all request types.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_req_t.data">
void* <code class="descname">uv_req_t.data</code><a class="headerlink" href="#c.uv_req_t.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Space for user-defined arbitrary data. libuv does not use this field.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_req_t.type">
uv_req_type <code class="descname">uv_req_t.type</code><a class="headerlink" href="#c.uv_req_t.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicated the type of request. Readonly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">UV_UNKNOWN_REQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">UV_REQ</span><span class="p">,</span>
    <span class="n">UV_CONNECT</span><span class="p">,</span>
    <span class="n">UV_WRITE</span><span class="p">,</span>
    <span class="n">UV_SHUTDOWN</span><span class="p">,</span>
    <span class="n">UV_UDP_SEND</span><span class="p">,</span>
    <span class="n">UV_FS</span><span class="p">,</span>
    <span class="n">UV_WORK</span><span class="p">,</span>
    <span class="n">UV_GETADDRINFO</span><span class="p">,</span>
    <span class="n">UV_GETNAMEINFO</span><span class="p">,</span>
    <span class="n">UV_REQ_TYPE_PRIVATE</span><span class="p">,</span>
    <span class="n">UV_REQ_TYPE_MAX</span><span class="p">,</span>
<span class="p">}</span> <span class="n">uv_req_type</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_cancel">
int <code class="descname">uv_cancel</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t">uv_req_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel a pending request. Fails if the request is executing or has finished
executing.</p>
<p>Returns 0 on success, or an error code &lt; 0 on failure.</p>
<p>Only cancellation of <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_t</span></code></a>, <a class="reference internal" href="index.html#c.uv_getaddrinfo_t" title="uv_getaddrinfo_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_getaddrinfo_t</span></code></a>,
<a class="reference internal" href="index.html#c.uv_getnameinfo_t" title="uv_getnameinfo_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_getnameinfo_t</span></code></a> and <a class="reference internal" href="index.html#c.uv_work_t" title="uv_work_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_work_t</span></code></a> requests is
currently supported.</p>
<p>Cancelled requests have their callbacks invoked some time in the future.
It’s <strong>not</strong> safe to free the memory associated with the request until the
callback is called.</p>
<p>Here is how cancellation is reported to the callback:</p>
<ul class="simple">
<li>A <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_t</span></code></a> request has its req-&gt;result field set to <cite>UV_ECANCELED</cite>.</li>
<li>A <a class="reference internal" href="index.html#c.uv_work_t" title="uv_work_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_work_t</span></code></a>, <a class="reference internal" href="index.html#c.uv_getaddrinfo_t" title="uv_getaddrinfo_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_getaddrinfo_t</span></code></a> or c:type:<cite>uv_getnameinfo_t</cite>
request has its callback invoked with status == <cite>UV_ECANCELED</cite>.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="c.uv_req_size">
size_t <code class="descname">uv_req_size</code><span class="sig-paren">(</span>uv_req_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_req_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the given request type. Useful for FFI binding writers
who don’t want to know the structure layout.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_req_get_data">
void* <code class="descname">uv_req_get_data</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t">uv_req_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_req_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>req-&gt;data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_req_set_data">
void* <code class="descname">uv_req_set_data</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t">uv_req_t</a>*<em>&nbsp;req</em>, void*<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_req_set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <cite>req-&gt;data</cite> to <cite>data</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_req_get_type">
uv_req_type <code class="descname">uv_req_get_type</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t">uv_req_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_req_get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>req-&gt;type</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_req_type_name">
const char* <code class="descname">uv_req_type_name</code><span class="sig-paren">(</span>uv_req_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_req_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name for the equivalent struct for a given request type,
e.g. <cite>“connect”</cite> (as in <a class="reference internal" href="index.html#c.uv_connect_t" title="uv_connect_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_connect_t</span></code></a>) for <cite>UV_CONNECT</cite>.</p>
<p>If no such request type exists, this returns <cite>NULL</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

</div>
</div>
<span id="document-timer"></span><div class="section" id="uv-timer-t-timer-handle">
<span id="timer"></span><h4><a class="reference internal" href="#c.uv_timer_t" title="uv_timer_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_timer_t</span></code></a> — Timer handle<a class="headerlink" href="#uv-timer-t-timer-handle" title="Permalink to this headline">¶</a></h4>
<p>Timer handles are used to schedule callbacks to be called in the future.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_timer_t">
<code class="descname">uv_timer_t</code><a class="headerlink" href="#c.uv_timer_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Timer handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_timer_cb">
void <code class="descname">(*uv_timer_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_timer_start" title="uv_timer_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_timer_start()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_timer_init">
int <code class="descname">uv_timer_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_timer_start">
int <code class="descname">uv_timer_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_timer_cb" title="uv_timer_cb">uv_timer_cb</a><em>&nbsp;cb</em>, uint64_t<em>&nbsp;timeout</em>, uint64_t<em>&nbsp;repeat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the timer. <cite>timeout</cite> and <cite>repeat</cite> are in milliseconds.</p>
<p>If <cite>timeout</cite> is zero, the callback fires on the next event loop iteration.
If <cite>repeat</cite> is non-zero, the callback fires first after <cite>timeout</cite>
milliseconds and then repeatedly after <cite>repeat</cite> milliseconds.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Does not update the event loop’s concept of “now”. See <a class="reference internal" href="index.html#c.uv_update_time" title="uv_update_time"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_update_time()</span></code></a> for more information.</p>
<p class="last">If the timer is already active, it is simply updated.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_timer_stop">
int <code class="descname">uv_timer_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the timer, the callback will not be called anymore.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_timer_again">
int <code class="descname">uv_timer_again</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_again" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the timer, and if it is repeating restart it using the repeat value
as the timeout. If the timer has never been started before it returns
UV_EINVAL.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_timer_set_repeat">
void <code class="descname">uv_timer_set_repeat</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em>, uint64_t<em>&nbsp;repeat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_set_repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the repeat interval value in milliseconds. The timer will be scheduled
to run on the given interval, regardless of the callback execution
duration, and will follow normal timer semantics in the case of a
time-slice overrun.</p>
<p>For example, if a 50ms repeating timer first runs for 17ms, it will be
scheduled to run again 33ms later. If other tasks consume more than the
33ms following the first timer callback, then the callback will run as soon
as possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the repeat value is set from a timer callback it does not immediately take effect.
If the timer was non-repeating before, it will have been stopped. If it was repeating,
then the old repeat value will have been used to schedule the next timeout.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_timer_get_repeat">
uint64_t <code class="descname">uv_timer_get_repeat</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_timer_t" title="uv_timer_t">uv_timer_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_timer_get_repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the timer repeat value.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-prepare"></span><div class="section" id="uv-prepare-t-prepare-handle">
<span id="prepare"></span><h4><a class="reference internal" href="#c.uv_prepare_t" title="uv_prepare_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_prepare_t</span></code></a> — Prepare handle<a class="headerlink" href="#uv-prepare-t-prepare-handle" title="Permalink to this headline">¶</a></h4>
<p>Prepare handles will run the given callback once per loop iteration, right
before polling for i/o.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_prepare_t">
<code class="descname">uv_prepare_t</code><a class="headerlink" href="#c.uv_prepare_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_prepare_cb">
void <code class="descname">(*uv_prepare_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_prepare_t" title="uv_prepare_t">uv_prepare_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_prepare_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_prepare_start" title="uv_prepare_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_prepare_start()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_prepare_init">
int <code class="descname">uv_prepare_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_prepare_t" title="uv_prepare_t">uv_prepare_t</a>*<em>&nbsp;prepare</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_prepare_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_prepare_start">
int <code class="descname">uv_prepare_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_prepare_t" title="uv_prepare_t">uv_prepare_t</a>*<em>&nbsp;prepare</em>, <a class="reference internal" href="index.html#c.uv_prepare_cb" title="uv_prepare_cb">uv_prepare_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_prepare_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the handle with the given callback.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_prepare_stop">
int <code class="descname">uv_prepare_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_prepare_t" title="uv_prepare_t">uv_prepare_t</a>*<em>&nbsp;prepare</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_prepare_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the handle, the callback will no longer be called.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-check"></span><div class="section" id="uv-check-t-check-handle">
<span id="check"></span><h4><a class="reference internal" href="#c.uv_check_t" title="uv_check_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_check_t</span></code></a> — Check handle<a class="headerlink" href="#uv-check-t-check-handle" title="Permalink to this headline">¶</a></h4>
<p>Check handles will run the given callback once per loop iteration, right
after polling for i/o.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_check_t">
<code class="descname">uv_check_t</code><a class="headerlink" href="#c.uv_check_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Check handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_check_cb">
void <code class="descname">(*uv_check_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_check_t" title="uv_check_t">uv_check_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_check_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_check_start" title="uv_check_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_check_start()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_check_init">
int <code class="descname">uv_check_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_check_t" title="uv_check_t">uv_check_t</a>*<em>&nbsp;check</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_check_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_check_start">
int <code class="descname">uv_check_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_check_t" title="uv_check_t">uv_check_t</a>*<em>&nbsp;check</em>, <a class="reference internal" href="index.html#c.uv_check_cb" title="uv_check_cb">uv_check_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_check_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the handle with the given callback.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_check_stop">
int <code class="descname">uv_check_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_check_t" title="uv_check_t">uv_check_t</a>*<em>&nbsp;check</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_check_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the handle, the callback will no longer be called.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-idle"></span><div class="section" id="uv-idle-t-idle-handle">
<span id="idle"></span><h4><a class="reference internal" href="#c.uv_idle_t" title="uv_idle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_idle_t</span></code></a> — Idle handle<a class="headerlink" href="#uv-idle-t-idle-handle" title="Permalink to this headline">¶</a></h4>
<p>Idle handles will run the given callback once per loop iteration, right
before the <a class="reference internal" href="index.html#c.uv_prepare_t" title="uv_prepare_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_prepare_t</span></code></a> handles.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The notable difference with prepare handles is that when there are active idle handles,
the loop will perform a zero timeout poll instead of blocking for i/o.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Despite the name, idle handles will get their callbacks called on every loop iteration,
not when the loop is actually “idle”.</p>
</div>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_idle_t">
<code class="descname">uv_idle_t</code><a class="headerlink" href="#c.uv_idle_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Idle handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_idle_cb">
void <code class="descname">(*uv_idle_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_idle_t" title="uv_idle_t">uv_idle_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_idle_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_idle_start" title="uv_idle_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_idle_start()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_idle_init">
int <code class="descname">uv_idle_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_idle_t" title="uv_idle_t">uv_idle_t</a>*<em>&nbsp;idle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_idle_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_idle_start">
int <code class="descname">uv_idle_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_idle_t" title="uv_idle_t">uv_idle_t</a>*<em>&nbsp;idle</em>, <a class="reference internal" href="index.html#c.uv_idle_cb" title="uv_idle_cb">uv_idle_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_idle_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the handle with the given callback.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_idle_stop">
int <code class="descname">uv_idle_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_idle_t" title="uv_idle_t">uv_idle_t</a>*<em>&nbsp;idle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_idle_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the handle, the callback will no longer be called.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-async"></span><div class="section" id="uv-async-t-async-handle">
<span id="async"></span><h4><a class="reference internal" href="#c.uv_async_t" title="uv_async_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_async_t</span></code></a> — Async handle<a class="headerlink" href="#uv-async-t-async-handle" title="Permalink to this headline">¶</a></h4>
<p>Async handles allow the user to “wakeup” the event loop and get a callback
called from another thread.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_async_t">
<code class="descname">uv_async_t</code><a class="headerlink" href="#c.uv_async_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Async handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_async_cb">
void <code class="descname">(*uv_async_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_async_t" title="uv_async_t">uv_async_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_async_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_async_init" title="uv_async_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_async_init()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_async_init">
int <code class="descname">uv_async_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_async_t" title="uv_async_t">uv_async_t</a>*<em>&nbsp;async</em>, <a class="reference internal" href="index.html#c.uv_async_cb" title="uv_async_cb">uv_async_cb</a><em>&nbsp;async_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_async_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle. A NULL callback is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 on success, or an error code &lt; 0 on failure.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike other handle initialization  functions, it immediately starts the handle.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_async_send">
int <code class="descname">uv_async_send</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_async_t" title="uv_async_t">uv_async_t</a>*<em>&nbsp;async</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_async_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake up the event loop and call the async handle’s callback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 on success, or an error code &lt; 0 on failure.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s safe to call this function from any thread. The callback will be called on the
loop thread.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">libuv will coalesce calls to <a class="reference internal" href="#c.uv_async_send" title="uv_async_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_async_send()</span></code></a>, that is, not every call to it will
yield an execution of the callback. For example: if <a class="reference internal" href="#c.uv_async_send" title="uv_async_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_async_send()</span></code></a> is called 5
times in a row before the callback is called, the callback will only be called once. If
<a class="reference internal" href="#c.uv_async_send" title="uv_async_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_async_send()</span></code></a> is called again after the callback was called, it will be called
again.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-poll"></span><div class="section" id="uv-poll-t-poll-handle">
<span id="poll"></span><h4><a class="reference internal" href="#c.uv_poll_t" title="uv_poll_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_poll_t</span></code></a> — Poll handle<a class="headerlink" href="#uv-poll-t-poll-handle" title="Permalink to this headline">¶</a></h4>
<p>Poll handles are used to watch file descriptors for readability,
writability and disconnection similar to the purpose of <a class="reference external" href="http://linux.die.net/man/2/poll">poll(2)</a>.</p>
<p>The purpose of poll handles is to enable integrating external libraries that
rely on the event loop to signal it about the socket status changes, like
c-ares or libssh2. Using uv_poll_t for any other purpose is not recommended;
<a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tcp_t</span></code></a>, <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_udp_t</span></code></a>, etc. provide an implementation that is faster and
more scalable than what can be achieved with <a class="reference internal" href="#c.uv_poll_t" title="uv_poll_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_poll_t</span></code></a>, especially on
Windows.</p>
<p>It is possible that poll handles occasionally signal that a file descriptor is
readable or writable even when it isn’t. The user should therefore always
be prepared to handle EAGAIN or equivalent when it attempts to read from or
write to the fd.</p>
<p>It is not okay to have multiple active poll handles for the same socket, this
can cause libuv to busyloop or otherwise malfunction.</p>
<p>The user should not close a file descriptor while it is being polled by an
active poll handle. This can cause the handle to report an error,
but it might also start polling another socket. However the fd can be safely
closed immediately after a call to <a class="reference internal" href="#c.uv_poll_stop" title="uv_poll_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_poll_stop()</span></code></a> or <a class="reference internal" href="index.html#c.uv_close" title="uv_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_close()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On windows only sockets can be polled with poll handles. On Unix any file
descriptor that would be accepted by <a class="reference external" href="http://linux.die.net/man/2/poll">poll(2)</a> can be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On AIX, watching for disconnection is not supported.</p>
</div>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_poll_t">
<code class="descname">uv_poll_t</code><a class="headerlink" href="#c.uv_poll_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_poll_cb">
void <code class="descname">(*uv_poll_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_poll_t" title="uv_poll_t">uv_poll_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;status</em>, int<em>&nbsp;events</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_poll_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_poll_start" title="uv_poll_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_poll_start()</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_poll_event">
<code class="descname">uv_poll_event</code><a class="headerlink" href="#c.uv_poll_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll event types</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">uv_poll_event</span> <span class="p">{</span>
    <span class="n">UV_READABLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">UV_WRITABLE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">UV_DISCONNECT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">UV_PRIORITIZED</span> <span class="o">=</span> <span class="mi">8</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_poll_init">
int <code class="descname">uv_poll_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_poll_t" title="uv_poll_t">uv_poll_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_poll_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle using a file descriptor.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.2.2: </span>the file descriptor is set to non-blocking mode.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_poll_init_socket">
int <code class="descname">uv_poll_init_socket</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_poll_t" title="uv_poll_t">uv_poll_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_os_sock_t" title="uv_os_sock_t">uv_os_sock_t</a><em>&nbsp;socket</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_poll_init_socket" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle using a socket descriptor. On Unix this is identical
to <a class="reference internal" href="#c.uv_poll_init" title="uv_poll_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_poll_init()</span></code></a>. On windows it takes a SOCKET handle.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.2.2: </span>the socket is set to non-blocking mode.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_poll_start">
int <code class="descname">uv_poll_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_poll_t" title="uv_poll_t">uv_poll_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;events</em>, <a class="reference internal" href="index.html#c.uv_poll_cb" title="uv_poll_cb">uv_poll_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_poll_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts polling the file descriptor. <cite>events</cite> is a bitmask made up of
UV_READABLE, UV_WRITABLE, UV_PRIORITIZED and UV_DISCONNECT. As soon as an
event is detected the callback will be called with <cite>status</cite> set to 0, and the
detected events set on the <cite>events</cite> field.</p>
<p>The UV_PRIORITIZED event is used to watch for sysfs interrupts or TCP out-of-band
messages.</p>
<p>The UV_DISCONNECT event is optional in the sense that it may not be
reported and the user is free to ignore it, but it can help optimize the shutdown
path because an extra read or write call might be avoided.</p>
<p>If an error happens while polling, <cite>status</cite> will be &lt; 0 and corresponds
with one of the UV_E* error codes (see <a class="reference internal" href="index.html#errors"><span class="std std-ref">Error handling</span></a>). The user should
not close the socket while the handle is active. If the user does that
anyway, the callback <em>may</em> be called reporting an error status, but this
is <strong>not</strong> guaranteed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calling <a class="reference internal" href="#c.uv_poll_start" title="uv_poll_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_poll_start()</span></code></a> on a handle that is already active is fine. Doing so
will update the events mask that is being watched for.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Though UV_DISCONNECT can be set, it is unsupported on AIX and as such will not be set
on the <cite>events</cite> field in the callback.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9.0: </span>Added the UV_DISCONNECT event.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.14.0: </span>Added the UV_PRIORITIZED event.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_poll_stop">
int <code class="descname">uv_poll_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_poll_t" title="uv_poll_t">uv_poll_t</a>*<em>&nbsp;poll</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_poll_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop polling the file descriptor, the callback will no longer be called.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-signal"></span><div class="section" id="uv-signal-t-signal-handle">
<span id="signal"></span><h4><a class="reference internal" href="#c.uv_signal_t" title="uv_signal_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_signal_t</span></code></a> — Signal handle<a class="headerlink" href="#uv-signal-t-signal-handle" title="Permalink to this headline">¶</a></h4>
<p>Signal handles implement Unix style signal handling on a per-event loop bases.</p>
<p>Reception of some signals is emulated on Windows:</p>
<ul class="simple">
<li>SIGINT is normally delivered when the user presses CTRL+C. However, like
on Unix, it is not generated when terminal raw mode is enabled.</li>
<li>SIGBREAK is delivered when the user pressed CTRL + BREAK.</li>
<li>SIGHUP is generated when the user closes the console window. On SIGHUP the
program is given approximately 10 seconds to perform cleanup. After that
Windows will unconditionally terminate it.</li>
</ul>
<p>Watchers for other signals can be successfully created, but these signals
are never received. These signals are: <cite>SIGILL</cite>, <cite>SIGABRT</cite>, <cite>SIGFPE</cite>, <cite>SIGSEGV</cite>,
<cite>SIGTERM</cite> and <cite>SIGKILL.</cite></p>
<p>Calls to raise() or abort() to programmatically raise a signal are
not detected by libuv; these will not trigger a signal watcher.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Linux SIGRT0 and SIGRT1 (signals 32 and 33) are used by the NPTL pthreads library to
manage threads. Installing watchers for those signals will lead to unpredictable behavior
and is strongly discouraged. Future versions of libuv may simply reject them.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.15.0: </span>SIGWINCH support on Windows was improved.</p>
</div>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_signal_t">
<code class="descname">uv_signal_t</code><a class="headerlink" href="#c.uv_signal_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_signal_cb">
void <code class="descname">(*uv_signal_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_signal_t" title="uv_signal_t">uv_signal_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;signum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_signal_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_signal_start" title="uv_signal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_signal_start()</span></code></a>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_signal_t.signum">
int <code class="descname">uv_signal_t.signum</code><a class="headerlink" href="#c.uv_signal_t.signum" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal being monitored by this handle. Readonly.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_signal_init">
int <code class="descname">uv_signal_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_signal_t" title="uv_signal_t">uv_signal_t</a>*<em>&nbsp;signal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_signal_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_signal_start">
int <code class="descname">uv_signal_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_signal_t" title="uv_signal_t">uv_signal_t</a>*<em>&nbsp;signal</em>, <a class="reference internal" href="index.html#c.uv_signal_cb" title="uv_signal_cb">uv_signal_cb</a><em>&nbsp;cb</em>, int<em>&nbsp;signum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_signal_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the handle with the given callback, watching for the given signal.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_signal_start_oneshot">
int <code class="descname">uv_signal_start_oneshot</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_signal_t" title="uv_signal_t">uv_signal_t</a>*<em>&nbsp;signal</em>, <a class="reference internal" href="index.html#c.uv_signal_cb" title="uv_signal_cb">uv_signal_cb</a><em>&nbsp;cb</em>, int<em>&nbsp;signum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_signal_start_oneshot" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<p>Same functionality as <a class="reference internal" href="#c.uv_signal_start" title="uv_signal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_signal_start()</span></code></a> but the signal handler is reset the moment
the signal is received.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_signal_stop">
int <code class="descname">uv_signal_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_signal_t" title="uv_signal_t">uv_signal_t</a>*<em>&nbsp;signal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_signal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the handle, the callback will no longer be called.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-process"></span><div class="section" id="uv-process-t-process-handle">
<span id="process"></span><h4><a class="reference internal" href="#c.uv_process_t" title="uv_process_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_process_t</span></code></a> — Process handle<a class="headerlink" href="#uv-process-t-process-handle" title="Permalink to this headline">¶</a></h4>
<p>Process handles will spawn a new process and allow the user to control it and
establish communication channels with it using streams.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_process_t">
<code class="descname">uv_process_t</code><a class="headerlink" href="#c.uv_process_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Process handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_process_options_t">
<code class="descname">uv_process_options_t</code><a class="headerlink" href="#c.uv_process_options_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Options for spawning the process (passed to <a class="reference internal" href="#c.uv_spawn" title="uv_spawn"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_spawn()</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_process_options_s</span> <span class="p">{</span>
    <span class="n">uv_exit_cb</span> <span class="n">exit_cb</span><span class="p">;</span>
    <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
    <span class="n">char</span><span class="o">**</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">char</span><span class="o">**</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">cwd</span><span class="p">;</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">stdio_count</span><span class="p">;</span>
    <span class="n">uv_stdio_container_t</span><span class="o">*</span> <span class="n">stdio</span><span class="p">;</span>
    <span class="n">uv_uid_t</span> <span class="n">uid</span><span class="p">;</span>
    <span class="n">uv_gid_t</span> <span class="n">gid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_process_options_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_exit_cb">
void <code class="descname">(*uv_exit_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_process_t" title="uv_process_t">uv_process_t</a>*, int64_t<em>&nbsp;exit_status</em>, int<em>&nbsp;term_signal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_exit_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed in <a class="reference internal" href="#c.uv_process_options_t" title="uv_process_options_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_process_options_t</span></code></a> which
will indicate the exit status and the signal that caused the process to
terminate, if any.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_process_flags">
<code class="descname">uv_process_flags</code><a class="headerlink" href="#c.uv_process_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags to be set on the flags field of <a class="reference internal" href="#c.uv_process_options_t" title="uv_process_options_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_process_options_t</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">uv_process_flags</span> <span class="p">{</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">child</span> <span class="n">process</span><span class="s1">&#39; user id.</span>
    <span class="o">*/</span>
    <span class="n">UV_PROCESS_SETUID</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">child</span> <span class="n">process</span><span class="s1">&#39; group id.</span>
    <span class="o">*/</span>
    <span class="n">UV_PROCESS_SETGID</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Do</span> <span class="ow">not</span> <span class="n">wrap</span> <span class="nb">any</span> <span class="n">arguments</span> <span class="ow">in</span> <span class="n">quotes</span><span class="p">,</span> <span class="ow">or</span> <span class="n">perform</span> <span class="nb">any</span> <span class="n">other</span> <span class="n">escaping</span><span class="p">,</span> <span class="n">when</span>
    <span class="o">*</span> <span class="n">converting</span> <span class="n">the</span> <span class="n">argument</span> <span class="nb">list</span> <span class="n">into</span> <span class="n">a</span> <span class="n">command</span> <span class="n">line</span> <span class="n">string</span><span class="o">.</span> <span class="n">This</span> <span class="n">option</span> <span class="ow">is</span>
    <span class="o">*</span> <span class="n">only</span> <span class="n">meaningful</span> <span class="n">on</span> <span class="n">Windows</span> <span class="n">systems</span><span class="o">.</span> <span class="n">On</span> <span class="n">Unix</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">silently</span> <span class="n">ignored</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Spawn</span> <span class="n">the</span> <span class="n">child</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">detached</span> <span class="n">state</span> <span class="o">-</span> <span class="n">this</span> <span class="n">will</span> <span class="n">make</span> <span class="n">it</span> <span class="n">a</span> <span class="n">process</span>
    <span class="o">*</span> <span class="n">group</span> <span class="n">leader</span><span class="p">,</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">effectively</span> <span class="n">enable</span> <span class="n">the</span> <span class="n">child</span> <span class="n">to</span> <span class="n">keep</span> <span class="n">running</span> <span class="n">after</span>
    <span class="o">*</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">exits</span><span class="o">.</span> <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">child</span> <span class="n">process</span> <span class="n">will</span> <span class="n">still</span> <span class="n">keep</span> <span class="n">the</span>
    <span class="o">*</span> <span class="n">parent</span><span class="s1">&#39;s event loop alive unless the parent process calls uv_unref() on</span>
    <span class="o">*</span> <span class="n">the</span> <span class="n">child</span><span class="s1">&#39;s process handle.</span>
    <span class="o">*/</span>
    <span class="n">UV_PROCESS_DETACHED</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Hide</span> <span class="n">the</span> <span class="n">subprocess</span> <span class="n">console</span> <span class="n">window</span> <span class="n">that</span> <span class="n">would</span> <span class="n">normally</span> <span class="n">be</span> <span class="n">created</span><span class="o">.</span> <span class="n">This</span>
    <span class="o">*</span> <span class="n">option</span> <span class="ow">is</span> <span class="n">only</span> <span class="n">meaningful</span> <span class="n">on</span> <span class="n">Windows</span> <span class="n">systems</span><span class="o">.</span> <span class="n">On</span> <span class="n">Unix</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">silently</span>
    <span class="o">*</span> <span class="n">ignored</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_PROCESS_WINDOWS_HIDE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_stdio_container_t">
<code class="descname">uv_stdio_container_t</code><a class="headerlink" href="#c.uv_stdio_container_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for each stdio handle or fd passed to a child process.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_stdio_container_s</span> <span class="p">{</span>
    <span class="n">uv_stdio_flags</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">union</span> <span class="p">{</span>
        <span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">stream</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_stdio_container_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_stdio_flags">
<code class="descname">uv_stdio_flags</code><a class="headerlink" href="#c.uv_stdio_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags specifying how a stdio should be transmitted to the child process.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">UV_IGNORE</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
    <span class="n">UV_CREATE_PIPE</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
    <span class="n">UV_INHERIT_FD</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
    <span class="n">UV_INHERIT_STREAM</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">When</span> <span class="n">UV_CREATE_PIPE</span> <span class="ow">is</span> <span class="n">specified</span><span class="p">,</span> <span class="n">UV_READABLE_PIPE</span> <span class="ow">and</span> <span class="n">UV_WRITABLE_PIPE</span>
    <span class="o">*</span> <span class="n">determine</span> <span class="n">the</span> <span class="n">direction</span> <span class="n">of</span> <span class="n">flow</span><span class="p">,</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">child</span> <span class="n">process</span><span class="s1">&#39; perspective. Both</span>
    <span class="o">*</span> <span class="n">flags</span> <span class="n">may</span> <span class="n">be</span> <span class="n">specified</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">duplex</span> <span class="n">data</span> <span class="n">stream</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_READABLE_PIPE</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
    <span class="n">UV_WRITABLE_PIPE</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="p">}</span> <span class="n">uv_stdio_flags</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_process_t.pid">
<code class="descname">uv_process_t.pid</code><a class="headerlink" href="#c.uv_process_t.pid" title="Permalink to this definition">¶</a></dt>
<dd><p>The PID of the spawned process. It’s set after calling <a class="reference internal" href="#c.uv_spawn" title="uv_spawn"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_spawn()</span></code></a>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
<dl class="member">
<dt id="c.uv_process_options_t.exit_cb">
<code class="descname">uv_process_options_t.exit_cb</code><a class="headerlink" href="#c.uv_process_options_t.exit_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after the process exits.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.file">
<code class="descname">uv_process_options_t.file</code><a class="headerlink" href="#c.uv_process_options_t.file" title="Permalink to this definition">¶</a></dt>
<dd><p>Path pointing to the program to be executed.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.args">
<code class="descname">uv_process_options_t.args</code><a class="headerlink" href="#c.uv_process_options_t.args" title="Permalink to this definition">¶</a></dt>
<dd><p>Command line arguments. args[0] should be the path to the program. On
Windows this uses <cite>CreateProcess</cite> which concatenates the arguments into a
string this can cause some strange errors. See the
<code class="docutils literal notranslate"><span class="pre">UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</span></code> flag on <a class="reference internal" href="#c.uv_process_flags" title="uv_process_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_process_flags</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.env">
<code class="descname">uv_process_options_t.env</code><a class="headerlink" href="#c.uv_process_options_t.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Environment for the new process. If NULL the parents environment is used.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.cwd">
<code class="descname">uv_process_options_t.cwd</code><a class="headerlink" href="#c.uv_process_options_t.cwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Current working directory for the subprocess.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.flags">
<code class="descname">uv_process_options_t.flags</code><a class="headerlink" href="#c.uv_process_options_t.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Various flags that control how <a class="reference internal" href="#c.uv_spawn" title="uv_spawn"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_spawn()</span></code></a> behaves. See
<a class="reference internal" href="#c.uv_process_flags" title="uv_process_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_process_flags</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.stdio_count">
<code class="descname">uv_process_options_t.stdio_count</code><a class="headerlink" href="#c.uv_process_options_t.stdio_count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.stdio">
<code class="descname">uv_process_options_t.stdio</code><a class="headerlink" href="#c.uv_process_options_t.stdio" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>stdio</cite> field points to an array of <a class="reference internal" href="#c.uv_stdio_container_t" title="uv_stdio_container_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stdio_container_t</span></code></a>
structs that describe the file descriptors that will be made available to
the child process. The convention is that stdio[0] points to stdin,
fd 1 is used for stdout, and fd 2 is stderr.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Windows file descriptors greater than 2 are available to the child process only if
the child processes uses the MSVCRT runtime.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.uid">
<code class="descname">uv_process_options_t.uid</code><a class="headerlink" href="#c.uv_process_options_t.uid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.uv_process_options_t.gid">
<code class="descname">uv_process_options_t.gid</code><a class="headerlink" href="#c.uv_process_options_t.gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Libuv can change the child process’ user/group id. This happens only when
the appropriate bits are set in the flags fields.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is not supported on Windows, <a class="reference internal" href="#c.uv_spawn" title="uv_spawn"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_spawn()</span></code></a> will fail and set the error
to <code class="docutils literal notranslate"><span class="pre">UV_ENOTSUP</span></code>.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.uv_stdio_container_t.flags">
<code class="descname">uv_stdio_container_t.flags</code><a class="headerlink" href="#c.uv_stdio_container_t.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags specifying how the stdio container should be passed to the child. See
<a class="reference internal" href="#c.uv_stdio_flags" title="uv_stdio_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stdio_flags</span></code></a>.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_stdio_container_t.data">
<code class="descname">uv_stdio_container_t.data</code><a class="headerlink" href="#c.uv_stdio_container_t.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Union containing either the stream or fd to be passed on to the child
process.</p>
</dd></dl>

</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_disable_stdio_inheritance">
void <code class="descname">uv_disable_stdio_inheritance</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_disable_stdio_inheritance" title="Permalink to this definition">¶</a></dt>
<dd><p>Disables inheritance for file descriptors / handles that this process
inherited from its parent. The effect is that child processes spawned by
this process don’t accidentally inherit these handles.</p>
<p>It is recommended to call this function as early in your program as possible,
before the inherited file descriptors can be closed or duplicated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function works on a best-effort basis: there is no guarantee that libuv can discover
all file descriptors that were inherited. In general it does a better job on Windows than
it does on Unix.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_spawn">
int <code class="descname">uv_spawn</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_process_t" title="uv_process_t">uv_process_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="index.html#c.uv_process_options_t" title="uv_process_options_t">uv_process_options_t</a>*<em>&nbsp;options</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_spawn" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the process handle and starts the process. If the process is
successfully spawned, this function will return 0. Otherwise, the
negative error code corresponding to the reason it couldn’t spawn is
returned.</p>
<p>Possible reasons for failing to spawn would include (but not be limited to)
the file to execute not existing, not having permissions to use the setuid or
setgid specified, or not having enough memory to allocate for the new
process.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_process_kill">
int <code class="descname">uv_process_kill</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_process_t" title="uv_process_t">uv_process_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;signum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_process_kill" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends the specified signal to the given process handle. Check the documentation
on <a class="reference internal" href="index.html#signal"><span class="std std-ref">uv_signal_t — Signal handle</span></a> for signal support, specially on Windows.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_kill">
int <code class="descname">uv_kill</code><span class="sig-paren">(</span>int<em>&nbsp;pid</em>, int<em>&nbsp;signum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_kill" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends the specified signal to the given PID. Check the documentation
on <a class="reference internal" href="index.html#signal"><span class="std std-ref">uv_signal_t — Signal handle</span></a> for signal support, specially on Windows.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_process_get_pid">
<a class="reference internal" href="index.html#c.uv_pid_t" title="uv_pid_t">uv_pid_t</a> <code class="descname">uv_process_get_pid</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_process_t" title="uv_process_t">uv_process_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_process_get_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;pid</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-stream"></span><div class="section" id="uv-stream-t-stream-handle">
<span id="stream"></span><h4><a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> — Stream handle<a class="headerlink" href="#uv-stream-t-stream-handle" title="Permalink to this headline">¶</a></h4>
<p>Stream handles provide an abstraction of a duplex communication channel.
<a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> is an abstract type, libuv provides 3 stream implementations
in the form of <a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tcp_t</span></code></a>, <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_pipe_t</span></code></a> and <a class="reference internal" href="index.html#c.uv_tty_t" title="uv_tty_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tty_t</span></code></a>.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_stream_t">
<code class="descname">uv_stream_t</code><a class="headerlink" href="#c.uv_stream_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Stream handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_connect_t">
<code class="descname">uv_connect_t</code><a class="headerlink" href="#c.uv_connect_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_shutdown_t">
<code class="descname">uv_shutdown_t</code><a class="headerlink" href="#c.uv_shutdown_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_write_t">
<code class="descname">uv_write_t</code><a class="headerlink" href="#c.uv_write_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write request type. Careful attention must be paid when reusing objects of
this type. When a stream is in non-blocking mode, write requests sent
with <code class="docutils literal notranslate"><span class="pre">uv_write</span></code> will be queued. Reusing objects at this point is undefined
behaviour. It is safe to reuse the <code class="docutils literal notranslate"><span class="pre">uv_write_t</span></code> object only after the
callback passed to <code class="docutils literal notranslate"><span class="pre">uv_write</span></code> is fired.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_read_cb">
void <code class="descname">(*uv_read_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em>, ssize_t<em>&nbsp;nread</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a>*<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_read_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called when data was read on a stream.</p>
<p><cite>nread</cite> is &gt; 0 if there is data available or &lt; 0 on error. When we’ve
reached EOF, <cite>nread</cite> will be set to <code class="docutils literal notranslate"><span class="pre">UV_EOF</span></code>. When <cite>nread</cite> &lt; 0,
the <cite>buf</cite> parameter might not point to a valid buffer; in that case
<cite>buf.len</cite> and <cite>buf.base</cite> are both set to 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>nread</cite> might be 0, which does <em>not</em> indicate an error or EOF. This
is equivalent to <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> or <code class="docutils literal notranslate"><span class="pre">EWOULDBLOCK</span></code> under <code class="docutils literal notranslate"><span class="pre">read(2)</span></code>.</p>
</div>
<p>The callee is responsible for stopping closing the stream when an error happens
by calling <a class="reference internal" href="#c.uv_read_stop" title="uv_read_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_read_stop()</span></code></a> or <a class="reference internal" href="index.html#c.uv_close" title="uv_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_close()</span></code></a>. Trying to read
from the stream again is undefined.</p>
<p>The callee is responsible for freeing the buffer, libuv does not reuse it.
The buffer may be a null buffer (where buf-&gt;base=NULL and buf-&gt;len=0) on
error.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_write_cb">
void <code class="descname">(*uv_write_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_write_t" title="uv_write_t">uv_write_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_write_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after data was written on a stream. <cite>status</cite> will be 0 in
case of success, &lt; 0 otherwise.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_connect_cb">
void <code class="descname">(*uv_connect_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_connect_t" title="uv_connect_t">uv_connect_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_connect_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after a connection started by <code class="xref c c-func docutils literal notranslate"><span class="pre">uv_connect()</span></code> is done.
<cite>status</cite> will be 0 in case of success, &lt; 0 otherwise.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_shutdown_cb">
void <code class="descname">(*uv_shutdown_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_shutdown_t" title="uv_shutdown_t">uv_shutdown_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_shutdown_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called after a shutdown request has been completed. <cite>status</cite> will
be 0 in case of success, &lt; 0 otherwise.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_connection_cb">
void <code class="descname">(*uv_connection_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;server</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_connection_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called when a stream server has received an incoming connection.
The user can accept the connection by calling <a class="reference internal" href="#c.uv_accept" title="uv_accept"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_accept()</span></code></a>.
<cite>status</cite> will be 0 in case of success, &lt; 0 otherwise.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_stream_t.write_queue_size">
size_t <code class="descname">uv_stream_t.write_queue_size</code><a class="headerlink" href="#c.uv_stream_t.write_queue_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the amount of queued bytes waiting to be sent. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_connect_t.handle">
<a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_connect_t.handle</code><a class="headerlink" href="#c.uv_connect_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream where this connection request is running.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_shutdown_t.handle">
<a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_shutdown_t.handle</code><a class="headerlink" href="#c.uv_shutdown_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream where this shutdown request is running.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_write_t.handle">
<a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_write_t.handle</code><a class="headerlink" href="#c.uv_write_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream where this write request is running.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_write_t.send_handle">
<a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>* <code class="descname">uv_write_t.send_handle</code><a class="headerlink" href="#c.uv_write_t.send_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the stream being sent using this write request.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_shutdown">
int <code class="descname">uv_shutdown</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_shutdown_t" title="uv_shutdown_t">uv_shutdown_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_shutdown_cb" title="uv_shutdown_cb">uv_shutdown_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the outgoing (write) side of a duplex stream. It waits for pending
write requests to complete. The <cite>handle</cite> should refer to a initialized stream.
<cite>req</cite> should be an uninitialized shutdown request struct. The <cite>cb</cite> is called
after shutdown is complete.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_listen">
int <code class="descname">uv_listen</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em>, int<em>&nbsp;backlog</em>, <a class="reference internal" href="index.html#c.uv_connection_cb" title="uv_connection_cb">uv_connection_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Start listening for incoming connections. <cite>backlog</cite> indicates the number of
connections the kernel might queue, same as <a class="reference external" href="http://linux.die.net/man/2/listen">listen(2)</a>. When a new
incoming connection is received the <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_connection_cb</span></code></a> callback is
called.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_accept">
int <code class="descname">uv_accept</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;server</em>, <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>This call is used in conjunction with <a class="reference internal" href="#c.uv_listen" title="uv_listen"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_listen()</span></code></a> to accept incoming
connections. Call this function after receiving a <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_connection_cb</span></code></a>
to accept the connection. Before calling this function the client handle must
be initialized. &lt; 0 return value indicates an error.</p>
<p>When the <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_connection_cb</span></code></a> callback is called it is guaranteed that
this function will complete successfully the first time. If you attempt to use
it more than once, it may fail. It is suggested to only call this function once
per <a class="reference internal" href="#c.uv_connection_cb" title="uv_connection_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_connection_cb</span></code></a> call.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>server</cite> and <cite>client</cite> must be handles running on the same loop.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_read_start">
int <code class="descname">uv_read_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em>, <a class="reference internal" href="index.html#c.uv_alloc_cb" title="uv_alloc_cb">uv_alloc_cb</a><em>&nbsp;alloc_cb</em>, <a class="reference internal" href="index.html#c.uv_read_cb" title="uv_read_cb">uv_read_cb</a><em>&nbsp;read_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_read_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from an incoming stream. The <a class="reference internal" href="#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_read_cb</span></code></a> callback will
be made several times until there is no more data to read or
<a class="reference internal" href="#c.uv_read_stop" title="uv_read_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_read_stop()</span></code></a> is called.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_read_stop">
int <code class="descname">uv_read_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_read_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop reading data from the stream. The <a class="reference internal" href="#c.uv_read_cb" title="uv_read_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_read_cb</span></code></a> callback will
no longer be called.</p>
<p>This function is idempotent and may be safely called on a stopped stream.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_write">
int <code class="descname">uv_write</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_write_t" title="uv_write_t">uv_write_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, <a class="reference internal" href="index.html#c.uv_write_cb" title="uv_write_cb">uv_write_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to stream. Buffers are written in order. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">cb</span><span class="p">(</span><span class="n">uv_write_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Logic</span> <span class="n">which</span> <span class="n">handles</span> <span class="n">the</span> <span class="n">write</span> <span class="n">result</span> <span class="o">*/</span>
<span class="p">}</span>

<span class="n">uv_buf_t</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">uv_buf_t</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">uv_write_t</span> <span class="n">req1</span><span class="p">;</span>
<span class="n">uv_write_t</span> <span class="n">req2</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">writes</span> <span class="s2">&quot;1234&quot;</span> <span class="o">*/</span>
<span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req1</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req2</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The memory pointed to by the buffers must remain valid until the callback gets called.
This also holds for <a class="reference internal" href="#c.uv_write2" title="uv_write2"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_write2()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_write2">
int <code class="descname">uv_write2</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_write_t" title="uv_write_t">uv_write_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;send_handle</em>, <a class="reference internal" href="index.html#c.uv_write_cb" title="uv_write_cb">uv_write_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_write2" title="Permalink to this definition">¶</a></dt>
<dd><p>Extended write function for sending handles over a pipe. The pipe must be
initialized with <cite>ipc</cite> == 1.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>send_handle</cite> must be a TCP socket or pipe, which is a server or a connection (listening
or connected state). Bound sockets or pipes will be assumed to be servers.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_try_write">
int <code class="descname">uv_try_write</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_try_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#c.uv_write" title="uv_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_write()</span></code></a>, but won’t queue a write request if it can’t be
completed immediately.</p>
<p>Will return either:</p>
<ul class="simple">
<li>&gt; 0: number of bytes written (can be less than the supplied buffer size).</li>
<li>&lt; 0: negative error code (<code class="docutils literal notranslate"><span class="pre">UV_EAGAIN</span></code> is returned if no data can be sent
immediately).</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_readable">
int <code class="descname">uv_is_readable</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the stream is readable, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_is_writable">
int <code class="descname">uv_is_writable</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_is_writable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the stream is writable, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_stream_set_blocking">
int <code class="descname">uv_stream_set_blocking</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;blocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_stream_set_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable blocking mode for a stream.</p>
<p>When blocking mode is enabled all writes complete synchronously. The
interface remains unchanged otherwise, e.g. completion or failure of the
operation will still be reported through a callback which is made
asynchronously.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Relying too much on this API is not recommended. It is likely to change
significantly in the future.</p>
<p>Currently only works on Windows for <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_pipe_t</span></code></a> handles.
On UNIX platforms, all <a class="reference internal" href="#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> handles are supported.</p>
<p class="last">Also libuv currently makes no ordering guarantee when the blocking mode
is changed after write requests have already been submitted. Therefore it is
recommended to set the blocking mode immediately after opening or creating
the stream.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.4.0: </span>UNIX implementation added.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_stream_get_write_queue_size">
size_t <code class="descname">uv_stream_get_write_queue_size</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t">uv_stream_t</a>*<em>&nbsp;stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_stream_get_write_queue_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>stream-&gt;write_queue_size</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-tcp"></span><div class="section" id="uv-tcp-t-tcp-handle">
<span id="tcp"></span><h4><a class="reference internal" href="#c.uv_tcp_t" title="uv_tcp_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tcp_t</span></code></a> — TCP handle<a class="headerlink" href="#uv-tcp-t-tcp-handle" title="Permalink to this headline">¶</a></h4>
<p>TCP handles are used to represent both TCP streams and servers.</p>
<p><a class="reference internal" href="#c.uv_tcp_t" title="uv_tcp_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tcp_t</span></code></a> is a ‘subclass’ of <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a>.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_tcp_t">
<code class="descname">uv_tcp_t</code><a class="headerlink" href="#c.uv_tcp_t" title="Permalink to this definition">¶</a></dt>
<dd><p>TCP handle type.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_tcp_init">
int <code class="descname">uv_tcp_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle. No socket is created as of yet.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_init_ex">
int <code class="descname">uv_tcp_init_ex</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_init_ex" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle with the specified flags. At the moment only the lower 8 bits
of the <cite>flags</cite> parameter are used as the socket domain. A socket will be created
for the given domain. If the specified domain is <code class="docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code> no socket is created,
just like <a class="reference internal" href="#c.uv_tcp_init" title="uv_tcp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_tcp_init()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_open">
int <code class="descname">uv_tcp_open</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_os_sock_t" title="uv_os_sock_t">uv_os_sock_t</a><em>&nbsp;sock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an existing file descriptor or SOCKET as a TCP handle.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.2.1: </span>the file descriptor is set to non-blocking mode.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The passed file descriptor or SOCKET is not checked for its type, but
it’s required that it represents a valid stream socket.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_nodelay">
int <code class="descname">uv_tcp_nodelay</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_nodelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable <cite>TCP_NODELAY</cite>, which disables Nagle’s algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_keepalive">
int <code class="descname">uv_tcp_keepalive</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;enable</em>, unsigned int<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_keepalive" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable / disable TCP keep-alive. <cite>delay</cite> is the initial delay in seconds,
ignored when <cite>enable</cite> is zero.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_simultaneous_accepts">
int <code class="descname">uv_tcp_simultaneous_accepts</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_simultaneous_accepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable / disable simultaneous asynchronous accept requests that are
queued by the operating system when listening for new TCP connections.</p>
<p>This setting is used to tune a TCP server for the desired performance.
Having simultaneous accepts can significantly improve the rate of accepting
connections (which is why it is enabled by default) but may lead to uneven
load distribution in multi-process setups.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_bind">
int <code class="descname">uv_tcp_bind</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, const struct sockaddr*<em>&nbsp;addr</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the handle to an address and port. <cite>addr</cite> should point to an
initialized <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code> or <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code>.</p>
<p>When the port is already taken, you can expect to see an <code class="docutils literal notranslate"><span class="pre">UV_EADDRINUSE</span></code>
error from either <a class="reference internal" href="#c.uv_tcp_bind" title="uv_tcp_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_tcp_bind()</span></code></a>, <a class="reference internal" href="index.html#c.uv_listen" title="uv_listen"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_listen()</span></code></a> or
<a class="reference internal" href="#c.uv_tcp_connect" title="uv_tcp_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_tcp_connect()</span></code></a>. That is, a successful call to this function does
not guarantee that the call to <a class="reference internal" href="index.html#c.uv_listen" title="uv_listen"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_listen()</span></code></a> or <a class="reference internal" href="#c.uv_tcp_connect" title="uv_tcp_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_tcp_connect()</span></code></a>
will succeed as well.</p>
<p><cite>flags</cite> can contain <code class="docutils literal notranslate"><span class="pre">UV_TCP_IPV6ONLY</span></code>, in which case dual-stack support
is disabled and only IPv6 is used.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_getsockname">
int <code class="descname">uv_tcp_getsockname</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, struct sockaddr*<em>&nbsp;name</em>, int*<em>&nbsp;namelen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_getsockname" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current address to which the handle is bound. <cite>addr</cite> must point to
a valid and big enough chunk of memory, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_storage</span></code> is
recommended for IPv4 and IPv6 support.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_getpeername">
int <code class="descname">uv_tcp_getpeername</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, struct sockaddr*<em>&nbsp;name</em>, int*<em>&nbsp;namelen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_getpeername" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the address of the peer connected to the handle. <cite>addr</cite> must point to
a valid and big enough chunk of memory, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_storage</span></code> is
recommended for IPv4 and IPv6 support.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tcp_connect">
int <code class="descname">uv_tcp_connect</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_connect_t" title="uv_connect_t">uv_connect_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_tcp_t" title="uv_tcp_t">uv_tcp_t</a>*<em>&nbsp;handle</em>, const struct sockaddr*<em>&nbsp;addr</em>, <a class="reference internal" href="index.html#c.uv_connect_cb" title="uv_connect_cb">uv_connect_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tcp_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Establish an IPv4 or IPv6 TCP connection. Provide an initialized TCP handle
and an uninitialized <a class="reference internal" href="index.html#c.uv_connect_t" title="uv_connect_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_connect_t</span></code></a>. <cite>addr</cite> should point to an
initialized <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code> or <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code>.</p>
<p>On Windows if the <cite>addr</cite> is initialized to point to an unspecified address
(<code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> or <code class="docutils literal notranslate"><span class="pre">::</span></code>) it will be changed to point to <code class="docutils literal notranslate"><span class="pre">localhost</span></code>.
This is done to match the behavior of Linux systems.</p>
<p>The callback is made when the connection has been established or when a
connection error happened.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.19.0: </span>added <code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">::</span></code> to <code class="docutils literal notranslate"><span class="pre">localhost</span></code>
mapping</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-pipe"></span><div class="section" id="uv-pipe-t-pipe-handle">
<span id="pipe"></span><h4><a class="reference internal" href="#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_pipe_t</span></code></a> — Pipe handle<a class="headerlink" href="#uv-pipe-t-pipe-handle" title="Permalink to this headline">¶</a></h4>
<p>Pipe handles provide an abstraction over local domain sockets on Unix and named
pipes on Windows.</p>
<p><a class="reference internal" href="#c.uv_pipe_t" title="uv_pipe_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_pipe_t</span></code></a> is a ‘subclass’ of <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a>.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_pipe_t">
<code class="descname">uv_pipe_t</code><a class="headerlink" href="#c.uv_pipe_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Pipe handle type.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_pipe_init">
int <code class="descname">uv_pipe_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;ipc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a pipe handle. The <cite>ipc</cite> argument is a boolean to indicate if
this pipe will be used for handle passing between processes.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_open">
int <code class="descname">uv_pipe_open</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an existing file descriptor or HANDLE as a pipe.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.2.1: </span>the file descriptor is set to non-blocking mode.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The passed file descriptor or HANDLE is not checked for its type, but
it’s required that it represents a valid pipe.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_bind">
int <code class="descname">uv_pipe_bind</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, const char*<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the pipe to a file path (Unix) or a name (Windows).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Paths on Unix get truncated to <code class="docutils literal notranslate"><span class="pre">sizeof(sockaddr_un.sun_path)</span></code> bytes, typically between
92 and 108 bytes.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_connect">
void <code class="descname">uv_pipe_connect</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_connect_t" title="uv_connect_t">uv_connect_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, const char*<em>&nbsp;name</em>, <a class="reference internal" href="index.html#c.uv_connect_cb" title="uv_connect_cb">uv_connect_cb</a><em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to the Unix domain socket or the named pipe.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Paths on Unix get truncated to <code class="docutils literal notranslate"><span class="pre">sizeof(sockaddr_un.sun_path)</span></code> bytes, typically between
92 and 108 bytes.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_getsockname">
int <code class="descname">uv_pipe_getsockname</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_getsockname" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the Unix domain socket or the named pipe.</p>
<p>A preallocated buffer must be provided. The size parameter holds the length
of the buffer and it’s set to the number of bytes written to the buffer on
output. If the buffer is not big enough <code class="docutils literal notranslate"><span class="pre">UV_ENOBUFS</span></code> will be returned and
len will contain the required size.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the returned length no longer includes the terminating null byte,
and the buffer is not null terminated.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_getpeername">
int <code class="descname">uv_pipe_getpeername</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_getpeername" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the Unix domain socket or the named pipe to which the handle
is connected.</p>
<p>A preallocated buffer must be provided. The size parameter holds the length
of the buffer and it’s set to the number of bytes written to the buffer on
output. If the buffer is not big enough <code class="docutils literal notranslate"><span class="pre">UV_ENOBUFS</span></code> will be returned and
len will contain the required size.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.3.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_pending_instances">
void <code class="descname">uv_pipe_pending_instances</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_pending_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of pending pipe instance handles when the pipe server is
waiting for connections.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This setting applies to Windows only.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_pipe_pending_count">
int <code class="descname">uv_pipe_pending_count</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_pending_count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_pipe_pending_type">
<a class="reference internal" href="index.html#c.uv_handle_type" title="uv_handle_type">uv_handle_type</a> <code class="descname">uv_pipe_pending_type</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_pending_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to receive handles over IPC pipes.</p>
<p>First - call <a class="reference internal" href="#c.uv_pipe_pending_count" title="uv_pipe_pending_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_pipe_pending_count()</span></code></a>, if it’s &gt; 0 then initialize
a handle of the given <cite>type</cite>, returned by <a class="reference internal" href="#c.uv_pipe_pending_type" title="uv_pipe_pending_type"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_pipe_pending_type()</span></code></a>
and call <code class="docutils literal notranslate"><span class="pre">uv_accept(pipe,</span> <span class="pre">handle)</span></code>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> API functions also apply.</p>
</div>
<dl class="function">
<dt id="c.uv_pipe_chmod">
int <code class="descname">uv_pipe_chmod</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_pipe_t" title="uv_pipe_t">uv_pipe_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_pipe_chmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters pipe permissions, allowing it to be accessed from processes run by
different users. Makes the pipe writable or readable by all users. Mode can
be <code class="docutils literal notranslate"><span class="pre">UV_WRITABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">UV_READABLE</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_WRITABLE</span> <span class="pre">|</span> <span class="pre">UV_READABLE</span></code>. This
function is blocking.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.16.0.</span></p>
</div>
</dd></dl>

</div>
</div>
<span id="document-tty"></span><div class="section" id="uv-tty-t-tty-handle">
<span id="tty"></span><h4><a class="reference internal" href="#c.uv_tty_t" title="uv_tty_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tty_t</span></code></a> — TTY handle<a class="headerlink" href="#uv-tty-t-tty-handle" title="Permalink to this headline">¶</a></h4>
<p>TTY handles represent a stream for the console.</p>
<p><a class="reference internal" href="#c.uv_tty_t" title="uv_tty_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tty_t</span></code></a> is a ‘subclass’ of <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a>.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_tty_t">
<code class="descname">uv_tty_t</code><a class="headerlink" href="#c.uv_tty_t" title="Permalink to this definition">¶</a></dt>
<dd><p>TTY handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_tty_mode_t">
<code class="descname">uv_tty_mode_t</code><a class="headerlink" href="#c.uv_tty_mode_t" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">New in version 1.2.0.</span></p>
</div>
<p>TTY mode type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Initial</span><span class="o">/</span><span class="n">normal</span> <span class="n">terminal</span> <span class="n">mode</span> <span class="o">*/</span>
    <span class="n">UV_TTY_MODE_NORMAL</span><span class="p">,</span>
    <span class="o">/*</span> <span class="n">Raw</span> <span class="nb">input</span> <span class="n">mode</span> <span class="p">(</span><span class="n">On</span> <span class="n">Windows</span><span class="p">,</span> <span class="n">ENABLE_WINDOW_INPUT</span> <span class="ow">is</span> <span class="n">also</span> <span class="n">enabled</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">UV_TTY_MODE_RAW</span><span class="p">,</span>
    <span class="o">/*</span> <span class="n">Binary</span><span class="o">-</span><span class="n">safe</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">mode</span> <span class="k">for</span> <span class="n">IPC</span> <span class="p">(</span><span class="n">Unix</span><span class="o">-</span><span class="n">only</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">UV_TTY_MODE_IO</span>
<span class="p">}</span> <span class="n">uv_tty_mode_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_tty_init">
int <code class="descname">uv_tty_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_tty_t" title="uv_tty_t">uv_tty_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;fd</em>, int<em>&nbsp;readable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tty_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a new TTY stream with the given file descriptor. Usually the
file descriptor will be:</p>
<ul class="simple">
<li>0 = stdin</li>
<li>1 = stdout</li>
<li>2 = stderr</li>
</ul>
<p><cite>readable</cite>, specifies if you plan on calling <a class="reference internal" href="index.html#c.uv_read_start" title="uv_read_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_read_start()</span></code></a> with
this stream. stdin is readable, stdout is not.</p>
<p>On Unix this function will determine the path of the fd of the terminal
using <a class="reference external" href="http://linux.die.net/man/3/ttyname_r">ttyname_r(3)</a>, open it, and use it if the passed file descriptor
refers to a TTY. This lets libuv put the tty in non-blocking mode without
affecting other processes that share the tty.</p>
<p>This function is not thread safe on systems that don’t support
ioctl TIOCGPTN or TIOCPTYGNAME, for instance OpenBSD and Solaris.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If reopening the TTY fails, libuv falls back to blocking writes for
non-readable TTY streams.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9.0:: </span>the path of the TTY is determined by
<a class="reference external" href="http://linux.die.net/man/3/ttyname_r">ttyname_r(3)</a>. In earlier versions libuv opened
<cite>/dev/tty</cite> instead.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5.0:: </span>trying to initialize a TTY stream with a file
descriptor that refers to a file returns <cite>UV_EINVAL</cite>
on UNIX.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_tty_set_mode">
int <code class="descname">uv_tty_set_mode</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tty_t" title="uv_tty_t">uv_tty_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_tty_mode_t" title="uv_tty_mode_t">uv_tty_mode_t</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tty_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.2.0:: </span>the mode is specified as a
<a class="reference internal" href="#c.uv_tty_mode_t" title="uv_tty_mode_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_tty_mode_t</span></code></a> value.</p>
</div>
<p>Set the TTY using the specified terminal mode.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tty_reset_mode">
int <code class="descname">uv_tty_reset_mode</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tty_reset_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>To be called when the program exits. Resets TTY settings to default
values for the next process to take over.</p>
<p>This function is async signal-safe on Unix platforms but can fail with error
code <code class="docutils literal notranslate"><span class="pre">UV_EBUSY</span></code> if you call it when execution is inside
<a class="reference internal" href="#c.uv_tty_set_mode" title="uv_tty_set_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_tty_set_mode()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_tty_get_winsize">
int <code class="descname">uv_tty_get_winsize</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_tty_t" title="uv_tty_t">uv_tty_t</a>*<em>&nbsp;handle</em>, int*<em>&nbsp;width</em>, int*<em>&nbsp;height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_tty_get_winsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current Window size. On success it returns 0.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_stream_t" title="uv_stream_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stream_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-udp"></span><div class="section" id="uv-udp-t-udp-handle">
<span id="udp"></span><h4><a class="reference internal" href="#c.uv_udp_t" title="uv_udp_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_udp_t</span></code></a> — UDP handle<a class="headerlink" href="#uv-udp-t-udp-handle" title="Permalink to this headline">¶</a></h4>
<p>UDP handles encapsulate UDP communication for both clients and servers.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_udp_t">
<code class="descname">uv_udp_t</code><a class="headerlink" href="#c.uv_udp_t" title="Permalink to this definition">¶</a></dt>
<dd><p>UDP handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_udp_send_t">
<code class="descname">uv_udp_send_t</code><a class="headerlink" href="#c.uv_udp_send_t" title="Permalink to this definition">¶</a></dt>
<dd><p>UDP send request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_udp_flags">
<code class="descname">uv_udp_flags</code><a class="headerlink" href="#c.uv_udp_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags used in <a class="reference internal" href="#c.uv_udp_bind" title="uv_udp_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_bind()</span></code></a> and <a class="reference internal" href="#c.uv_udp_recv_cb" title="uv_udp_recv_cb"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_udp_recv_cb</span></code></a>..</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">uv_udp_flags</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Disables</span> <span class="n">dual</span> <span class="n">stack</span> <span class="n">mode</span><span class="o">.</span> <span class="o">*/</span>
    <span class="n">UV_UDP_IPV6ONLY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Indicates</span> <span class="n">message</span> <span class="n">was</span> <span class="n">truncated</span> <span class="n">because</span> <span class="n">read</span> <span class="n">buffer</span> <span class="n">was</span> <span class="n">too</span> <span class="n">small</span><span class="o">.</span> <span class="n">The</span>
    <span class="o">*</span> <span class="n">remainder</span> <span class="n">was</span> <span class="n">discarded</span> <span class="n">by</span> <span class="n">the</span> <span class="n">OS</span><span class="o">.</span> <span class="n">Used</span> <span class="ow">in</span> <span class="n">uv_udp_recv_cb</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_UDP_PARTIAL</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">Indicates</span> <span class="k">if</span> <span class="n">SO_REUSEADDR</span> <span class="n">will</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">binding</span> <span class="n">the</span> <span class="n">handle</span> <span class="ow">in</span>
    <span class="o">*</span> <span class="n">uv_udp_bind</span><span class="o">.</span>
    <span class="o">*</span> <span class="n">This</span> <span class="n">sets</span> <span class="n">the</span> <span class="n">SO_REUSEPORT</span> <span class="n">socket</span> <span class="n">flag</span> <span class="n">on</span> <span class="n">the</span> <span class="n">BSDs</span> <span class="ow">and</span> <span class="n">OS</span> <span class="n">X</span><span class="o">.</span> <span class="n">On</span> <span class="n">other</span>
    <span class="o">*</span> <span class="n">Unix</span> <span class="n">platforms</span><span class="p">,</span> <span class="n">it</span> <span class="n">sets</span> <span class="n">the</span> <span class="n">SO_REUSEADDR</span> <span class="n">flag</span><span class="o">.</span> <span class="n">What</span> <span class="n">that</span> <span class="n">means</span> <span class="ow">is</span> <span class="n">that</span>
    <span class="o">*</span> <span class="n">multiple</span> <span class="n">threads</span> <span class="ow">or</span> <span class="n">processes</span> <span class="n">can</span> <span class="n">bind</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">address</span> <span class="n">without</span> <span class="n">error</span>
    <span class="o">*</span> <span class="p">(</span><span class="n">provided</span> <span class="n">they</span> <span class="nb">all</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">flag</span><span class="p">)</span> <span class="n">but</span> <span class="n">only</span> <span class="n">the</span> <span class="n">last</span> <span class="n">one</span> <span class="n">to</span> <span class="n">bind</span> <span class="n">will</span> <span class="n">receive</span>
    <span class="o">*</span> <span class="nb">any</span> <span class="n">traffic</span><span class="p">,</span> <span class="ow">in</span> <span class="n">effect</span> <span class="s2">&quot;stealing&quot;</span> <span class="n">the</span> <span class="n">port</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">previous</span> <span class="n">listener</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_UDP_REUSEADDR</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_udp_send_cb">
void <code class="descname">(*uv_udp_send_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_send_t" title="uv_udp_send_t">uv_udp_send_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_send_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_udp_send" title="uv_udp_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_send()</span></code></a>, which is
called after the data was sent.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_udp_recv_cb">
void <code class="descname">(*uv_udp_recv_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, ssize_t<em>&nbsp;nread</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a>*<em>&nbsp;buf</em>, const struct sockaddr*<em>&nbsp;addr</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_recv_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Type definition for callback passed to <a class="reference internal" href="#c.uv_udp_recv_start" title="uv_udp_recv_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_recv_start()</span></code></a>, which
is called when the endpoint receives data.</p>
<ul class="simple">
<li><cite>handle</cite>: UDP handle</li>
<li><cite>nread</cite>:  Number of bytes that have been received.
0 if there is no more data to read. You may discard or repurpose
the read buffer. Note that 0 may also mean that an empty datagram
was received (in this case <cite>addr</cite> is not NULL). &lt; 0 if a transmission
error was detected.</li>
<li><cite>buf</cite>: <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_buf_t</span></code></a> with the received data.</li>
<li><cite>addr</cite>: <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr*</span></code> containing the address of the sender.
Can be NULL. Valid for the duration of the callback only.</li>
<li><cite>flags</cite>: One or more or’ed UV_UDP_* constants. Right now only
<code class="docutils literal notranslate"><span class="pre">UV_UDP_PARTIAL</span></code> is used.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The receive callback will be called with <cite>nread</cite> == 0 and <cite>addr</cite> == NULL when there is
nothing to read, and with <cite>nread</cite> == 0 and <cite>addr</cite> != NULL when an empty UDP packet is
received.</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_membership">
<code class="descname">uv_membership</code><a class="headerlink" href="#c.uv_membership" title="Permalink to this definition">¶</a></dt>
<dd><p>Membership type for a multicast address.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">UV_LEAVE_GROUP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">UV_JOIN_GROUP</span>
<span class="p">}</span> <span class="n">uv_membership</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_udp_t.send_queue_size">
size_t <code class="descname">uv_udp_t.send_queue_size</code><a class="headerlink" href="#c.uv_udp_t.send_queue_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bytes queued for sending. This field strictly shows how much
information is currently queued.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_udp_t.send_queue_count">
size_t <code class="descname">uv_udp_t.send_queue_count</code><a class="headerlink" href="#c.uv_udp_t.send_queue_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of send requests currently in the queue awaiting to be processed.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_udp_send_t.handle">
<a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>* <code class="descname">uv_udp_send_t.handle</code><a class="headerlink" href="#c.uv_udp_send_t.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>UDP handle where this send request is taking place.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_udp_init">
int <code class="descname">uv_udp_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a new UDP handle. The actual socket is created lazily.
Returns 0 on success.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_init_ex">
int <code class="descname">uv_udp_init_ex</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_init_ex" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle with the specified flags. At the moment the lower 8 bits
of the <cite>flags</cite> parameter are used as the socket domain. A socket will be created
for the given domain. If the specified domain is <code class="docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code> no socket is created,
just like <a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_open">
int <code class="descname">uv_udp_open</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_os_sock_t" title="uv_os_sock_t">uv_os_sock_t</a><em>&nbsp;sock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens an existing file descriptor or Windows SOCKET as a UDP handle.</p>
<p>Unix only:
The only requirement of the <cite>sock</cite> argument is that it follows the datagram
contract (works in unconnected mode, supports sendmsg()/recvmsg(), etc).
In other words, other datagram-type sockets like raw sockets or netlink
sockets can also be passed to this function.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.2.1: </span>the file descriptor is set to non-blocking mode.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The passed file descriptor or SOCKET is not checked for its type, but
it’s required that it represents a valid datagram socket.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_bind">
int <code class="descname">uv_udp_bind</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, const struct sockaddr*<em>&nbsp;addr</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the UDP handle to an IP address and port.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>addr</strong> – <cite>struct sockaddr_in</cite> or <cite>struct sockaddr_in6</cite>
with the address and port to bind to.</li>
<li><strong>flags</strong> – Indicate how the socket will be bound,
<code class="docutils literal notranslate"><span class="pre">UV_UDP_IPV6ONLY</span></code> and <code class="docutils literal notranslate"><span class="pre">UV_UDP_REUSEADDR</span></code> are supported.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_getsockname">
int <code class="descname">uv_udp_getsockname</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, struct sockaddr*<em>&nbsp;name</em>, int*<em>&nbsp;namelen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_getsockname" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the local IP and port of the UDP handle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a> and bound.</li>
<li><strong>name</strong> – Pointer to the structure to be filled with the address data.
In order to support IPv4 and IPv6 <cite>struct sockaddr_storage</cite> should be
used.</li>
<li><strong>namelen</strong> – On input it indicates the data of the <cite>name</cite> field. On
output it indicates how much of it was filled.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_set_membership">
int <code class="descname">uv_udp_set_membership</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, const char*<em>&nbsp;multicast_addr</em>, const char*<em>&nbsp;interface_addr</em>, <a class="reference internal" href="index.html#c.uv_membership" title="uv_membership">uv_membership</a><em>&nbsp;membership</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_set_membership" title="Permalink to this definition">¶</a></dt>
<dd><p>Set membership for a multicast address</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>multicast_addr</strong> – Multicast address to set membership for.</li>
<li><strong>interface_addr</strong> – Interface address.</li>
<li><strong>membership</strong> – Should be <code class="docutils literal notranslate"><span class="pre">UV_JOIN_GROUP</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_LEAVE_GROUP</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_set_multicast_loop">
int <code class="descname">uv_udp_set_multicast_loop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_set_multicast_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set IP multicast loop flag. Makes multicast packets loop back to
local sockets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>on</strong> – 1 for on, 0 for off.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_set_multicast_ttl">
int <code class="descname">uv_udp_set_multicast_ttl</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;ttl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_set_multicast_ttl" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the multicast ttl.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>ttl</strong> – 1 through 255.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_set_multicast_interface">
int <code class="descname">uv_udp_set_multicast_interface</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, const char*<em>&nbsp;interface_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_set_multicast_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the multicast interface to send or receive data on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>interface_addr</strong> – interface address.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_set_broadcast">
int <code class="descname">uv_udp_set_broadcast</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_set_broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Set broadcast on or off.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>on</strong> – 1 for on, 0 for off.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_set_ttl">
int <code class="descname">uv_udp_set_ttl</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;ttl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_set_ttl" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the time to live.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>ttl</strong> – 1 through 255.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_send">
int <code class="descname">uv_udp_send</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_send_t" title="uv_udp_send_t">uv_udp_send_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, const struct sockaddr*<em>&nbsp;addr</em>, <a class="reference internal" href="index.html#c.uv_udp_send_cb" title="uv_udp_send_cb">uv_udp_send_cb</a><em>&nbsp;send_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send data over the UDP socket. If the socket has not previously been bound
with <a class="reference internal" href="#c.uv_udp_bind" title="uv_udp_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_bind()</span></code></a> it will be bound to 0.0.0.0
(the “all interfaces” IPv4 address) and a random port number.</p>
<p>On Windows if the <cite>addr</cite> is initialized to point to an unspecified address
(<code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> or <code class="docutils literal notranslate"><span class="pre">::</span></code>) it will be changed to point to <code class="docutils literal notranslate"><span class="pre">localhost</span></code>.
This is done to match the behavior of Linux systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>req</strong> – UDP request handle. Need not be initialized.</li>
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>bufs</strong> – List of buffers to send.</li>
<li><strong>nbufs</strong> – Number of buffers in <cite>bufs</cite>.</li>
<li><strong>addr</strong> – <cite>struct sockaddr_in</cite> or <cite>struct sockaddr_in6</cite> with the
address and port of the remote peer.</li>
<li><strong>send_cb</strong> – Callback to invoke when the data has been sent out.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.19.0: </span>added <code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">::</span></code> to <code class="docutils literal notranslate"><span class="pre">localhost</span></code>
mapping</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_try_send">
int <code class="descname">uv_udp_try_send</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, const struct sockaddr*<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_try_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#c.uv_udp_send" title="uv_udp_send"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_send()</span></code></a>, but won’t queue a send request if it can’t
be completed immediately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">&gt;= 0: number of bytes sent (it matches the given buffer size).
&lt; 0: negative error code (<code class="docutils literal notranslate"><span class="pre">UV_EAGAIN</span></code> is returned when the message
can’t be sent immediately).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_recv_start">
int <code class="descname">uv_udp_recv_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_alloc_cb" title="uv_alloc_cb">uv_alloc_cb</a><em>&nbsp;alloc_cb</em>, <a class="reference internal" href="index.html#c.uv_udp_recv_cb" title="uv_udp_recv_cb">uv_udp_recv_cb</a><em>&nbsp;recv_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_recv_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for receiving data. If the socket has not previously been bound
with <a class="reference internal" href="#c.uv_udp_bind" title="uv_udp_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_bind()</span></code></a> it is bound to 0.0.0.0 (the “all interfaces”
IPv4 address) and a random port number.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
<li><strong>alloc_cb</strong> – Callback to invoke when temporary storage is needed.</li>
<li><strong>recv_cb</strong> – Callback to invoke with received data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_recv_stop">
int <code class="descname">uv_udp_recv_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_recv_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop listening for incoming datagrams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>handle</strong> – UDP handle. Should have been initialized with
<a class="reference internal" href="#c.uv_udp_init" title="uv_udp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_udp_init()</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, or an error code &lt; 0 on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_get_send_queue_size">
size_t <code class="descname">uv_udp_get_send_queue_size</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_get_send_queue_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;send_queue_size</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_udp_get_send_queue_count">
size_t <code class="descname">uv_udp_get_send_queue_count</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_udp_t" title="uv_udp_t">uv_udp_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_udp_get_send_queue_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>handle-&gt;send_queue_count</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-fs_event"></span><div class="section" id="uv-fs-event-t-fs-event-handle">
<span id="fs-event"></span><h4><a class="reference internal" href="#c.uv_fs_event_t" title="uv_fs_event_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_event_t</span></code></a> — FS Event handle<a class="headerlink" href="#uv-fs-event-t-fs-event-handle" title="Permalink to this headline">¶</a></h4>
<p>FS Event handles allow the user to monitor a given path for changes, for example,
if the file was renamed or there was a generic change in it. This handle uses
the best backend for the job on each platform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For AIX, the non default IBM bos.ahafs package has to be installed.
The AIX Event Infrastructure file system (ahafs) has some limitations:</p>
<blockquote>
<div><ul class="simple">
<li>ahafs tracks monitoring per process and is not thread safe. A separate process
must be spawned for each monitor for the same event.</li>
<li>Events for file modification (writing to a file) are not received if only the
containing folder is watched.</li>
</ul>
</div></blockquote>
<p>See <a class="reference external" href="http://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/">documentation</a> for more details.</p>
<p class="last">The z/OS file system events monitoring infrastructure does not notify of file
creation/deletion within a directory that is being monitored.
See the <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.2.0/com.ibm.zos.v2r1.bpxb100/ioc.htm">IBM Knowledge centre</a> for more details.</p>
</div>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_fs_event_t">
<code class="descname">uv_fs_event_t</code><a class="headerlink" href="#c.uv_fs_event_t" title="Permalink to this definition">¶</a></dt>
<dd><p>FS Event handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_fs_event_cb">
void <code class="descname">(*uv_fs_event_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_event_t" title="uv_fs_event_t">uv_fs_event_t</a>*<em>&nbsp;handle</em>, const char*<em>&nbsp;filename</em>, int<em>&nbsp;events</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_event_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback passed to <a class="reference internal" href="#c.uv_fs_event_start" title="uv_fs_event_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_event_start()</span></code></a> which will be called repeatedly
after the handle is started. If the handle was started with a directory the
<cite>filename</cite> parameter will be a relative path to a file contained in the directory.
The <cite>events</cite> parameter is an ORed mask of <a class="reference internal" href="#c.uv_fs_event" title="uv_fs_event"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_event</span></code></a> elements.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_fs_event">
<code class="descname">uv_fs_event</code><a class="headerlink" href="#c.uv_fs_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Event types that <a class="reference internal" href="#c.uv_fs_event_t" title="uv_fs_event_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_event_t</span></code></a> handles monitor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">uv_fs_event</span> <span class="p">{</span>
    <span class="n">UV_RENAME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">UV_CHANGE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_fs_event_flags">
<code class="descname">uv_fs_event_flags</code><a class="headerlink" href="#c.uv_fs_event_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags that can be passed to <a class="reference internal" href="#c.uv_fs_event_start" title="uv_fs_event_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_event_start()</span></code></a> to control its
behavior.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">uv_fs_event_flags</span> <span class="p">{</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">By</span> <span class="n">default</span><span class="p">,</span> <span class="k">if</span> <span class="n">the</span> <span class="n">fs</span> <span class="n">event</span> <span class="n">watcher</span> <span class="ow">is</span> <span class="n">given</span> <span class="n">a</span> <span class="n">directory</span> <span class="n">name</span><span class="p">,</span> <span class="n">we</span> <span class="n">will</span>
    <span class="o">*</span> <span class="n">watch</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">events</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">directory</span><span class="o">.</span> <span class="n">This</span> <span class="n">flags</span> <span class="n">overrides</span> <span class="n">this</span> <span class="n">behavior</span>
    <span class="o">*</span> <span class="ow">and</span> <span class="n">makes</span> <span class="n">fs_event</span> <span class="n">report</span> <span class="n">only</span> <span class="n">changes</span> <span class="n">to</span> <span class="n">the</span> <span class="n">directory</span> <span class="n">entry</span> <span class="n">itself</span><span class="o">.</span> <span class="n">This</span>
    <span class="o">*</span> <span class="n">flag</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">affect</span> <span class="n">individual</span> <span class="n">files</span> <span class="n">watched</span><span class="o">.</span>
    <span class="o">*</span> <span class="n">This</span> <span class="n">flag</span> <span class="ow">is</span> <span class="n">currently</span> <span class="ow">not</span> <span class="n">implemented</span> <span class="n">yet</span> <span class="n">on</span> <span class="nb">any</span> <span class="n">backend</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_FS_EVENT_WATCH_ENTRY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">By</span> <span class="n">default</span> <span class="n">uv_fs_event</span> <span class="n">will</span> <span class="k">try</span> <span class="n">to</span> <span class="n">use</span> <span class="n">a</span> <span class="n">kernel</span> <span class="n">interface</span> <span class="n">such</span> <span class="k">as</span> <span class="n">inotify</span>
    <span class="o">*</span> <span class="ow">or</span> <span class="n">kqueue</span> <span class="n">to</span> <span class="n">detect</span> <span class="n">events</span><span class="o">.</span> <span class="n">This</span> <span class="n">may</span> <span class="ow">not</span> <span class="n">work</span> <span class="n">on</span> <span class="n">remote</span> <span class="n">file</span> <span class="n">systems</span> <span class="n">such</span>
    <span class="o">*</span> <span class="k">as</span> <span class="n">NFS</span> <span class="n">mounts</span><span class="o">.</span> <span class="n">This</span> <span class="n">flag</span> <span class="n">makes</span> <span class="n">fs_event</span> <span class="n">fall</span> <span class="n">back</span> <span class="n">to</span> <span class="n">calling</span> <span class="n">stat</span><span class="p">()</span> <span class="n">on</span> <span class="n">a</span>
    <span class="o">*</span> <span class="n">regular</span> <span class="n">interval</span><span class="o">.</span>
    <span class="o">*</span> <span class="n">This</span> <span class="n">flag</span> <span class="ow">is</span> <span class="n">currently</span> <span class="ow">not</span> <span class="n">implemented</span> <span class="n">yet</span> <span class="n">on</span> <span class="nb">any</span> <span class="n">backend</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_FS_EVENT_STAT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="o">/*</span>
    <span class="o">*</span> <span class="n">By</span> <span class="n">default</span><span class="p">,</span> <span class="n">event</span> <span class="n">watcher</span><span class="p">,</span> <span class="n">when</span> <span class="n">watching</span> <span class="n">directory</span><span class="p">,</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">registering</span>
    <span class="o">*</span> <span class="p">(</span><span class="ow">is</span> <span class="n">ignoring</span><span class="p">)</span> <span class="n">changes</span> <span class="ow">in</span> <span class="n">its</span> <span class="n">subdirectories</span><span class="o">.</span>
    <span class="o">*</span> <span class="n">This</span> <span class="n">flag</span> <span class="n">will</span> <span class="n">override</span> <span class="n">this</span> <span class="n">behaviour</span> <span class="n">on</span> <span class="n">platforms</span> <span class="n">that</span> <span class="n">support</span> <span class="n">it</span><span class="o">.</span>
    <span class="o">*/</span>
    <span class="n">UV_FS_EVENT_RECURSIVE</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_fs_event_init">
int <code class="descname">uv_fs_event_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_event_t" title="uv_fs_event_t">uv_fs_event_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_event_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_event_start">
int <code class="descname">uv_fs_event_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_event_t" title="uv_fs_event_t">uv_fs_event_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_fs_event_cb" title="uv_fs_event_cb">uv_fs_event_cb</a><em>&nbsp;cb</em>, const char*<em>&nbsp;path</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_event_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the handle with the given callback, which will watch the specified
<cite>path</cite> for changes. <cite>flags</cite> can be an ORed mask of <a class="reference internal" href="#c.uv_fs_event_flags" title="uv_fs_event_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_event_flags</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently the only supported flag is <code class="docutils literal notranslate"><span class="pre">UV_FS_EVENT_RECURSIVE</span></code> and
only on OSX and Windows.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_event_stop">
int <code class="descname">uv_fs_event_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_event_t" title="uv_fs_event_t">uv_fs_event_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_event_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the handle, the callback will no longer be called.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_event_getpath">
int <code class="descname">uv_fs_event_getpath</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_event_t" title="uv_fs_event_t">uv_fs_event_t</a>*<em>&nbsp;handle</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_event_getpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path being monitored by the handle. The buffer must be preallocated
by the user. Returns 0 on success or an error code &lt; 0 in case of failure.
On success, <cite>buffer</cite> will contain the path and <cite>size</cite> its length. If the buffer
is not big enough <cite>UV_ENOBUFS</cite> will be returned and <cite>size</cite> will be set to
the required size, including the null terminator.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the returned length no longer includes the terminating null byte,
and the buffer is not null terminated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9.0: </span>the returned length includes the terminating null
byte on <cite>UV_ENOBUFS</cite>, and the buffer is null terminated
on success.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-fs_poll"></span><div class="section" id="uv-fs-poll-t-fs-poll-handle">
<span id="fs-poll"></span><h4><a class="reference internal" href="#c.uv_fs_poll_t" title="uv_fs_poll_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_poll_t</span></code></a> — FS Poll handle<a class="headerlink" href="#uv-fs-poll-t-fs-poll-handle" title="Permalink to this headline">¶</a></h4>
<p>FS Poll handles allow the user to monitor a given path for changes. Unlike
<a class="reference internal" href="index.html#c.uv_fs_event_t" title="uv_fs_event_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_fs_event_t</span></code></a>, fs poll handles use <cite>stat</cite> to detect when a file has
changed so they can work on file systems where fs event handles can’t.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_fs_poll_t">
<code class="descname">uv_fs_poll_t</code><a class="headerlink" href="#c.uv_fs_poll_t" title="Permalink to this definition">¶</a></dt>
<dd><p>FS Poll handle type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_fs_poll_cb">
void <code class="descname">(*uv_fs_poll_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_poll_t" title="uv_fs_poll_t">uv_fs_poll_t</a>*<em>&nbsp;handle</em>, int<em>&nbsp;status</em>, const <a class="reference internal" href="index.html#c.uv_stat_t" title="uv_stat_t">uv_stat_t</a>*<em>&nbsp;prev</em>, const <a class="reference internal" href="index.html#c.uv_stat_t" title="uv_stat_t">uv_stat_t</a>*<em>&nbsp;curr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_poll_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback passed to <a class="reference internal" href="#c.uv_fs_poll_start" title="uv_fs_poll_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_poll_start()</span></code></a> which will be called repeatedly
after the handle is started, when any change happens to the monitored path.</p>
<p>The callback is invoked with <cite>status &lt; 0</cite> if <cite>path</cite> does not exist
or is inaccessible. The watcher is <em>not</em> stopped but your callback is
not called again until something changes (e.g. when the file is created
or the error reason changes).</p>
<p>When <cite>status == 0</cite>, the callback receives pointers to the old and new
<a class="reference internal" href="index.html#c.uv_stat_t" title="uv_stat_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_stat_t</span></code></a> structs. They are valid for the duration of the
callback only.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_fs_poll_init">
int <code class="descname">uv_fs_poll_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_poll_t" title="uv_fs_poll_t">uv_fs_poll_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_poll_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the handle.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_poll_start">
int <code class="descname">uv_fs_poll_start</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_poll_t" title="uv_fs_poll_t">uv_fs_poll_t</a>*<em>&nbsp;handle</em>, <a class="reference internal" href="index.html#c.uv_fs_poll_cb" title="uv_fs_poll_cb">uv_fs_poll_cb</a><em>&nbsp;poll_cb</em>, const char*<em>&nbsp;path</em>, unsigned int<em>&nbsp;interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_poll_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the file at <cite>path</cite> for changes every <cite>interval</cite> milliseconds.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For maximum portability, use multi-second intervals. Sub-second intervals will not detect
all changes on many file systems.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_poll_stop">
int <code class="descname">uv_fs_poll_stop</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_poll_t" title="uv_fs_poll_t">uv_fs_poll_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_poll_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the handle, the callback will no longer be called.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_poll_getpath">
int <code class="descname">uv_fs_poll_getpath</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_poll_t" title="uv_fs_poll_t">uv_fs_poll_t</a>*<em>&nbsp;handle</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_poll_getpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path being monitored by the handle. The buffer must be preallocated
by the user. Returns 0 on success or an error code &lt; 0 in case of failure.
On success, <cite>buffer</cite> will contain the path and <cite>size</cite> its length. If the buffer
is not big enough <cite>UV_ENOBUFS</cite> will be returned and <cite>size</cite> will be set to
the required size.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the returned length no longer includes the terminating null byte,
and the buffer is not null terminated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9.0: </span>the returned length includes the terminating null
byte on <cite>UV_ENOBUFS</cite>, and the buffer is null terminated
on success.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_handle_t" title="uv_handle_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_handle_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-fs"></span><div class="section" id="file-system-operations">
<span id="fs"></span><h4>File system operations<a class="headerlink" href="#file-system-operations" title="Permalink to this headline">¶</a></h4>
<p>libuv provides a wide variety of cross-platform sync and async file system
operations. All functions defined in this document take a callback, which is
allowed to be NULL. If the callback is NULL the request is completed synchronously,
otherwise it will be performed asynchronously.</p>
<p>All file operations are run on the threadpool. See <a class="reference internal" href="index.html#threadpool"><span class="std std-ref">Thread pool work scheduling</span></a> for information
on the threadpool size.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_fs_t">
<code class="descname">uv_fs_t</code><a class="headerlink" href="#c.uv_fs_t" title="Permalink to this definition">¶</a></dt>
<dd><p>File system request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_timespec_t">
<code class="descname">uv_timespec_t</code><a class="headerlink" href="#c.uv_timespec_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Portable equivalent of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">long</span> <span class="n">tv_sec</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">tv_nsec</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_timespec_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_stat_t">
<code class="descname">uv_stat_t</code><a class="headerlink" href="#c.uv_stat_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Portable equivalent of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">stat</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">st_dev</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_mode</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_nlink</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_uid</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_gid</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_rdev</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_ino</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_size</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_blksize</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_blocks</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_flags</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">st_gen</span><span class="p">;</span>
    <span class="n">uv_timespec_t</span> <span class="n">st_atim</span><span class="p">;</span>
    <span class="n">uv_timespec_t</span> <span class="n">st_mtim</span><span class="p">;</span>
    <span class="n">uv_timespec_t</span> <span class="n">st_ctim</span><span class="p">;</span>
    <span class="n">uv_timespec_t</span> <span class="n">st_birthtim</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_stat_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_fs_type">
<code class="descname">uv_fs_type</code><a class="headerlink" href="#c.uv_fs_type" title="Permalink to this definition">¶</a></dt>
<dd><p>File system request type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">UV_FS_UNKNOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">UV_FS_CUSTOM</span><span class="p">,</span>
    <span class="n">UV_FS_OPEN</span><span class="p">,</span>
    <span class="n">UV_FS_CLOSE</span><span class="p">,</span>
    <span class="n">UV_FS_READ</span><span class="p">,</span>
    <span class="n">UV_FS_WRITE</span><span class="p">,</span>
    <span class="n">UV_FS_SENDFILE</span><span class="p">,</span>
    <span class="n">UV_FS_STAT</span><span class="p">,</span>
    <span class="n">UV_FS_LSTAT</span><span class="p">,</span>
    <span class="n">UV_FS_FSTAT</span><span class="p">,</span>
    <span class="n">UV_FS_FTRUNCATE</span><span class="p">,</span>
    <span class="n">UV_FS_UTIME</span><span class="p">,</span>
    <span class="n">UV_FS_FUTIME</span><span class="p">,</span>
    <span class="n">UV_FS_ACCESS</span><span class="p">,</span>
    <span class="n">UV_FS_CHMOD</span><span class="p">,</span>
    <span class="n">UV_FS_FCHMOD</span><span class="p">,</span>
    <span class="n">UV_FS_FSYNC</span><span class="p">,</span>
    <span class="n">UV_FS_FDATASYNC</span><span class="p">,</span>
    <span class="n">UV_FS_UNLINK</span><span class="p">,</span>
    <span class="n">UV_FS_RMDIR</span><span class="p">,</span>
    <span class="n">UV_FS_MKDIR</span><span class="p">,</span>
    <span class="n">UV_FS_MKDTEMP</span><span class="p">,</span>
    <span class="n">UV_FS_RENAME</span><span class="p">,</span>
    <span class="n">UV_FS_SCANDIR</span><span class="p">,</span>
    <span class="n">UV_FS_LINK</span><span class="p">,</span>
    <span class="n">UV_FS_SYMLINK</span><span class="p">,</span>
    <span class="n">UV_FS_READLINK</span><span class="p">,</span>
    <span class="n">UV_FS_CHOWN</span><span class="p">,</span>
    <span class="n">UV_FS_FCHOWN</span><span class="p">,</span>
    <span class="n">UV_FS_REALPATH</span><span class="p">,</span>
    <span class="n">UV_FS_COPYFILE</span>
<span class="p">}</span> <span class="n">uv_fs_type</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_dirent_t">
<code class="descname">uv_dirent_t</code><a class="headerlink" href="#c.uv_dirent_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross platform (reduced) equivalent of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dirent</span></code>.
Used in <a class="reference internal" href="#c.uv_fs_scandir_next" title="uv_fs_scandir_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_scandir_next()</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">UV_DIRENT_UNKNOWN</span><span class="p">,</span>
    <span class="n">UV_DIRENT_FILE</span><span class="p">,</span>
    <span class="n">UV_DIRENT_DIR</span><span class="p">,</span>
    <span class="n">UV_DIRENT_LINK</span><span class="p">,</span>
    <span class="n">UV_DIRENT_FIFO</span><span class="p">,</span>
    <span class="n">UV_DIRENT_SOCKET</span><span class="p">,</span>
    <span class="n">UV_DIRENT_CHAR</span><span class="p">,</span>
    <span class="n">UV_DIRENT_BLOCK</span>
<span class="p">}</span> <span class="n">uv_dirent_type_t</span><span class="p">;</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_dirent_s</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">uv_dirent_type_t</span> <span class="nb">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_dirent_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_fs_t.loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_fs_t.loop</code><a class="headerlink" href="#c.uv_fs_t.loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop that started this request and where completion will be reported.
Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_fs_t.fs_type">
<a class="reference internal" href="index.html#c.uv_fs_type" title="uv_fs_type">uv_fs_type</a> <code class="descname">uv_fs_t.fs_type</code><a class="headerlink" href="#c.uv_fs_t.fs_type" title="Permalink to this definition">¶</a></dt>
<dd><p>FS request type.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_fs_t.path">
const char* <code class="descname">uv_fs_t.path</code><a class="headerlink" href="#c.uv_fs_t.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Path affecting the request.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_fs_t.result">
ssize_t <code class="descname">uv_fs_t.result</code><a class="headerlink" href="#c.uv_fs_t.result" title="Permalink to this definition">¶</a></dt>
<dd><p>Result of the request. &lt; 0 means error, success otherwise. On requests such
as <a class="reference internal" href="#c.uv_fs_read" title="uv_fs_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_read()</span></code></a> or <a class="reference internal" href="#c.uv_fs_write" title="uv_fs_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_write()</span></code></a> it indicates the amount of
data that was read or written, respectively.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_fs_t.statbuf">
<a class="reference internal" href="index.html#c.uv_stat_t" title="uv_stat_t">uv_stat_t</a> <code class="descname">uv_fs_t.statbuf</code><a class="headerlink" href="#c.uv_fs_t.statbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the result of <a class="reference internal" href="#c.uv_fs_stat" title="uv_fs_stat"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_stat()</span></code></a> and other stat requests.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_fs_t.ptr">
void* <code class="descname">uv_fs_t.ptr</code><a class="headerlink" href="#c.uv_fs_t.ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the result of <a class="reference internal" href="#c.uv_fs_readlink" title="uv_fs_readlink"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_readlink()</span></code></a> and
<a class="reference internal" href="#c.uv_fs_realpath" title="uv_fs_realpath"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_realpath()</span></code></a> and serves as an alias to <cite>statbuf</cite>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_fs_req_cleanup">
void <code class="descname">uv_fs_req_cleanup</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_req_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleanup request. Must be called after a request is finished to deallocate
any memory libuv might have allocated.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_close">
int <code class="descname">uv_fs_close</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/close">close(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_open">
int <code class="descname">uv_fs_open</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, int<em>&nbsp;flags</em>, int<em>&nbsp;mode</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/open">open(2)</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Windows libuv uses <cite>CreateFileW</cite> and thus the file is always opened
in binary mode. Because of this the O_BINARY and O_TEXT flags are not
supported.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_read">
int <code class="descname">uv_fs_read</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, int64_t<em>&nbsp;offset</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/preadv">preadv(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_unlink">
int <code class="descname">uv_fs_unlink</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/unlink">unlink(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_write">
int <code class="descname">uv_fs_write</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, const <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a><em>&nbsp;bufs[]</em>, unsigned int<em>&nbsp;nbufs</em>, int64_t<em>&nbsp;offset</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/pwritev">pwritev(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_mkdir">
int <code class="descname">uv_fs_mkdir</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, int<em>&nbsp;mode</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_mkdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/mkdir">mkdir(2)</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>mode</cite> is currently not implemented on Windows.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_mkdtemp">
int <code class="descname">uv_fs_mkdtemp</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;tpl</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_mkdtemp" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/3/mkdtemp">mkdtemp(3)</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The result can be found as a null terminated string at <cite>req-&gt;path</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_rmdir">
int <code class="descname">uv_fs_rmdir</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_rmdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/rmdir">rmdir(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_scandir">
int <code class="descname">uv_fs_scandir</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, int<em>&nbsp;flags</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_scandir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_fs_scandir_next">
int <code class="descname">uv_fs_scandir_next</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_dirent_t" title="uv_dirent_t">uv_dirent_t</a>*<em>&nbsp;ent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_scandir_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/3/scandir">scandir(3)</a>, with a slightly different API. Once the callback
for the request is called, the user can use <a class="reference internal" href="#c.uv_fs_scandir_next" title="uv_fs_scandir_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_scandir_next()</span></code></a> to
get <cite>ent</cite> populated with the next directory entry data. When there are no
more entries <code class="docutils literal notranslate"><span class="pre">UV_EOF</span></code> will be returned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike <cite>scandir(3)</cite>, this function does not return the “.” and “..” entries.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Linux, getting the type of an entry is only supported by some file systems (btrfs, ext2,
ext3 and ext4 at the time of this writing), check the <a class="reference external" href="http://linux.die.net/man/2/getdents">getdents(2)</a> man page.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_stat">
int <code class="descname">uv_fs_stat</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_stat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_fs_fstat">
int <code class="descname">uv_fs_fstat</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_fstat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_fs_lstat">
int <code class="descname">uv_fs_lstat</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_lstat" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/stat">stat(2)</a>, <a class="reference external" href="http://linux.die.net/man/2/fstat">fstat(2)</a> and <a class="reference external" href="http://linux.die.net/man/2/lstat">lstat(2)</a> respectively.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_rename">
int <code class="descname">uv_fs_rename</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, const char*<em>&nbsp;new_path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/rename">rename(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_fsync">
int <code class="descname">uv_fs_fsync</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/fsync">fsync(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_fdatasync">
int <code class="descname">uv_fs_fdatasync</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_fdatasync" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/fdatasync">fdatasync(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_ftruncate">
int <code class="descname">uv_fs_ftruncate</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, int64_t<em>&nbsp;offset</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_ftruncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/ftruncate">ftruncate(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_copyfile">
int <code class="descname">uv_fs_copyfile</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, const char*<em>&nbsp;new_path</em>, int<em>&nbsp;flags</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_copyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies a file from <cite>path</cite> to <cite>new_path</cite>. Supported <cite>flags</cite> are described below.</p>
<ul class="simple">
<li><cite>UV_FS_COPYFILE_EXCL</cite>: If present, <cite>uv_fs_copyfile()</cite> will fail with
<cite>UV_EEXIST</cite> if the destination path already exists. The default behavior
is to overwrite the destination if it exists.</li>
<li><cite>UV_FS_COPYFILE_FICLONE</cite>: If present, <cite>uv_fs_copyfile()</cite> will attempt to
create a copy-on-write reflink. If the underlying platform does not
support copy-on-write, then a fallback copy mechanism is used.</li>
<li><cite>UV_FS_COPYFILE_FICLONE_FORCE</cite>: If present, <cite>uv_fs_copyfile()</cite> will
attempt to create a copy-on-write reflink. If the underlying platform does
not support copy-on-write, then an error is returned.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the destination path is created, but an error occurs while copying
the data, then the destination path is removed. There is a brief window
of time between closing and removing the file where another process
could access the file.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.20.0: </span><cite>UV_FS_COPYFILE_FICLONE</cite> and
<cite>UV_FS_COPYFILE_FICLONE_FORCE</cite> are supported.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_sendfile">
int <code class="descname">uv_fs_sendfile</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;out_fd</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;in_fd</em>, int64_t<em>&nbsp;in_offset</em>, size_t<em>&nbsp;length</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_sendfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Limited equivalent to <a class="reference external" href="http://linux.die.net/man/2/sendfile">sendfile(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_access">
int <code class="descname">uv_fs_access</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, int<em>&nbsp;mode</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/access">access(2)</a> on Unix. Windows uses <code class="docutils literal notranslate"><span class="pre">GetFileAttributesW()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_chmod">
int <code class="descname">uv_fs_chmod</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, int<em>&nbsp;mode</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_chmod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_fs_fchmod">
int <code class="descname">uv_fs_fchmod</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, int<em>&nbsp;mode</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_fchmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/chmod">chmod(2)</a> and <a class="reference external" href="http://linux.die.net/man/2/fchmod">fchmod(2)</a> respectively.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_utime">
int <code class="descname">uv_fs_utime</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, double<em>&nbsp;atime</em>, double<em>&nbsp;mtime</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_utime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_fs_futime">
int <code class="descname">uv_fs_futime</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, double<em>&nbsp;atime</em>, double<em>&nbsp;mtime</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_futime" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/utime">utime(2)</a> and <a class="reference external" href="http://linux.die.net/man/2/futime">futime(2)</a> respectively.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">AIX: This function only works for AIX 7.1 and newer. It can still be called on older
versions but will return <code class="docutils literal notranslate"><span class="pre">UV_ENOSYS</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.10.0: </span>sub-second precission is supported on Windows</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_link">
int <code class="descname">uv_fs_link</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, const char*<em>&nbsp;new_path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/link">link(2)</a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_symlink">
int <code class="descname">uv_fs_symlink</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, const char*<em>&nbsp;new_path</em>, int<em>&nbsp;flags</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/symlink">symlink(2)</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>On Windows the <cite>flags</cite> parameter can be specified to control how the symlink will
be created:</p>
<blockquote class="last">
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">UV_FS_SYMLINK_DIR</span></code>: indicates that <cite>path</cite> points to a directory.</li>
<li><code class="docutils literal notranslate"><span class="pre">UV_FS_SYMLINK_JUNCTION</span></code>: request that the symlink is created
using junction points.</li>
</ul>
</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_readlink">
int <code class="descname">uv_fs_readlink</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/readlink">readlink(2)</a>.
The resulting string is stored in <cite>req-&gt;ptr</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_realpath">
int <code class="descname">uv_fs_realpath</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_realpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/3/realpath">realpath(3)</a> on Unix. Windows uses <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364962(v=vs.85).aspx">GetFinalPathNameByHandle</a>.
The resulting string is stored in <cite>req-&gt;ptr</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>This function has certain platform-specific caveats that were discovered when used in Node.</p>
<ul class="simple">
<li>macOS and other BSDs: this function will fail with UV_ELOOP if more than 32 symlinks are
found while resolving the given path.  This limit is hardcoded and cannot be sidestepped.</li>
<li>Windows: while this function works in the common case, there are a number of corner cases
where it doesn’t:<ul>
<li>Paths in ramdisk volumes created by tools which sidestep the Volume Manager (such as ImDisk)
cannot be resolved.</li>
<li>Inconsistent casing when using drive letters.</li>
<li>Resolved path bypasses subst’d drives.</li>
</ul>
</li>
</ul>
<p>While this function can still be used, it’s not recommended if scenarios such as the
above need to be supported.</p>
<p class="last">The background story and some more details on these issues can be checked
<a class="reference external" href="https://github.com/nodejs/node/issues/7726">here</a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is not implemented on Windows XP and Windows Server 2003.
On these systems, UV_ENOSYS is returned.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_chown">
int <code class="descname">uv_fs_chown</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, const char*<em>&nbsp;path</em>, uv_uid_t<em>&nbsp;uid</em>, uv_gid_t<em>&nbsp;gid</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_chown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_fs_fchown">
int <code class="descname">uv_fs_fchown</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em>, uv_uid_t<em>&nbsp;uid</em>, uv_gid_t<em>&nbsp;gid</em>, uv_fs_cb<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_fchown" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <a class="reference external" href="http://linux.die.net/man/2/chown">chown(2)</a> and <a class="reference external" href="http://linux.die.net/man/2/fchown">fchown(2)</a> respectively.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These functions are not implemented on Windows.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_get_type">
<a class="reference internal" href="index.html#c.uv_fs_type" title="uv_fs_type">uv_fs_type</a> <code class="descname">uv_fs_get_type</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>req-&gt;fs_type</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_get_result">
ssize_t <code class="descname">uv_fs_get_result</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_get_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>req-&gt;result</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_get_ptr">
void* <code class="descname">uv_fs_get_ptr</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_get_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>req-&gt;ptr</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_get_path">
const char* <code class="descname">uv_fs_get_path</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_get_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>req-&gt;path</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_fs_get_statbuf">
<a class="reference internal" href="index.html#c.uv_stat_t" title="uv_stat_t">uv_stat_t</a>* <code class="descname">uv_fs_get_statbuf</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_fs_t" title="uv_fs_t">uv_fs_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_fs_get_statbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>&amp;req-&gt;statbuf</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.19.0.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> API functions also apply.</p>
</div>
</div>
<div class="section" id="helper-functions">
<h5>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_get_osfhandle">
<a class="reference internal" href="index.html#c.uv_os_fd_t" title="uv_os_fd_t">uv_os_fd_t</a> <code class="descname">uv_get_osfhandle</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_get_osfhandle" title="Permalink to this definition">¶</a></dt>
<dd><p>For a file descriptor in the C runtime, get the OS-dependent handle.
On UNIX, returns the <code class="docutils literal notranslate"><span class="pre">fd</span></code> intact. On Windows, this calls <a class="reference external" href="https://msdn.microsoft.com/en-us/library/ks2530z6.aspx">_get_osfhandle</a>.
Note that the return value is still owned by the C runtime,
any attempts to close it or to use it after closing the fd may lead to malfunction.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="file-open-constants">
<h5>File open constants<a class="headerlink" href="#file-open-constants" title="Permalink to this headline">¶</a></h5>
<dl class="macro">
<dt id="c.UV_FS_O_APPEND">
<code class="descname">UV_FS_O_APPEND</code><a class="headerlink" href="#c.UV_FS_O_APPEND" title="Permalink to this definition">¶</a></dt>
<dd><p>The file is opened in append mode. Before each write, the file offset is
positioned at the end of the file.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_CREAT">
<code class="descname">UV_FS_O_CREAT</code><a class="headerlink" href="#c.UV_FS_O_CREAT" title="Permalink to this definition">¶</a></dt>
<dd><p>The file is created if it does not already exist.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_DIRECT">
<code class="descname">UV_FS_O_DIRECT</code><a class="headerlink" href="#c.UV_FS_O_DIRECT" title="Permalink to this definition">¶</a></dt>
<dd><p>File I/O is done directly to and from user-space buffers, which must be
aligned. Buffer size and address should be a multiple of the physical sector
size of the block device.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_DIRECT</cite> is supported on Linux, and on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/cc644950.aspx">FILE_FLAG_NO_BUFFERING</a>.
<cite>UV_FS_O_DIRECT</cite> is not supported on macOS.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_DIRECTORY">
<code class="descname">UV_FS_O_DIRECTORY</code><a class="headerlink" href="#c.UV_FS_O_DIRECTORY" title="Permalink to this definition">¶</a></dt>
<dd><p>If the path is not a directory, fail the open.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_DIRECTORY</cite> is not supported on Windows.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_DSYNC">
<code class="descname">UV_FS_O_DSYNC</code><a class="headerlink" href="#c.UV_FS_O_DSYNC" title="Permalink to this definition">¶</a></dt>
<dd><p>The file is opened for synchronous I/O. Write operations will complete once
all data and a minimum of metadata are flushed to disk.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_DSYNC</cite> is supported on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/cc644950.aspx">FILE_FLAG_WRITE_THROUGH</a>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_EXCL">
<code class="descname">UV_FS_O_EXCL</code><a class="headerlink" href="#c.UV_FS_O_EXCL" title="Permalink to this definition">¶</a></dt>
<dd><p>If the <cite>O_CREAT</cite> flag is set and the file already exists, fail the open.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, the behavior of <cite>O_EXCL</cite> is undefined if it is used without
<cite>O_CREAT</cite>. There is one exception: on Linux 2.6 and later, <cite>O_EXCL</cite> can
be used without <cite>O_CREAT</cite> if pathname refers to a block device. If the
block device is in use by the system (e.g., mounted), the open will fail
with the error <cite>EBUSY</cite>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_EXLOCK">
<code class="descname">UV_FS_O_EXLOCK</code><a class="headerlink" href="#c.UV_FS_O_EXLOCK" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically obtain an exclusive lock.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_EXLOCK</cite> is only supported on macOS and Windows.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.17.0: </span>support is added for Windows.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_NOATIME">
<code class="descname">UV_FS_O_NOATIME</code><a class="headerlink" href="#c.UV_FS_O_NOATIME" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not update the file access time when the file is read.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_NOATIME</cite> is not supported on Windows.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_NOCTTY">
<code class="descname">UV_FS_O_NOCTTY</code><a class="headerlink" href="#c.UV_FS_O_NOCTTY" title="Permalink to this definition">¶</a></dt>
<dd><p>If the path identifies a terminal device, opening the path will not cause
that terminal to become the controlling terminal for the process (if the
process does not already have one).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_NOCTTY</cite> is not supported on Windows.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_NOFOLLOW">
<code class="descname">UV_FS_O_NOFOLLOW</code><a class="headerlink" href="#c.UV_FS_O_NOFOLLOW" title="Permalink to this definition">¶</a></dt>
<dd><p>If the path is a symbolic link, fail the open.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_NOFOLLOW</cite> is not supported on Windows.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_NONBLOCK">
<code class="descname">UV_FS_O_NONBLOCK</code><a class="headerlink" href="#c.UV_FS_O_NONBLOCK" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the file in nonblocking mode if possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_NONBLOCK</cite> is not supported on Windows.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_RANDOM">
<code class="descname">UV_FS_O_RANDOM</code><a class="headerlink" href="#c.UV_FS_O_RANDOM" title="Permalink to this definition">¶</a></dt>
<dd><p>Access is intended to be random. The system can use this as a hint to
optimize file caching.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_RANDOM</cite> is only supported on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx">FILE_FLAG_RANDOM_ACCESS</a>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_RDONLY">
<code class="descname">UV_FS_O_RDONLY</code><a class="headerlink" href="#c.UV_FS_O_RDONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the file for read-only access.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_RDWR">
<code class="descname">UV_FS_O_RDWR</code><a class="headerlink" href="#c.UV_FS_O_RDWR" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the file for read-write access.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_SEQUENTIAL">
<code class="descname">UV_FS_O_SEQUENTIAL</code><a class="headerlink" href="#c.UV_FS_O_SEQUENTIAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Access is intended to be sequential from beginning to end. The system can
use this as a hint to optimize file caching.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_SEQUENTIAL</cite> is only supported on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx">FILE_FLAG_SEQUENTIAL_SCAN</a>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_SHORT_LIVED">
<code class="descname">UV_FS_O_SHORT_LIVED</code><a class="headerlink" href="#c.UV_FS_O_SHORT_LIVED" title="Permalink to this definition">¶</a></dt>
<dd><p>The file is temporary and should not be flushed to disk if possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_SHORT_LIVED</cite> is only supported on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx">FILE_ATTRIBUTE_TEMPORARY</a>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_SYMLINK">
<code class="descname">UV_FS_O_SYMLINK</code><a class="headerlink" href="#c.UV_FS_O_SYMLINK" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the symbolic link itself rather than the resource it points to.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_SYNC">
<code class="descname">UV_FS_O_SYNC</code><a class="headerlink" href="#c.UV_FS_O_SYNC" title="Permalink to this definition">¶</a></dt>
<dd><p>The file is opened for synchronous I/O. Write operations will complete once
all data and all metadata are flushed to disk.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_SYNC</cite> is supported on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/cc644950.aspx">FILE_FLAG_WRITE_THROUGH</a>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_TEMPORARY">
<code class="descname">UV_FS_O_TEMPORARY</code><a class="headerlink" href="#c.UV_FS_O_TEMPORARY" title="Permalink to this definition">¶</a></dt>
<dd><p>The file is temporary and should not be flushed to disk if possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>UV_FS_O_TEMPORARY</cite> is only supported on Windows via
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx">FILE_ATTRIBUTE_TEMPORARY</a>.</p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_TRUNC">
<code class="descname">UV_FS_O_TRUNC</code><a class="headerlink" href="#c.UV_FS_O_TRUNC" title="Permalink to this definition">¶</a></dt>
<dd><p>If the file exists and is a regular file, and the file is opened
successfully for write access, its length shall be truncated to zero.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_FS_O_WRONLY">
<code class="descname">UV_FS_O_WRONLY</code><a class="headerlink" href="#c.UV_FS_O_WRONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the file for write-only access.</p>
</dd></dl>

</div>
</div>
<span id="document-threadpool"></span><div class="section" id="thread-pool-work-scheduling">
<span id="threadpool"></span><h4>Thread pool work scheduling<a class="headerlink" href="#thread-pool-work-scheduling" title="Permalink to this headline">¶</a></h4>
<p>libuv provides a threadpool which can be used to run user code and get notified
in the loop thread. This thread pool is internally used to run all file system
operations, as well as getaddrinfo and getnameinfo requests.</p>
<p>Its default size is 4, but it can be changed at startup time by setting the
<code class="docutils literal notranslate"><span class="pre">UV_THREADPOOL_SIZE</span></code> environment variable to any value (the absolute maximum
is 128).</p>
<p>The threadpool is global and shared across all event loops. When a particular
function makes use of the threadpool (i.e. when using <a class="reference internal" href="#c.uv_queue_work" title="uv_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_queue_work()</span></code></a>)
libuv preallocates and initializes the maximum number of threads allowed by
<code class="docutils literal notranslate"><span class="pre">UV_THREADPOOL_SIZE</span></code>. This causes a relatively minor memory overhead
(~1MB for 128 threads) but increases the performance of threading at runtime.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that even though a global thread pool which is shared across all events
loops is used, the functions are not thread safe.</p>
</div>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_work_t">
<code class="descname">uv_work_t</code><a class="headerlink" href="#c.uv_work_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Work request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_work_cb">
void <code class="descname">(*uv_work_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_work_t" title="uv_work_t">uv_work_t</a>*<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_work_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback passed to <a class="reference internal" href="#c.uv_queue_work" title="uv_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_queue_work()</span></code></a> which will be run on the thread
pool.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_after_work_cb">
void <code class="descname">(*uv_after_work_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_work_t" title="uv_work_t">uv_work_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_after_work_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback passed to <a class="reference internal" href="#c.uv_queue_work" title="uv_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_queue_work()</span></code></a> which will be called on the loop
thread after the work on the threadpool has been completed. If the work
was cancelled using <a class="reference internal" href="index.html#c.uv_cancel" title="uv_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cancel()</span></code></a> <cite>status</cite> will be <code class="docutils literal notranslate"><span class="pre">UV_ECANCELED</span></code>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_work_t.loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_work_t.loop</code><a class="headerlink" href="#c.uv_work_t.loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop that started this request and where completion will be reported.
Readonly.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_queue_work">
int <code class="descname">uv_queue_work</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_work_t" title="uv_work_t">uv_work_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_work_cb" title="uv_work_cb">uv_work_cb</a><em>&nbsp;work_cb</em>, <a class="reference internal" href="index.html#c.uv_after_work_cb" title="uv_after_work_cb">uv_after_work_cb</a><em>&nbsp;after_work_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_queue_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a work request which will run the given <cite>work_cb</cite> in a thread
from the threadpool. Once <cite>work_cb</cite> is completed, <cite>after_work_cb</cite> will be
called on the loop thread.</p>
<p>This request can be cancelled with <a class="reference internal" href="index.html#c.uv_cancel" title="uv_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cancel()</span></code></a>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-dns"></span><div class="section" id="dns-utility-functions">
<span id="dns"></span><h4>DNS utility functions<a class="headerlink" href="#dns-utility-functions" title="Permalink to this headline">¶</a></h4>
<p>libuv provides asynchronous variants of <cite>getaddrinfo</cite> and <cite>getnameinfo</cite>.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_getaddrinfo_t">
<code class="descname">uv_getaddrinfo_t</code><a class="headerlink" href="#c.uv_getaddrinfo_t" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>getaddrinfo</cite> request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_getaddrinfo_cb">
void <code class="descname">(*uv_getaddrinfo_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_getaddrinfo_t" title="uv_getaddrinfo_t">uv_getaddrinfo_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em>, struct addrinfo*<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_getaddrinfo_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback which will be called with the getaddrinfo request result once
complete. In case it was cancelled, <cite>status</cite> will have a value of
<code class="docutils literal notranslate"><span class="pre">UV_ECANCELED</span></code>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_getnameinfo_t">
<code class="descname">uv_getnameinfo_t</code><a class="headerlink" href="#c.uv_getnameinfo_t" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>getnameinfo</cite> request type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_getnameinfo_cb">
void <code class="descname">(*uv_getnameinfo_cb)</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_getnameinfo_t" title="uv_getnameinfo_t">uv_getnameinfo_t</a>*<em>&nbsp;req</em>, int<em>&nbsp;status</em>, const char*<em>&nbsp;hostname</em>, const char*<em>&nbsp;service</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_getnameinfo_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback which will be called with the getnameinfo request result once
complete. In case it was cancelled, <cite>status</cite> will have a value of
<code class="docutils literal notranslate"><span class="pre">UV_ECANCELED</span></code>.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<dl class="member">
<dt id="c.uv_getaddrinfo_t.loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_getaddrinfo_t.loop</code><a class="headerlink" href="#c.uv_getaddrinfo_t.loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop that started this getaddrinfo request and where completion will be
reported. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_getaddrinfo_t.addrinfo">
struct addrinfo* <code class="descname">uv_getaddrinfo_t.addrinfo</code><a class="headerlink" href="#c.uv_getaddrinfo_t.addrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to a <cite>struct addrinfo</cite> containing the result. Must be freed by the user
with <a class="reference internal" href="#c.uv_freeaddrinfo" title="uv_freeaddrinfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_freeaddrinfo()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the field is declared as public.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.uv_getnameinfo_t.loop">
<a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>* <code class="descname">uv_getnameinfo_t.loop</code><a class="headerlink" href="#c.uv_getnameinfo_t.loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop that started this getnameinfo request and where completion will be
reported. Readonly.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_getnameinfo_t.host">
char[NI_MAXHOST] <code class="descname">uv_getnameinfo_t.host</code><a class="headerlink" href="#c.uv_getnameinfo_t.host" title="Permalink to this definition">¶</a></dt>
<dd><p>Char array containing the resulting host. It’s null terminated.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the field is declared as public.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.uv_getnameinfo_t.service">
char[NI_MAXSERV] <code class="descname">uv_getnameinfo_t.service</code><a class="headerlink" href="#c.uv_getnameinfo_t.service" title="Permalink to this definition">¶</a></dt>
<dd><p>Char array containing the resulting service. It’s null terminated.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the field is declared as public.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> members also apply.</p>
</div>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_getaddrinfo">
int <code class="descname">uv_getaddrinfo</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_getaddrinfo_t" title="uv_getaddrinfo_t">uv_getaddrinfo_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_getaddrinfo_cb" title="uv_getaddrinfo_cb">uv_getaddrinfo_cb</a><em>&nbsp;getaddrinfo_cb</em>, const char*<em>&nbsp;node</em>, const char*<em>&nbsp;service</em>, const struct addrinfo*<em>&nbsp;hints</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_getaddrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Asynchronous <a class="reference external" href="http://linux.die.net/man/3/getaddrinfo">getaddrinfo(3)</a>.</p>
<p>Either node or service may be NULL but not both.</p>
<p><cite>hints</cite> is a pointer to a struct addrinfo with additional address type
constraints, or NULL. Consult <cite>man -s 3 getaddrinfo</cite> for more details.</p>
<p>Returns 0 on success or an error code &lt; 0 on failure. If successful, the
callback will get called sometime in the future with the lookup result,
which is either:</p>
<ul class="simple">
<li>status == 0, the res argument points to a valid <cite>struct addrinfo</cite>, or</li>
<li>status &lt; 0, the res argument is NULL. See the UV_EAI_* constants.</li>
</ul>
<p>Call <a class="reference internal" href="#c.uv_freeaddrinfo" title="uv_freeaddrinfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_freeaddrinfo()</span></code></a> to free the addrinfo structure.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the callback parameter is now allowed to be NULL,
in which case the request will run <strong>synchronously</strong>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_freeaddrinfo">
void <code class="descname">uv_freeaddrinfo</code><span class="sig-paren">(</span>struct addrinfo*<em>&nbsp;ai</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_freeaddrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the struct addrinfo. Passing NULL is allowed and is a no-op.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_getnameinfo">
int <code class="descname">uv_getnameinfo</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, <a class="reference internal" href="index.html#c.uv_getnameinfo_t" title="uv_getnameinfo_t">uv_getnameinfo_t</a>*<em>&nbsp;req</em>, <a class="reference internal" href="index.html#c.uv_getnameinfo_cb" title="uv_getnameinfo_cb">uv_getnameinfo_cb</a><em>&nbsp;getnameinfo_cb</em>, const struct sockaddr*<em>&nbsp;addr</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_getnameinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Asynchronous <a class="reference external" href="http://linux.die.net/man/3/getnameinfo">getnameinfo(3)</a>.</p>
<p>Returns 0 on success or an error code &lt; 0 on failure. If successful, the
callback will get called sometime in the future with the lookup result.
Consult <cite>man -s 3 getnameinfo</cite> for more details.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3.0: </span>the callback parameter is now allowed to be NULL,
in which case the request will run <strong>synchronously</strong>.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="index.html#c.uv_req_t" title="uv_req_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_req_t</span></code></a> API functions also apply.</p>
</div>
</div>
</div>
<span id="document-dll"></span><div class="section" id="shared-library-handling">
<span id="dll"></span><h4>Shared library handling<a class="headerlink" href="#shared-library-handling" title="Permalink to this headline">¶</a></h4>
<p>libuv provides cross platform utilities for loading shared libraries and
retrieving symbols from them, using the following API.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_lib_t">
<code class="descname">uv_lib_t</code><a class="headerlink" href="#c.uv_lib_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Shared library data type.</p>
</dd></dl>

<div class="section" id="public-members">
<h6>Public members<a class="headerlink" href="#public-members" title="Permalink to this headline">¶</a></h6>
<p>N/A</p>
</div>
</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_dlopen">
int <code class="descname">uv_dlopen</code><span class="sig-paren">(</span>const char*<em>&nbsp;filename</em>, <a class="reference internal" href="index.html#c.uv_lib_t" title="uv_lib_t">uv_lib_t</a>*<em>&nbsp;lib</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_dlopen" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a shared library. The filename is in utf-8. Returns 0 on success and
-1 on error. Call <a class="reference internal" href="#c.uv_dlerror" title="uv_dlerror"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_dlerror()</span></code></a> to get the error message.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_dlclose">
void <code class="descname">uv_dlclose</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_lib_t" title="uv_lib_t">uv_lib_t</a>*<em>&nbsp;lib</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_dlclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the shared library.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_dlsym">
int <code class="descname">uv_dlsym</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_lib_t" title="uv_lib_t">uv_lib_t</a>*<em>&nbsp;lib</em>, const char*<em>&nbsp;name</em>, void**<em>&nbsp;ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_dlsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves a data pointer from a dynamic library. It is legal for a symbol
to map to NULL. Returns 0 on success and -1 if the symbol was not found.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_dlerror">
const char* <code class="descname">uv_dlerror</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_lib_t" title="uv_lib_t">uv_lib_t</a>*<em>&nbsp;lib</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_dlerror" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last uv_dlopen() or uv_dlsym() error message.</p>
</dd></dl>

</div>
</div>
<span id="document-threading"></span><div class="section" id="threading-and-synchronization-utilities">
<span id="threading"></span><h4>Threading and synchronization utilities<a class="headerlink" href="#threading-and-synchronization-utilities" title="Permalink to this headline">¶</a></h4>
<p>libuv provides cross-platform implementations for multiple threading and
synchronization primitives. The API largely follows the pthreads API.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_thread_t">
<code class="descname">uv_thread_t</code><a class="headerlink" href="#c.uv_thread_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Thread data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_thread_cb">
void <code class="descname">(*uv_thread_cb)</code><span class="sig-paren">(</span>void*<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_thread_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback that is invoked to initialize thread execution. <cite>arg</cite> is the same
value that was passed to <a class="reference internal" href="#c.uv_thread_create" title="uv_thread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_thread_create()</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_key_t">
<code class="descname">uv_key_t</code><a class="headerlink" href="#c.uv_key_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Thread-local key data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_once_t">
<code class="descname">uv_once_t</code><a class="headerlink" href="#c.uv_once_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Once-only initializer data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_mutex_t">
<code class="descname">uv_mutex_t</code><a class="headerlink" href="#c.uv_mutex_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutex data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_rwlock_t">
<code class="descname">uv_rwlock_t</code><a class="headerlink" href="#c.uv_rwlock_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-write lock data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_sem_t">
<code class="descname">uv_sem_t</code><a class="headerlink" href="#c.uv_sem_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Semaphore data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_cond_t">
<code class="descname">uv_cond_t</code><a class="headerlink" href="#c.uv_cond_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Condition data type.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_barrier_t">
<code class="descname">uv_barrier_t</code><a class="headerlink" href="#c.uv_barrier_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Barrier data type.</p>
</dd></dl>

</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<div class="section" id="threads">
<h6>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h6>
<dl class="function">
<dt id="c.uv_thread_create">
int <code class="descname">uv_thread_create</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_thread_t" title="uv_thread_t">uv_thread_t</a>*<em>&nbsp;tid</em>, <a class="reference internal" href="index.html#c.uv_thread_cb" title="uv_thread_cb">uv_thread_cb</a><em>&nbsp;entry</em>, void*<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_thread_create" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.4.1: </span>returns a UV_E* error code on failure</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_thread_self">
<a class="reference internal" href="index.html#c.uv_thread_t" title="uv_thread_t">uv_thread_t</a> <code class="descname">uv_thread_self</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_thread_self" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_thread_join">
int <code class="descname">uv_thread_join</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_thread_t" title="uv_thread_t">uv_thread_t</a><em>&nbsp;*tid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_thread_join" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_thread_equal">
int <code class="descname">uv_thread_equal</code><span class="sig-paren">(</span>const <a class="reference internal" href="index.html#c.uv_thread_t" title="uv_thread_t">uv_thread_t</a>*<em>&nbsp;t1</em>, const <a class="reference internal" href="index.html#c.uv_thread_t" title="uv_thread_t">uv_thread_t</a>*<em>&nbsp;t2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_thread_equal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="thread-local-storage">
<h6>Thread-local storage<a class="headerlink" href="#thread-local-storage" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The total thread-local storage size may be limited. That is, it may not be possible to
create many TLS keys.</p>
</div>
<dl class="function">
<dt id="c.uv_key_create">
int <code class="descname">uv_key_create</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_key_t" title="uv_key_t">uv_key_t</a>*<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_key_create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_key_delete">
void <code class="descname">uv_key_delete</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_key_t" title="uv_key_t">uv_key_t</a>*<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_key_delete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_key_get">
void* <code class="descname">uv_key_get</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_key_t" title="uv_key_t">uv_key_t</a>*<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_key_get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_key_set">
void <code class="descname">uv_key_set</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_key_t" title="uv_key_t">uv_key_t</a>*<em>&nbsp;key</em>, void*<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_key_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="once-only-initialization">
<h6>Once-only initialization<a class="headerlink" href="#once-only-initialization" title="Permalink to this headline">¶</a></h6>
<p>Runs a function once and only once. Concurrent calls to <a class="reference internal" href="#c.uv_once" title="uv_once"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_once()</span></code></a> with the
same guard will block all callers except one (it’s unspecified which one).
The guard should be initialized statically with the UV_ONCE_INIT macro.</p>
<dl class="function">
<dt id="c.uv_once">
void <code class="descname">uv_once</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_once_t" title="uv_once_t">uv_once_t</a>*<em>&nbsp;guard</em>, void (<em>*callback</em>)(void)<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="mutex-locks">
<h6>Mutex locks<a class="headerlink" href="#mutex-locks" title="Permalink to this headline">¶</a></h6>
<p>Functions return 0 on success or an error code &lt; 0 (unless the
return type is void, of course).</p>
<dl class="function">
<dt id="c.uv_mutex_init">
int <code class="descname">uv_mutex_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_mutex_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_mutex_init_recursive">
int <code class="descname">uv_mutex_init_recursive</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_mutex_init_recursive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_mutex_destroy">
void <code class="descname">uv_mutex_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_mutex_destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_mutex_lock">
void <code class="descname">uv_mutex_lock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_mutex_trylock">
int <code class="descname">uv_mutex_trylock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_mutex_trylock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_mutex_unlock">
void <code class="descname">uv_mutex_unlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="read-write-locks">
<h6>Read-write locks<a class="headerlink" href="#read-write-locks" title="Permalink to this headline">¶</a></h6>
<p>Functions return 0 on success or an error code &lt; 0 (unless the
return type is void, of course).</p>
<dl class="function">
<dt id="c.uv_rwlock_init">
int <code class="descname">uv_rwlock_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_destroy">
void <code class="descname">uv_rwlock_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_rdlock">
void <code class="descname">uv_rwlock_rdlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_rdlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_tryrdlock">
int <code class="descname">uv_rwlock_tryrdlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_tryrdlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_rdunlock">
void <code class="descname">uv_rwlock_rdunlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_rdunlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_wrlock">
void <code class="descname">uv_rwlock_wrlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_wrlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_trywrlock">
int <code class="descname">uv_rwlock_trywrlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_trywrlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_rwlock_wrunlock">
void <code class="descname">uv_rwlock_wrunlock</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rwlock_t" title="uv_rwlock_t">uv_rwlock_t</a>*<em>&nbsp;rwlock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_rwlock_wrunlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="semaphores">
<h6>Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this headline">¶</a></h6>
<p>Functions return 0 on success or an error code &lt; 0 (unless the
return type is void, of course).</p>
<dl class="function">
<dt id="c.uv_sem_init">
int <code class="descname">uv_sem_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_sem_t" title="uv_sem_t">uv_sem_t</a>*<em>&nbsp;sem</em>, unsigned int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_sem_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_sem_destroy">
void <code class="descname">uv_sem_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_sem_t" title="uv_sem_t">uv_sem_t</a>*<em>&nbsp;sem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_sem_destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_sem_post">
void <code class="descname">uv_sem_post</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_sem_t" title="uv_sem_t">uv_sem_t</a>*<em>&nbsp;sem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_sem_post" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_sem_wait">
void <code class="descname">uv_sem_wait</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_sem_t" title="uv_sem_t">uv_sem_t</a>*<em>&nbsp;sem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_sem_wait" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_sem_trywait">
int <code class="descname">uv_sem_trywait</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_sem_t" title="uv_sem_t">uv_sem_t</a>*<em>&nbsp;sem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_sem_trywait" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="conditions">
<h6>Conditions<a class="headerlink" href="#conditions" title="Permalink to this headline">¶</a></h6>
<p>Functions return 0 on success or an error code &lt; 0 (unless the
return type is void, of course).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Callers should be prepared to deal with spurious wakeups on <a class="reference internal" href="#c.uv_cond_wait" title="uv_cond_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cond_wait()</span></code></a>
and <a class="reference internal" href="#c.uv_cond_timedwait" title="uv_cond_timedwait"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cond_timedwait()</span></code></a>.</li>
<li>The timeout parameter for <a class="reference internal" href="#c.uv_cond_timedwait" title="uv_cond_timedwait"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cond_timedwait()</span></code></a> is relative to the time
at which function is called.</li>
<li>On z/OS, the timeout parameter for <a class="reference internal" href="#c.uv_cond_timedwait" title="uv_cond_timedwait"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cond_timedwait()</span></code></a> is converted to an
absolute system time at which the wait expires. If the current system clock time
passes the absolute time calculated before the condition is signaled, an ETIMEDOUT
error results. After the wait begins, the wait time is not affected by changes
to the system clock.</li>
</ol>
</div>
<dl class="function">
<dt id="c.uv_cond_init">
int <code class="descname">uv_cond_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cond_t" title="uv_cond_t">uv_cond_t</a>*<em>&nbsp;cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cond_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_cond_destroy">
void <code class="descname">uv_cond_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cond_t" title="uv_cond_t">uv_cond_t</a>*<em>&nbsp;cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cond_destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_cond_signal">
void <code class="descname">uv_cond_signal</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cond_t" title="uv_cond_t">uv_cond_t</a>*<em>&nbsp;cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cond_signal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_cond_broadcast">
void <code class="descname">uv_cond_broadcast</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cond_t" title="uv_cond_t">uv_cond_t</a>*<em>&nbsp;cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cond_broadcast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_cond_wait">
void <code class="descname">uv_cond_wait</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cond_t" title="uv_cond_t">uv_cond_t</a>*<em>&nbsp;cond</em>, <a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;mutex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cond_wait" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_cond_timedwait">
int <code class="descname">uv_cond_timedwait</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cond_t" title="uv_cond_t">uv_cond_t</a>*<em>&nbsp;cond</em>, <a class="reference internal" href="index.html#c.uv_mutex_t" title="uv_mutex_t">uv_mutex_t</a>*<em>&nbsp;mutex</em>, uint64_t<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cond_timedwait" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="barriers">
<h6>Barriers<a class="headerlink" href="#barriers" title="Permalink to this headline">¶</a></h6>
<p>Functions return 0 on success or an error code &lt; 0 (unless the
return type is void, of course).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="reference internal" href="#c.uv_barrier_wait" title="uv_barrier_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_barrier_wait()</span></code></a> returns a value &gt; 0 to an arbitrarily chosen “serializer” thread
to facilitate cleanup, i.e.</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">uv_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">uv_barrier_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier</span><span class="p">);</span>
</pre></div>
</div>
</div>
<dl class="function">
<dt id="c.uv_barrier_init">
int <code class="descname">uv_barrier_init</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_barrier_t" title="uv_barrier_t">uv_barrier_t</a>*<em>&nbsp;barrier</em>, unsigned int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_barrier_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_barrier_destroy">
void <code class="descname">uv_barrier_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_barrier_t" title="uv_barrier_t">uv_barrier_t</a>*<em>&nbsp;barrier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_barrier_destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_barrier_wait">
int <code class="descname">uv_barrier_wait</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_barrier_t" title="uv_barrier_t">uv_barrier_t</a>*<em>&nbsp;barrier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_barrier_wait" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>
<span id="document-misc"></span><div class="section" id="miscellaneous-utilities">
<span id="misc"></span><h4>Miscellaneous utilities<a class="headerlink" href="#miscellaneous-utilities" title="Permalink to this headline">¶</a></h4>
<p>This section contains miscellaneous functions that don’t really belong in any
other section.</p>
<div class="section" id="data-types">
<h5>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h5>
<dl class="type">
<dt id="c.uv_buf_t">
<code class="descname">uv_buf_t</code><a class="headerlink" href="#c.uv_buf_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Buffer data type.</p>
<dl class="member">
<dt id="c.uv_buf_t.uv_buf_t.base">
char* <code class="descname">uv_buf_t.base</code><a class="headerlink" href="#c.uv_buf_t.uv_buf_t.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer to the base of the buffer.</p>
</dd></dl>

<dl class="member">
<dt id="c.uv_buf_t.uv_buf_t.len">
size_t <code class="descname">uv_buf_t.len</code><a class="headerlink" href="#c.uv_buf_t.uv_buf_t.len" title="Permalink to this definition">¶</a></dt>
<dd><p>Total bytes in the buffer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Windows this field is ULONG.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="c.uv_malloc_func">
void* <code class="descname">(*uv_malloc_func)</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_malloc_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Replacement function for <a class="reference external" href="http://linux.die.net/man/3/malloc">malloc(3)</a>.
See <a class="reference internal" href="#c.uv_replace_allocator" title="uv_replace_allocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_replace_allocator()</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_realloc_func">
void* <code class="descname">(*uv_realloc_func)</code><span class="sig-paren">(</span>void*<em>&nbsp;ptr</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_realloc_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Replacement function for <a class="reference external" href="http://linux.die.net/man/3/realloc">realloc(3)</a>.
See <a class="reference internal" href="#c.uv_replace_allocator" title="uv_replace_allocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_replace_allocator()</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_calloc_func">
void* <code class="descname">(*uv_calloc_func)</code><span class="sig-paren">(</span>size_t<em>&nbsp;count</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_calloc_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Replacement function for <a class="reference external" href="http://linux.die.net/man/3/calloc">calloc(3)</a>.
See <a class="reference internal" href="#c.uv_replace_allocator" title="uv_replace_allocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_replace_allocator()</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_free_func">
void <code class="descname">(*uv_free_func)</code><span class="sig-paren">(</span>void*<em>&nbsp;ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_free_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Replacement function for <a class="reference external" href="http://linux.die.net/man/3/free">free(3)</a>.
See <a class="reference internal" href="#c.uv_replace_allocator" title="uv_replace_allocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_replace_allocator()</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_file">
<code class="descname">uv_file</code><a class="headerlink" href="#c.uv_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross platform representation of a file handle.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_os_sock_t">
<code class="descname">uv_os_sock_t</code><a class="headerlink" href="#c.uv_os_sock_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross platform representation of a socket handle.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_os_fd_t">
<code class="descname">uv_os_fd_t</code><a class="headerlink" href="#c.uv_os_fd_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract representation of a file descriptor. On Unix systems this is a
<cite>typedef</cite> of <cite>int</cite> and on Windows a <cite>HANDLE</cite>.</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_pid_t">
<code class="descname">uv_pid_t</code><a class="headerlink" href="#c.uv_pid_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross platform representation of a <cite>pid_t</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.16.0.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_rusage_t">
<code class="descname">uv_rusage_t</code><a class="headerlink" href="#c.uv_rusage_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type for resource usage results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">uv_timeval_t</span> <span class="n">ru_utime</span><span class="p">;</span> <span class="o">/*</span> <span class="n">user</span> <span class="n">CPU</span> <span class="n">time</span> <span class="n">used</span> <span class="o">*/</span>
    <span class="n">uv_timeval_t</span> <span class="n">ru_stime</span><span class="p">;</span> <span class="o">/*</span> <span class="n">system</span> <span class="n">CPU</span> <span class="n">time</span> <span class="n">used</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_maxrss</span><span class="p">;</span> <span class="o">/*</span> <span class="n">maximum</span> <span class="n">resident</span> <span class="nb">set</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_ixrss</span><span class="p">;</span> <span class="o">/*</span> <span class="n">integral</span> <span class="n">shared</span> <span class="n">memory</span> <span class="n">size</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_idrss</span><span class="p">;</span> <span class="o">/*</span> <span class="n">integral</span> <span class="n">unshared</span> <span class="n">data</span> <span class="n">size</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_isrss</span><span class="p">;</span> <span class="o">/*</span> <span class="n">integral</span> <span class="n">unshared</span> <span class="n">stack</span> <span class="n">size</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_minflt</span><span class="p">;</span> <span class="o">/*</span> <span class="n">page</span> <span class="n">reclaims</span> <span class="p">(</span><span class="n">soft</span> <span class="n">page</span> <span class="n">faults</span><span class="p">)</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_majflt</span><span class="p">;</span> <span class="o">/*</span> <span class="n">page</span> <span class="n">faults</span> <span class="p">(</span><span class="n">hard</span> <span class="n">page</span> <span class="n">faults</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_nswap</span><span class="p">;</span> <span class="o">/*</span> <span class="n">swaps</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_inblock</span><span class="p">;</span> <span class="o">/*</span> <span class="n">block</span> <span class="nb">input</span> <span class="n">operations</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_oublock</span><span class="p">;</span> <span class="o">/*</span> <span class="n">block</span> <span class="n">output</span> <span class="n">operations</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_msgsnd</span><span class="p">;</span> <span class="o">/*</span> <span class="n">IPC</span> <span class="n">messages</span> <span class="n">sent</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_msgrcv</span><span class="p">;</span> <span class="o">/*</span> <span class="n">IPC</span> <span class="n">messages</span> <span class="n">received</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_nsignals</span><span class="p">;</span> <span class="o">/*</span> <span class="n">signals</span> <span class="n">received</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_nvcsw</span><span class="p">;</span> <span class="o">/*</span> <span class="n">voluntary</span> <span class="n">context</span> <span class="n">switches</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ru_nivcsw</span><span class="p">;</span> <span class="o">/*</span> <span class="n">involuntary</span> <span class="n">context</span> <span class="n">switches</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*/</span>
<span class="p">}</span> <span class="n">uv_rusage_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Members marked with <cite>(X)</cite> are unsupported on Windows.
See <a class="reference external" href="http://linux.die.net/man/2/getrusage">getrusage(2)</a> for supported fields on Unix</p>
</dd></dl>

<dl class="type">
<dt id="c.uv_cpu_info_t">
<code class="descname">uv_cpu_info_t</code><a class="headerlink" href="#c.uv_cpu_info_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type for CPU information.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_cpu_info_s</span> <span class="p">{</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">model</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">speed</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">uv_cpu_times_s</span> <span class="p">{</span>
        <span class="n">uint64_t</span> <span class="n">user</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">nice</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">sys</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">idle</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">irq</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">cpu_times</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_cpu_info_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_interface_address_t">
<code class="descname">uv_interface_address_t</code><a class="headerlink" href="#c.uv_interface_address_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type for interface addresses.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_interface_address_s</span> <span class="p">{</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">char</span> <span class="n">phys_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
    <span class="nb">int</span> <span class="n">is_internal</span><span class="p">;</span>
    <span class="n">union</span> <span class="p">{</span>
        <span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">address4</span><span class="p">;</span>
        <span class="n">struct</span> <span class="n">sockaddr_in6</span> <span class="n">address6</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">address</span><span class="p">;</span>
    <span class="n">union</span> <span class="p">{</span>
        <span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">netmask4</span><span class="p">;</span>
        <span class="n">struct</span> <span class="n">sockaddr_in6</span> <span class="n">netmask6</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">netmask</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_interface_address_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="c.uv_passwd_t">
<code class="descname">uv_passwd_t</code><a class="headerlink" href="#c.uv_passwd_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type for password file information.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_passwd_s</span> <span class="p">{</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">username</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">uid</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">gid</span><span class="p">;</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">shell</span><span class="p">;</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">homedir</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_passwd_t</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="api">
<h5>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="c.uv_guess_handle">
<a class="reference internal" href="index.html#c.uv_handle_type" title="uv_handle_type">uv_handle_type</a> <code class="descname">uv_guess_handle</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_file" title="uv_file">uv_file</a><em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_guess_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to detect what type of stream should be used with a given file
descriptor. Usually this will be used during initialization to guess the
type of the stdio streams.</p>
<p>For <a class="reference external" href="http://linux.die.net/man/3/isatty">isatty(3)</a> equivalent functionality use this function and test
for <code class="docutils literal notranslate"><span class="pre">UV_TTY</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_replace_allocator">
int <code class="descname">uv_replace_allocator</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_malloc_func" title="uv_malloc_func">uv_malloc_func</a><em>&nbsp;malloc_func</em>, <a class="reference internal" href="index.html#c.uv_realloc_func" title="uv_realloc_func">uv_realloc_func</a><em>&nbsp;realloc_func</em>, <a class="reference internal" href="index.html#c.uv_calloc_func" title="uv_calloc_func">uv_calloc_func</a><em>&nbsp;calloc_func</em>, <a class="reference internal" href="index.html#c.uv_free_func" title="uv_free_func">uv_free_func</a><em>&nbsp;free_func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_replace_allocator" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
<p>Override the use of the standard library’s <a class="reference external" href="http://linux.die.net/man/3/malloc">malloc(3)</a>,
<a class="reference external" href="http://linux.die.net/man/3/calloc">calloc(3)</a>, <a class="reference external" href="http://linux.die.net/man/3/realloc">realloc(3)</a>, <a class="reference external" href="http://linux.die.net/man/3/free">free(3)</a>, memory allocation
functions.</p>
<p>This function must be called before any other libuv function is called or
after all resources have been freed and thus libuv doesn’t reference
any allocated memory chunk.</p>
<p>On success, it returns 0, if any of the function pointers is NULL it
returns UV_EINVAL.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">There is no protection against changing the allocator multiple
times. If the user changes it they are responsible for making
sure the allocator is changed while no memory was allocated with
the previous allocator, or that they are compatible.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_buf_init">
<a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t">uv_buf_t</a> <code class="descname">uv_buf_init</code><span class="sig-paren">(</span>char*<em>&nbsp;base</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_buf_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for <a class="reference internal" href="#c.uv_buf_t" title="uv_buf_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_buf_t</span></code></a>.</p>
<p>Due to platform differences the user cannot rely on the ordering of the
<cite>base</cite> and <cite>len</cite> members of the uv_buf_t struct. The user is responsible for
freeing <cite>base</cite> after the uv_buf_t is done. Return struct passed by value.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_setup_args">
char** <code class="descname">uv_setup_args</code><span class="sig-paren">(</span>int<em>&nbsp;argc</em>, char**<em>&nbsp;argv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_setup_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the program arguments. Required for getting / setting the process title.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_get_process_title">
int <code class="descname">uv_get_process_title</code><span class="sig-paren">(</span>char*<em>&nbsp;buffer</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_get_process_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the title of the current process. You <em>must</em> call <cite>uv_setup_args</cite>
before calling this function. If <cite>buffer</cite> is <cite>NULL</cite> or <cite>size</cite> is zero,
<cite>UV_EINVAL</cite> is returned. If <cite>size</cite> cannot accommodate the process title and
terminating <cite>NULL</cite> character, the function returns <cite>UV_ENOBUFS</cite>.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.18.1: </span>now thread-safe on all supported platforms.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_set_process_title">
int <code class="descname">uv_set_process_title</code><span class="sig-paren">(</span>const char*<em>&nbsp;title</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_set_process_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the current process title. You <em>must</em> call <cite>uv_setup_args</cite> before
calling this function. On platforms with a fixed size buffer for the process
title the contents of <cite>title</cite> will be copied to the buffer and truncated if
larger than the available space. Other platforms will return <cite>UV_ENOMEM</cite> if
they cannot allocate enough space to duplicate the contents of <cite>title</cite>.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.18.1: </span>now thread-safe on all supported platforms.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_resident_set_memory">
int <code class="descname">uv_resident_set_memory</code><span class="sig-paren">(</span>size_t*<em>&nbsp;rss</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_resident_set_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the resident set size (RSS) for the current process.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_uptime">
int <code class="descname">uv_uptime</code><span class="sig-paren">(</span>double*<em>&nbsp;uptime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_uptime" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current system uptime.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_getrusage">
int <code class="descname">uv_getrusage</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_rusage_t" title="uv_rusage_t">uv_rusage_t</a>*<em>&nbsp;rusage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_getrusage" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the resource usage measures for the current process.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Windows not all fields are set, the unsupported fields are filled with zeroes.
See <a class="reference internal" href="#c.uv_rusage_t" title="uv_rusage_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_rusage_t</span></code></a> for more details.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_getpid">
<a class="reference internal" href="index.html#c.uv_pid_t" title="uv_pid_t">uv_pid_t</a> <code class="descname">uv_os_getpid</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_getpid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current process ID.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.18.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_getppid">
<a class="reference internal" href="index.html#c.uv_pid_t" title="uv_pid_t">uv_pid_t</a> <code class="descname">uv_os_getppid</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_getppid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the parent process ID.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.16.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_cpu_info">
int <code class="descname">uv_cpu_info</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cpu_info_t" title="uv_cpu_info_t">uv_cpu_info_t</a>**<em>&nbsp;cpu_infos</em>, int*<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cpu_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets information about the CPUs on the system. The <cite>cpu_infos</cite> array will
have <cite>count</cite> elements and needs to be freed with <a class="reference internal" href="#c.uv_free_cpu_info" title="uv_free_cpu_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_free_cpu_info()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_free_cpu_info">
void <code class="descname">uv_free_cpu_info</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_cpu_info_t" title="uv_cpu_info_t">uv_cpu_info_t</a>*<em>&nbsp;cpu_infos</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_free_cpu_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees the <cite>cpu_infos</cite> array previously allocated with <a class="reference internal" href="#c.uv_cpu_info" title="uv_cpu_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_cpu_info()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_interface_addresses">
int <code class="descname">uv_interface_addresses</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_interface_address_t" title="uv_interface_address_t">uv_interface_address_t</a>**<em>&nbsp;addresses</em>, int*<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_interface_addresses" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets address information about the network interfaces on the system. An
array of <cite>count</cite> elements is allocated and returned in <cite>addresses</cite>. It must
be freed by the user, calling <a class="reference internal" href="#c.uv_free_interface_addresses" title="uv_free_interface_addresses"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_free_interface_addresses()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_free_interface_addresses">
void <code class="descname">uv_free_interface_addresses</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_interface_address_t" title="uv_interface_address_t">uv_interface_address_t</a>*<em>&nbsp;addresses</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_free_interface_addresses" title="Permalink to this definition">¶</a></dt>
<dd><p>Free an array of <a class="reference internal" href="#c.uv_interface_address_t" title="uv_interface_address_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_interface_address_t</span></code></a> which was returned by
<a class="reference internal" href="#c.uv_interface_addresses" title="uv_interface_addresses"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_interface_addresses()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_loadavg">
void <code class="descname">uv_loadavg</code><span class="sig-paren">(</span>double<em>&nbsp;avg[3]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_loadavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the load average. See: <a class="reference external" href="http://en.wikipedia.org/wiki/Load_(computing)">http://en.wikipedia.org/wiki/Load_(computing)</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Returns [0,0,0] on Windows (i.e., it’s not implemented).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_ip4_addr">
int <code class="descname">uv_ip4_addr</code><span class="sig-paren">(</span>const char*<em>&nbsp;ip</em>, int<em>&nbsp;port</em>, struct sockaddr_in*<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_ip4_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string containing an IPv4 addresses to a binary structure.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_ip6_addr">
int <code class="descname">uv_ip6_addr</code><span class="sig-paren">(</span>const char*<em>&nbsp;ip</em>, int<em>&nbsp;port</em>, struct sockaddr_in6*<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_ip6_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string containing an IPv6 addresses to a binary structure.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_ip4_name">
int <code class="descname">uv_ip4_name</code><span class="sig-paren">(</span>const struct sockaddr_in*<em>&nbsp;src</em>, char*<em>&nbsp;dst</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_ip4_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a binary structure containing an IPv4 address to a string.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_ip6_name">
int <code class="descname">uv_ip6_name</code><span class="sig-paren">(</span>const struct sockaddr_in6*<em>&nbsp;src</em>, char*<em>&nbsp;dst</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_ip6_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a binary structure containing an IPv6 address to a string.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_inet_ntop">
int <code class="descname">uv_inet_ntop</code><span class="sig-paren">(</span>int<em>&nbsp;af</em>, const void*<em>&nbsp;src</em>, char*<em>&nbsp;dst</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_inet_ntop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.uv_inet_pton">
int <code class="descname">uv_inet_pton</code><span class="sig-paren">(</span>int<em>&nbsp;af</em>, const char*<em>&nbsp;src</em>, void*<em>&nbsp;dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_inet_pton" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross-platform IPv6-capable implementation of <a class="reference external" href="http://linux.die.net/man/3/inet_ntop">inet_ntop(3)</a>
and <a class="reference external" href="http://linux.die.net/man/3/inet_pton">inet_pton(3)</a>. On success they return 0. In case of error
the target <cite>dst</cite> pointer is unmodified.</p>
</dd></dl>

<dl class="macro">
<dt id="c.UV_IF_NAMESIZE">
<code class="descname">UV_IF_NAMESIZE</code><a class="headerlink" href="#c.UV_IF_NAMESIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum IPv6 interface identifier name length.  Defined as
<cite>IFNAMSIZ</cite> on Unix and <cite>IF_NAMESIZE</cite> on Linux and Windows.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.16.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_if_indextoname">
int <code class="descname">uv_if_indextoname</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;ifindex</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_if_indextoname" title="Permalink to this definition">¶</a></dt>
<dd><p>IPv6-capable implementation of <a class="reference external" href="http://linux.die.net/man/3/if_indextoname">if_indextoname(3)</a>. When called,
<cite>*size</cite> indicates the length of the <cite>buffer</cite>, which is used to store the
result.
On success, zero is returned, <cite>buffer</cite> contains the interface name, and
<cite>*size</cite> represents the string length of the <cite>buffer</cite>, excluding the NUL
terminator byte from <cite>*size</cite>. On error, a negative result is
returned. If <cite>buffer</cite> is not large enough to hold the result,
<cite>UV_ENOBUFS</cite> is returned, and <cite>*size</cite> represents the necessary size in
bytes, including the NUL terminator byte into the <cite>*size</cite>.</p>
<p>On Unix, the returned interface name can be used directly as an
interface identifier in scoped IPv6 addresses, e.g.
<cite>fe80::abc:def1:2345%en0</cite>.</p>
<p>On Windows, the returned interface cannot be used as an interface
identifier, as Windows uses numerical interface identifiers, e.g.
<cite>fe80::abc:def1:2345%5</cite>.</p>
<p>To get an interface identifier in a cross-platform compatible way,
use <cite>uv_if_indextoiid()</cite>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="n">ifname</span><span class="p">[</span><span class="n">UV_IF_NAMESIZE</span><span class="p">];</span>
<span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">ifname</span><span class="p">);</span>
<span class="n">uv_if_indextoname</span><span class="p">(</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_scope_id</span><span class="p">,</span> <span class="n">ifname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.16.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_if_indextoiid">
int <code class="descname">uv_if_indextoiid</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;ifindex</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_if_indextoiid" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves a network interface identifier suitable for use in an IPv6 scoped
address. On Windows, returns the numeric <cite>ifindex</cite> as a string. On all other
platforms, <cite>uv_if_indextoname()</cite> is called. The result is written to
<cite>buffer</cite>, with <cite>*size</cite> indicating the length of <cite>buffer</cite>. If <cite>buffer</cite> is not
large enough to hold the result, then <cite>UV_ENOBUFS</cite> is returned, and <cite>*size</cite>
represents the size, including the NUL byte, required to hold the
result.</p>
<p>See <cite>uv_if_indextoname</cite> for further details.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.16.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_exepath">
int <code class="descname">uv_exepath</code><span class="sig-paren">(</span>char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_exepath" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the executable path.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_cwd">
int <code class="descname">uv_cwd</code><span class="sig-paren">(</span>char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_cwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current working directory, and stores it in <cite>buffer</cite>. If the
current working directory is too large to fit in <cite>buffer</cite>, this function
returns <cite>UV_ENOBUFS</cite>, and sets <cite>size</cite> to the required length, including the
null terminator.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.1.0: </span>On Unix the path no longer ends in a slash.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9.0: </span>the returned length includes the terminating null
byte on <cite>UV_ENOBUFS</cite>, and the buffer is null terminated
on success.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_chdir">
int <code class="descname">uv_chdir</code><span class="sig-paren">(</span>const char*<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_chdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the current working directory.</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_homedir">
int <code class="descname">uv_os_homedir</code><span class="sig-paren">(</span>char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_homedir" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current user’s home directory. On Windows, <cite>uv_os_homedir()</cite> first
checks the <cite>USERPROFILE</cite> environment variable using
<cite>GetEnvironmentVariableW()</cite>. If <cite>USERPROFILE</cite> is not set,
<cite>GetUserProfileDirectoryW()</cite> is called. On all other operating systems,
<cite>uv_os_homedir()</cite> first checks the <cite>HOME</cite> environment variable using
<a class="reference external" href="http://linux.die.net/man/3/getenv">getenv(3)</a>. If <cite>HOME</cite> is not set, <a class="reference external" href="http://linux.die.net/man/3/getpwuid_r">getpwuid_r(3)</a> is called. The
user’s home directory is stored in <cite>buffer</cite>. When <cite>uv_os_homedir()</cite> is
called, <cite>size</cite> indicates the maximum size of <cite>buffer</cite>. On success <cite>size</cite> is set
to the string length of <cite>buffer</cite>. On <cite>UV_ENOBUFS</cite> failure <cite>size</cite> is set to the
required length for <cite>buffer</cite>, including the null byte.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><cite>uv_os_homedir()</cite> is not thread safe.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_tmpdir">
int <code class="descname">uv_os_tmpdir</code><span class="sig-paren">(</span>char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_tmpdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the temp directory. On Windows, <cite>uv_os_tmpdir()</cite> uses <cite>GetTempPathW()</cite>.
On all other operating systems, <cite>uv_os_tmpdir()</cite> uses the first environment
variable found in the ordered list <cite>TMPDIR</cite>, <cite>TMP</cite>, <cite>TEMP</cite>, and <cite>TEMPDIR</cite>.
If none of these are found, the path <cite>“/tmp”</cite> is used, or, on Android,
<cite>“/data/local/tmp”</cite> is used. The temp directory is stored in <cite>buffer</cite>. When
<cite>uv_os_tmpdir()</cite> is called, <cite>size</cite> indicates the maximum size of <cite>buffer</cite>.
On success <cite>size</cite> is set to the string length of <cite>buffer</cite> (which does not
include the terminating null). On <cite>UV_ENOBUFS</cite> failure <cite>size</cite> is set to the
required length for <cite>buffer</cite>, including the null byte.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><cite>uv_os_tmpdir()</cite> is not thread safe.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_get_passwd">
int <code class="descname">uv_os_get_passwd</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_passwd_t" title="uv_passwd_t">uv_passwd_t</a>*<em>&nbsp;pwd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_get_passwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a subset of the password file entry for the current effective uid (not
the real uid). The populated data includes the username, euid, gid, shell,
and home directory. On non-Windows systems, all data comes from
<a class="reference external" href="http://linux.die.net/man/3/getpwuid_r">getpwuid_r(3)</a>. On Windows, uid and gid are set to -1 and have no
meaning, and shell is <cite>NULL</cite>. After successfully calling this function, the
memory allocated to <cite>pwd</cite> needs to be freed with
<a class="reference internal" href="#c.uv_os_free_passwd" title="uv_os_free_passwd"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_os_free_passwd()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_free_passwd">
void <code class="descname">uv_os_free_passwd</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_passwd_t" title="uv_passwd_t">uv_passwd_t</a>*<em>&nbsp;pwd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_free_passwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees the <cite>pwd</cite> memory previously allocated with <a class="reference internal" href="#c.uv_os_get_passwd" title="uv_os_get_passwd"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_os_get_passwd()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_get_total_memory">
uint64_t <code class="descname">uv_get_total_memory</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_get_total_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets memory information (in bytes).</p>
</dd></dl>

<dl class="function">
<dt id="c.uv_hrtime">
uint64_t <code class="descname">uv_hrtime</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.uv_hrtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current high-resolution real time. This is expressed in
nanoseconds. It is relative to an arbitrary time in the past. It is not
related to the time of day and therefore not subject to clock drift. The
primary use is for measuring performance between intervals.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Not every platform can support nanosecond resolution; however, this value will always
be in nanoseconds.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_print_all_handles">
void <code class="descname">uv_print_all_handles</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, FILE*<em>&nbsp;stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_print_all_handles" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints all handles associated with the given <cite>loop</cite> to the given <cite>stream</cite>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_print_all_handles</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="n">stderr</span><span class="p">);</span>
<span class="o">/*</span>
<span class="p">[</span><span class="o">--</span><span class="n">I</span><span class="p">]</span> <span class="n">signal</span>   <span class="mh">0x1a25ea8</span>
<span class="p">[</span><span class="o">-</span><span class="n">AI</span><span class="p">]</span> <span class="k">async</span>    <span class="mh">0x1a25cf0</span>
<span class="p">[</span><span class="n">R</span><span class="o">--</span><span class="p">]</span> <span class="n">idle</span>     <span class="mh">0x1a7a8c8</span>
<span class="o">*/</span>
</pre></div>
</div>
<p>The format is <cite>[flags] handle-type handle-address</cite>. For <cite>flags</cite>:</p>
<ul class="simple">
<li><cite>R</cite> is printed for a handle that is referenced</li>
<li><cite>A</cite> is printed for a handle that is active</li>
<li><cite>I</cite> is printed for a handle that is internal</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is meant for ad hoc debugging, there is no API/ABI
stability guarantees.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_print_active_handles">
void <code class="descname">uv_print_active_handles</code><span class="sig-paren">(</span><a class="reference internal" href="index.html#c.uv_loop_t" title="uv_loop_t">uv_loop_t</a>*<em>&nbsp;loop</em>, FILE*<em>&nbsp;stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_print_active_handles" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the same as <a class="reference internal" href="#c.uv_print_all_handles" title="uv_print_all_handles"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_print_all_handles()</span></code></a> except only active handles
are printed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is meant for ad hoc debugging, there is no API/ABI
stability guarantees.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_getenv">
int <code class="descname">uv_os_getenv</code><span class="sig-paren">(</span>const char*<em>&nbsp;name</em>, char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_getenv" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the environment variable specified by <cite>name</cite>, copies its value
into <cite>buffer</cite>, and sets <cite>size</cite> to the string length of the value. When
calling this function, <cite>size</cite> must be set to the amount of storage available
in <cite>buffer</cite>, including the null terminator. If the environment variable
exceeds the storage available in <cite>buffer</cite>, <cite>UV_ENOBUFS</cite> is returned, and
<cite>size</cite> is set to the amount of storage required to hold the value. If no
matching environment variable exists, <cite>UV_ENOENT</cite> is returned.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is not thread safe.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_setenv">
int <code class="descname">uv_os_setenv</code><span class="sig-paren">(</span>const char*<em>&nbsp;name</em>, const char*<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_setenv" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates or updates the environment variable specified by <cite>name</cite> with
<cite>value</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is not thread safe.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_unsetenv">
int <code class="descname">uv_os_unsetenv</code><span class="sig-paren">(</span>const char*<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_unsetenv" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes the environment variable specified by <cite>name</cite>. If no such environment
variable exists, this function returns successfully.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is not thread safe.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.uv_os_gethostname">
int <code class="descname">uv_os_gethostname</code><span class="sig-paren">(</span>char*<em>&nbsp;buffer</em>, size_t*<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uv_os_gethostname" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hostname as a null-terminated string in <cite>buffer</cite>, and sets
<cite>size</cite> to the string length of the hostname. When calling this function,
<cite>size</cite> must be set to the amount of storage available in <cite>buffer</cite>, including
the null terminator. If the hostname exceeds the storage available in
<cite>buffer</cite>, <cite>UV_ENOBUFS</cite> is returned, and <cite>size</cite> is set to the amount of
storage required to hold the value.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd></dl>

</div>
</div>
</div>
</div>
<span id="document-guide"></span><div class="section" id="user-guide">
<span id="guide"></span><h3>User guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The contents of this guide have been recently incorporated into the libuv documentation
and it hasn’t gone through thorough review yet. If you spot a mistake please file an
issue, or better yet, open a pull request!</p>
</div>
<div class="toctree-wrapper compound">
<span id="document-guide/introduction"></span><div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>This ‘book’ is a small set of tutorials about using <a class="reference external" href="https://github.com/libuv/libuv">libuv</a> as
a high performance evented I/O library which offers the same API on Windows and Unix.</p>
<p>It is meant to cover the main areas of libuv, but is not a comprehensive
reference discussing every function and data structure. The <a class="reference external" href="http://docs.libuv.org/en/v1.x/">official libuv
documentation</a> may be consulted for full details.</p>
<p>This book is still a work in progress, so sections may be incomplete, but
I hope you will enjoy it as it grows.</p>
<div class="section" id="who-this-book-is-for">
<h5>Who this book is for<a class="headerlink" href="#who-this-book-is-for" title="Permalink to this headline">¶</a></h5>
<p>If you are reading this book, you are either:</p>
<ol class="arabic simple">
<li>a systems programmer, creating low-level programs such as daemons or network
services and clients. You have found that the event loop approach is well
suited for your application and decided to use libuv.</li>
<li>a node.js module writer, who wants to wrap platform APIs
written in C or C++ with a set of (a)synchronous APIs that are exposed to
JavaScript. You will use libuv purely in the context of node.js. For
this you will require some other resources as the book does not cover parts
specific to v8/node.js.</li>
</ol>
<p>This book assumes that you are comfortable with the C programming language.</p>
</div>
<div class="section" id="background">
<h5>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference external" href="http://www.nodejs.org">node.js</a> project began in 2009 as a JavaScript environment decoupled
from the browser. Using Google’s <a class="reference external" href="http://code.google.com/p/v8/">V8</a> and Marc Lehmann’s <a class="reference external" href="http://software.schmorp.de/pkg/libev.html">libev</a>, node.js
combined a model of I/O – evented – with a language that was well suited to
the style of programming; due to the way it had been shaped by browsers. As
node.js grew in popularity, it was important to make it work on Windows, but
libev ran only on Unix. The Windows equivalent of kernel event notification
mechanisms like kqueue or (e)poll is IOCP. libuv was an abstraction around libev
or IOCP depending on the platform, providing users an API based on libev.
In the node-v0.9.0 version of libuv <a class="reference external" href="https://github.com/joyent/libuv/issues/485">libev was removed</a>.</p>
<p>Since then libuv has continued to mature and become a high quality standalone
library for system programming. Users outside of node.js include Mozilla’s
<a class="reference external" href="http://rust-lang.org">Rust</a> programming language, and a <a class="reference external" href="https://github.com/libuv/libuv/wiki/Projects-that-use-libuv">variety</a> of language bindings.</p>
<p>This book and the code is based on libuv version <a class="reference external" href="https://github.com/libuv/libuv/tags">v1.3.0</a>.</p>
</div>
<div class="section" id="code">
<h5>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h5>
<p>All the code from this book is included as part of the source of the book on
Github. <a class="reference external" href="https://github.com/nikhilm/uvbook">Clone</a>/<a class="reference external" href="https://github.com/nikhilm/uvbook/downloads">Download</a> the book, then build libuv:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">libuv</span>
<span class="o">./</span><span class="n">autogen</span><span class="o">.</span><span class="n">sh</span>
<span class="o">./</span><span class="n">configure</span>
<span class="n">make</span>
</pre></div>
</div>
<p>There is no need to <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code>. To build the examples run <code class="docutils literal notranslate"><span class="pre">make</span></code> in the
<code class="docutils literal notranslate"><span class="pre">code/</span></code> directory.</p>
</div>
</div>
<span id="document-guide/basics"></span><div class="section" id="basics-of-libuv">
<h4>Basics of libuv<a class="headerlink" href="#basics-of-libuv" title="Permalink to this headline">¶</a></h4>
<p>libuv enforces an <strong>asynchronous</strong>, <strong>event-driven</strong> style of programming.  Its
core job is to provide an event loop and callback based notifications of I/O
and other activities.  libuv offers core utilities like timers, non-blocking
networking support, asynchronous file system access, child processes and more.</p>
<div class="section" id="event-loops">
<h5>Event loops<a class="headerlink" href="#event-loops" title="Permalink to this headline">¶</a></h5>
<p>In event-driven programming, an application expresses interest in certain events
and respond to them when they occur. The responsibility of gathering events
from the operating system or monitoring other sources of events is handled by
libuv, and the user can register callbacks to be invoked when an event occurs.
The event-loop usually keeps running <em>forever</em>. In pseudocode:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">still</span> <span class="n">events</span> <span class="n">to</span> <span class="n">process</span><span class="p">:</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">get</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">event</span>
    <span class="k">if</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">callback</span> <span class="n">associated</span> <span class="k">with</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">call</span> <span class="n">the</span> <span class="n">callback</span>
</pre></div>
</div>
<p>Some examples of events are:</p>
<ul class="simple">
<li>File is ready for writing</li>
<li>A socket has data ready to be read</li>
<li>A timer has timed out</li>
</ul>
<p>This event loop is encapsulated by <code class="docutils literal notranslate"><span class="pre">uv_run()</span></code> – the end-all function when using
libuv.</p>
<p>The most common activity of systems programs is to deal with input and output,
rather than a lot of number-crunching. The problem with using conventional
input/output functions (<code class="docutils literal notranslate"><span class="pre">read</span></code>, <code class="docutils literal notranslate"><span class="pre">fprintf</span></code>, etc.) is that they are
<strong>blocking</strong>. The actual write to a hard disk or reading from a network, takes
a disproportionately long time compared to the speed of the processor. The
functions don’t return until the task is done, so that your program is doing
nothing. For programs which require high performance this is a major roadblock
as other activities and other I/O operations are kept waiting.</p>
<p>One of the standard solutions is to use threads. Each blocking I/O operation is
started in a separate thread (or in a thread pool). When the blocking function
gets invoked in the thread, the processor can schedule another thread to run,
which actually needs the CPU.</p>
<p>The approach followed by libuv uses another style, which is the <strong>asynchronous,
non-blocking</strong> style. Most modern operating systems provide event notification
subsystems. For example, a normal <code class="docutils literal notranslate"><span class="pre">read</span></code> call on a socket would block until
the sender actually sent something. Instead, the application can request the
operating system to watch the socket and put an event notification in the
queue. The application can inspect the events at its convenience (perhaps doing
some number crunching before to use the processor to the maximum) and grab the
data. It is <strong>asynchronous</strong> because the application expressed interest at one
point, then used the data at another point (in time and space). It is
<strong>non-blocking</strong> because the application process was free to do other tasks.
This fits in well with libuv’s event-loop approach, since the operating system
events can be treated as just another libuv event. The non-blocking ensures
that other events can continue to be handled as fast as they come in <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">How the I/O is run in the background is not of our concern, but due to the
way our computer hardware works, with the thread as the basic unit of the
processor, libuv and OSes will usually run background/worker threads and/or
polling to perform tasks in a non-blocking manner.</p>
</div>
<p>Bert Belder, one of the libuv core developers has a small video explaining the
architecture of libuv and its background. If you have no prior experience with
either libuv or libev, it is a quick, useful watch.</p>
<p>libuv’s event loop is explained in more detail in the <a class="reference external" href="http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop">documentation</a>.</p>
<iframe width="560" height="315"
src="https://www.youtube-nocookie.com/embed/nGn60vDSxQ4" frameborder="0"
allowfullscreen></iframe></div>
<div class="section" id="hello-world">
<h5>Hello World<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h5>
<p>With the basics out of the way, lets write our first libuv program. It does
nothing, except start a loop which will exit immediately.</p>
<p class="rubric">helloworld/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="p">));</span>
    <span class="n">uv_loop_init</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Now quitting.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>

    <span class="n">uv_loop_close</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This program quits immediately because it has no events to process. A libuv
event loop has to be told to watch out for events using the various API
functions.</p>
<p>Starting with libuv v1.0, users should allocate the memory for the loops before
initializing it with <code class="docutils literal notranslate"><span class="pre">uv_loop_init(uv_loop_t</span> <span class="pre">*)</span></code>. This allows you to plug in
custom memory management. Remember to de-initialize the loop using
<code class="docutils literal notranslate"><span class="pre">uv_loop_close(uv_loop_t</span> <span class="pre">*)</span></code> and then delete the storage. The examples never
close loops since the program quits after the loop ends and the system will
reclaim memory. Production grade projects, especially long running systems
programs, should take care to release correctly.</p>
<div class="section" id="default-loop">
<h6>Default loop<a class="headerlink" href="#default-loop" title="Permalink to this headline">¶</a></h6>
<p>A default loop is provided by libuv and can be accessed using
<code class="docutils literal notranslate"><span class="pre">uv_default_loop()</span></code>. You should use this loop if you only want a single
loop.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">node.js uses the default loop as its main loop. If you are writing bindings
you should be aware of this.</p>
</div>
</div>
</div>
<div class="section" id="error-handling">
<span id="libuv-error-handling"></span><h5>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h5>
<p>Initialization functions or synchronous functions which may fail return a negative number on error. Async functions that may fail will pass a status parameter to their callbacks. The error messages are defined as <code class="docutils literal notranslate"><span class="pre">UV_E*</span></code> <a class="reference external" href="http://docs.libuv.org/en/v1.x/errors.html#error-constants">constants</a>.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">uv_strerror(int)</span></code> and <code class="docutils literal notranslate"><span class="pre">uv_err_name(int)</span></code> functions
to get a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> describing the error or the error name respectively.</p>
<p>I/O read callbacks (such as for files and sockets) are passed a parameter <code class="docutils literal notranslate"><span class="pre">nread</span></code>. If <code class="docutils literal notranslate"><span class="pre">nread</span></code> is less than 0, there was an error (UV_EOF is the end of file error, which you may want to handle differently).</p>
</div>
<div class="section" id="handles-and-requests">
<h5>Handles and Requests<a class="headerlink" href="#handles-and-requests" title="Permalink to this headline">¶</a></h5>
<p>libuv works by the user expressing interest in particular events. This is
usually done by creating a <strong>handle</strong> to an I/O device, timer or process.
Handles are opaque structs named as <code class="docutils literal notranslate"><span class="pre">uv_TYPE_t</span></code> where type signifies what the
handle is used for.</p>
<p class="rubric">libuv watchers</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">UV_REQ_TYPE_PRIVATE</span>
  <span class="n">UV_REQ_TYPE_MAX</span>
<span class="p">}</span> <span class="n">uv_req_type</span><span class="p">;</span>


<span class="o">/*</span> <span class="n">Handle</span> <span class="n">types</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_loop_s</span> <span class="n">uv_loop_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_handle_s</span> <span class="n">uv_handle_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_stream_s</span> <span class="n">uv_stream_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_tcp_s</span> <span class="n">uv_tcp_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_udp_s</span> <span class="n">uv_udp_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_pipe_s</span> <span class="n">uv_pipe_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_tty_s</span> <span class="n">uv_tty_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_poll_s</span> <span class="n">uv_poll_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_timer_s</span> <span class="n">uv_timer_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_prepare_s</span> <span class="n">uv_prepare_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_check_s</span> <span class="n">uv_check_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_idle_s</span> <span class="n">uv_idle_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_async_s</span> <span class="n">uv_async_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_process_s</span> <span class="n">uv_process_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_fs_event_s</span> <span class="n">uv_fs_event_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_fs_poll_s</span> <span class="n">uv_fs_poll_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_signal_s</span> <span class="n">uv_signal_t</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">Request</span> <span class="n">types</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_req_s</span> <span class="n">uv_req_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_getaddrinfo_s</span> <span class="n">uv_getaddrinfo_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_getnameinfo_s</span> <span class="n">uv_getnameinfo_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_shutdown_s</span> <span class="n">uv_shutdown_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_write_s</span> <span class="n">uv_write_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_connect_s</span> <span class="n">uv_connect_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_udp_send_s</span> <span class="n">uv_udp_send_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_fs_s</span> <span class="n">uv_fs_t</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">uv_work_s</span> <span class="n">uv_work_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Handles represent long-lived objects. Async operations on such handles are
identified using <strong>requests</strong>. A request is short-lived (usually used across
only one callback) and usually indicates one I/O operation on a handle.
Requests are used to preserve context between the initiation and the callback
of individual actions. For example, an UDP socket is represented by
a <code class="docutils literal notranslate"><span class="pre">uv_udp_t</span></code>, while individual writes to the socket use a <code class="docutils literal notranslate"><span class="pre">uv_udp_send_t</span></code>
structure that is passed to the callback after the write is done.</p>
<p>Handles are setup by a corresponding:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_TYPE_init</span><span class="p">(</span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">uv_TYPE_t</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>function.</p>
<p>Callbacks are functions which are called by libuv whenever an event the watcher
is interested in has taken place. Application specific logic will usually be
implemented in the callback. For example, an IO watcher’s callback will receive
the data read from a file, a timer callback will be triggered on timeout and so
on.</p>
<div class="section" id="idling">
<h6>Idling<a class="headerlink" href="#idling" title="Permalink to this headline">¶</a></h6>
<p>Here is an example of using an idle handle. The callback is called once on
every turn of the event loop. A use case for idle handles is discussed in
<a class="reference internal" href="index.html#document-guide/utilities"><span class="doc">Utilities</span></a>. Let us use an idle watcher to look at the watcher life cycle
and see how <code class="docutils literal notranslate"><span class="pre">uv_run()</span></code> will now block because a watcher is present. The idle
watcher is stopped when the count is reached and <code class="docutils literal notranslate"><span class="pre">uv_run()</span></code> exits since no
event watchers are active.</p>
<p class="rubric">idle-basic/main.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="n">int64_t</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="hll"><span class="n">void</span> <span class="n">wait_for_a_while</span><span class="p">(</span><span class="n">uv_idle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
</span>    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&gt;=</span> <span class="mf">10e6</span><span class="p">)</span>
<span class="hll">        <span class="n">uv_idle_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
<span class="hll">    <span class="n">uv_idle_t</span> <span class="n">idler</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="n">uv_idle_init</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">idler</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_idle_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idler</span><span class="p">,</span> <span class="n">wait_for_a_while</span><span class="p">);</span>
</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Idling...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">uv_run</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>

    <span class="n">uv_loop_close</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="storing-context">
<h6>Storing context<a class="headerlink" href="#storing-context" title="Permalink to this headline">¶</a></h6>
<p>In callback based programming style you’ll often want to pass some ‘context’ –
application specific information – between the call site and the callback. All
handles and requests have a <code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">data</span></code> member which you can set to the
context and cast back in the callback. This is a common pattern used throughout
the C library ecosystem. In addition <code class="docutils literal notranslate"><span class="pre">uv_loop_t</span></code> also has a similar data
member.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Depending on the capacity of the hardware of course.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<span id="document-guide/filesystem"></span><div class="section" id="filesystem">
<h4>Filesystem<a class="headerlink" href="#filesystem" title="Permalink to this headline">¶</a></h4>
<p>Simple filesystem read/write is achieved using the <code class="docutils literal notranslate"><span class="pre">uv_fs_*</span></code> functions and the
<code class="docutils literal notranslate"><span class="pre">uv_fs_t</span></code> struct.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The libuv filesystem operations are different from <a class="reference internal" href="index.html#document-guide/networking"><span class="doc">socket operations</span></a>. Socket operations use the non-blocking operations provided
by the operating system. Filesystem operations use blocking functions
internally, but invoke these functions in a <a class="reference external" href="http://docs.libuv.org/en/v1.x/threadpool.html#thread-pool-work-scheduling">thread pool</a> and notify
watchers registered with the event loop when application interaction is
required.</p>
</div>
<p>All filesystem functions have two forms - <em>synchronous</em> and <em>asynchronous</em>.</p>
<p>The <em>synchronous</em> forms automatically get called (and <strong>block</strong>) if the
callback is null. The return value of functions is a <a class="reference internal" href="index.html#libuv-error-handling"><span class="std std-ref">libuv error code</span></a>. This is usually only useful for synchronous calls.
The <em>asynchronous</em> form is called when a callback is passed and the return
value is 0.</p>
<div class="section" id="reading-writing-files">
<h5>Reading/Writing files<a class="headerlink" href="#reading-writing-files" title="Permalink to this headline">¶</a></h5>
<p>A file descriptor is obtained using</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">uv_fs_open</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">flags</span></code> and <code class="docutils literal notranslate"><span class="pre">mode</span></code> are standard
<a class="reference external" href="http://man7.org/linux/man-pages/man2/open.2.html">Unix flags</a>.
libuv takes care of converting to the appropriate Windows flags.</p>
<p>File descriptors are closed using</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">uv_fs_close</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="n">uv_file</span> <span class="n">file</span><span class="p">,</span> <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">)</span>
</pre></div>
</div>
<p>Filesystem operation callbacks have the signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">);</span>
</pre></div>
</div>
<p>Let’s see a simple implementation of <code class="docutils literal notranslate"><span class="pre">cat</span></code>. We start with registering
a callback for when the file is opened:</p>
<p class="rubric">uvcat/main.c - opening a file</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">on_open</span><span class="p">(</span><span class="n">uv_fs_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">request</span> <span class="n">passed</span> <span class="n">to</span> <span class="n">the</span> <span class="n">callback</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">same</span> <span class="k">as</span> <span class="n">the</span> <span class="n">one</span> <span class="n">the</span> <span class="n">call</span> <span class="n">setup</span>
    <span class="o">//</span> <span class="n">function</span> <span class="n">was</span> <span class="n">passed</span><span class="o">.</span>
<span class="hll">    <span class="k">assert</span><span class="p">(</span><span class="n">req</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">open_req</span><span class="p">);</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">iov</span> <span class="o">=</span> <span class="n">uv_buf_init</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
</span><span class="hll">        <span class="n">uv_fs_read</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">read_req</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span>
</span>                   <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;error opening file: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">((</span><span class="nb">int</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">result</span></code> field of a <code class="docutils literal notranslate"><span class="pre">uv_fs_t</span></code> is the file descriptor in case of the
<code class="docutils literal notranslate"><span class="pre">uv_fs_open</span></code> callback. If the file is successfully opened, we start reading it.</p>
<p class="rubric">uvcat/main.c - read callback</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">on_read</span><span class="p">(</span><span class="n">uv_fs_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Read error: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uv_fs_t</span> <span class="n">close_req</span><span class="p">;</span>
        <span class="o">//</span> <span class="n">synchronous</span>
<span class="hll">        <span class="n">uv_fs_close</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">close_req</span><span class="p">,</span> <span class="n">open_req</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
</span>    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">iov</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
<span class="hll">        <span class="n">uv_fs_write</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">write_req</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_write</span><span class="p">);</span>
</span>    <span class="p">}</span>
<span class="p">}</span>

</pre></div>
</td></tr></table></div>
<p>In the case of a read call, you should pass an <em>initialized</em> buffer which will
be filled with data before the read callback is triggered. The <code class="docutils literal notranslate"><span class="pre">uv_fs_*</span></code>
operations map almost directly to certain POSIX functions, so EOF is indicated
in this case by <code class="docutils literal notranslate"><span class="pre">result</span></code> being 0. In the case of streams or pipes, the
<code class="docutils literal notranslate"><span class="pre">UV_EOF</span></code> constant would have been passed as a status instead.</p>
<p>Here you see a common pattern when writing asynchronous programs. The
<code class="docutils literal notranslate"><span class="pre">uv_fs_close()</span></code> call is performed synchronously. <em>Usually tasks which are
one-off, or are done as part of the startup or shutdown stage are performed
synchronously, since we are interested in fast I/O when the program is going
about its primary task and dealing with multiple I/O sources</em>. For solo tasks
the performance difference usually is negligible and may lead to simpler code.</p>
<p>Filesystem writing is similarly simple using <code class="docutils literal notranslate"><span class="pre">uv_fs_write()</span></code>.  <em>Your callback
will be triggered after the write is complete</em>.  In our case the callback
simply drives the next read. Thus read and write proceed in lockstep via
callbacks.</p>
<p class="rubric">uvcat/main.c - write callback</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">on_write</span><span class="p">(</span><span class="n">uv_fs_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Write error: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">((</span><span class="nb">int</span><span class="p">)</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">));</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">else</span> <span class="p">{</span>
</span>        <span class="n">uv_fs_read</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">read_req</span><span class="p">,</span> <span class="n">open_req</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Due to the way filesystems and disk drives are configured for performance,
a write that ‘succeeds’ may not be committed to disk yet.</p>
</div>
<p>We set the dominos rolling in <code class="docutils literal notranslate"><span class="pre">main()</span></code>:</p>
<p class="rubric">uvcat/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="n">uv_fs_open</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">open_req</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">on_open</span><span class="p">);</span>
</span>    <span class="n">uv_run</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>

    <span class="n">uv_fs_req_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">open_req</span><span class="p">);</span>
    <span class="n">uv_fs_req_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_req</span><span class="p">);</span>
    <span class="n">uv_fs_req_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">write_req</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">uv_fs_req_cleanup()</span></code> function must always be called on filesystem
requests to free internal memory allocations in libuv.</p>
</div>
</div>
<div class="section" id="filesystem-operations">
<h5>Filesystem operations<a class="headerlink" href="#filesystem-operations" title="Permalink to this headline">¶</a></h5>
<p>All the standard filesystem operations like <code class="docutils literal notranslate"><span class="pre">unlink</span></code>, <code class="docutils literal notranslate"><span class="pre">rmdir</span></code>, <code class="docutils literal notranslate"><span class="pre">stat</span></code> are
supported asynchronously and have intuitive argument order. They follow the
same patterns as the read/write/open calls, returning the result in the
<code class="docutils literal notranslate"><span class="pre">uv_fs_t.result</span></code> field. The full list:</p>
<p class="rubric">Filesystem operations</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_homedir</span><span class="p">(</span><span class="n">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">size</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_tmpdir</span><span class="p">(</span><span class="n">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">size</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_get_passwd</span><span class="p">(</span><span class="n">uv_passwd_t</span><span class="o">*</span> <span class="n">pwd</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">void</span> <span class="n">uv_os_free_passwd</span><span class="p">(</span><span class="n">uv_passwd_t</span><span class="o">*</span> <span class="n">pwd</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">uv_pid_t</span> <span class="n">uv_os_getpid</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">uv_pid_t</span> <span class="n">uv_os_getppid</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>

<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_cpu_info</span><span class="p">(</span><span class="n">uv_cpu_info_t</span><span class="o">**</span> <span class="n">cpu_infos</span><span class="p">,</span> <span class="nb">int</span><span class="o">*</span> <span class="n">count</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">void</span> <span class="n">uv_free_cpu_info</span><span class="p">(</span><span class="n">uv_cpu_info_t</span><span class="o">*</span> <span class="n">cpu_infos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">count</span><span class="p">);</span>

<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_interface_addresses</span><span class="p">(</span><span class="n">uv_interface_address_t</span><span class="o">**</span> <span class="n">addresses</span><span class="p">,</span>
                                     <span class="nb">int</span><span class="o">*</span> <span class="n">count</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">void</span> <span class="n">uv_free_interface_addresses</span><span class="p">(</span><span class="n">uv_interface_address_t</span><span class="o">*</span> <span class="n">addresses</span><span class="p">,</span>
                                           <span class="nb">int</span> <span class="n">count</span><span class="p">);</span>

<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_getenv</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">size</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_setenv</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">value</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_unsetenv</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>

<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_os_gethostname</span><span class="p">(</span><span class="n">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">size</span><span class="p">);</span>


<span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
  <span class="n">UV_FS_UNKNOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
  <span class="n">UV_FS_CUSTOM</span><span class="p">,</span>
  <span class="n">UV_FS_OPEN</span><span class="p">,</span>
  <span class="n">UV_FS_CLOSE</span><span class="p">,</span>
  <span class="n">UV_FS_READ</span><span class="p">,</span>
  <span class="n">UV_FS_WRITE</span><span class="p">,</span>
  <span class="n">UV_FS_SENDFILE</span><span class="p">,</span>
  <span class="n">UV_FS_STAT</span><span class="p">,</span>
  <span class="n">UV_FS_LSTAT</span><span class="p">,</span>
  <span class="n">UV_FS_FSTAT</span><span class="p">,</span>
  <span class="n">UV_FS_FTRUNCATE</span><span class="p">,</span>
  <span class="n">UV_FS_UTIME</span><span class="p">,</span>
  <span class="n">UV_FS_FUTIME</span><span class="p">,</span>
  <span class="n">UV_FS_ACCESS</span><span class="p">,</span>
  <span class="n">UV_FS_CHMOD</span><span class="p">,</span>
  <span class="n">UV_FS_FCHMOD</span><span class="p">,</span>
  <span class="n">UV_FS_FSYNC</span><span class="p">,</span>
  <span class="n">UV_FS_FDATASYNC</span><span class="p">,</span>
  <span class="n">UV_FS_UNLINK</span><span class="p">,</span>
  <span class="n">UV_FS_RMDIR</span><span class="p">,</span>
  <span class="n">UV_FS_MKDIR</span><span class="p">,</span>
  <span class="n">UV_FS_MKDTEMP</span><span class="p">,</span>
  <span class="n">UV_FS_RENAME</span><span class="p">,</span>
  <span class="n">UV_FS_SCANDIR</span><span class="p">,</span>
  <span class="n">UV_FS_LINK</span><span class="p">,</span>
  <span class="n">UV_FS_SYMLINK</span><span class="p">,</span>
  <span class="n">UV_FS_READLINK</span><span class="p">,</span>
  <span class="n">UV_FS_CHOWN</span><span class="p">,</span>
  <span class="n">UV_FS_FCHOWN</span><span class="p">,</span>
  <span class="n">UV_FS_REALPATH</span><span class="p">,</span>
  <span class="n">UV_FS_COPYFILE</span>
<span class="p">}</span> <span class="n">uv_fs_type</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">uv_fs_t</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">subclass</span> <span class="n">of</span> <span class="n">uv_req_t</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">struct</span> <span class="n">uv_fs_s</span> <span class="p">{</span>
  <span class="n">UV_REQ_FIELDS</span>
  <span class="n">uv_fs_type</span> <span class="n">fs_type</span><span class="p">;</span>
  <span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">;</span>
  <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">path</span><span class="p">;</span>
  <span class="n">uv_stat_t</span> <span class="n">statbuf</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">Stores</span> <span class="n">the</span> <span class="n">result</span> <span class="n">of</span> <span class="n">uv_fs_stat</span><span class="p">()</span> <span class="ow">and</span> <span class="n">uv_fs_fstat</span><span class="p">()</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">UV_FS_PRIVATE_FIELDS</span>
<span class="p">};</span>

<span class="n">UV_EXTERN</span> <span class="n">uv_fs_type</span> <span class="n">uv_fs_get_type</span><span class="p">(</span><span class="n">const</span> <span class="n">uv_fs_t</span><span class="o">*</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">ssize_t</span> <span class="n">uv_fs_get_result</span><span class="p">(</span><span class="n">const</span> <span class="n">uv_fs_t</span><span class="o">*</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">void</span><span class="o">*</span> <span class="n">uv_fs_get_ptr</span><span class="p">(</span><span class="n">const</span> <span class="n">uv_fs_t</span><span class="o">*</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">uv_fs_get_path</span><span class="p">(</span><span class="n">const</span> <span class="n">uv_fs_t</span><span class="o">*</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">uv_stat_t</span><span class="o">*</span> <span class="n">uv_fs_get_statbuf</span><span class="p">(</span><span class="n">uv_fs_t</span><span class="o">*</span><span class="p">);</span>

<span class="n">UV_EXTERN</span> <span class="n">void</span> <span class="n">uv_fs_req_cleanup</span><span class="p">(</span><span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_fs_close</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                          <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span>
                          <span class="n">uv_file</span> <span class="n">file</span><span class="p">,</span>
                          <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_fs_open</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                         <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span>
                         <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span>
                         <span class="nb">int</span> <span class="n">flags</span><span class="p">,</span>
                         <span class="nb">int</span> <span class="n">mode</span><span class="p">,</span>
                         <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_fs_read</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                         <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span>
                         <span class="n">uv_file</span> <span class="n">file</span><span class="p">,</span>
                         <span class="n">const</span> <span class="n">uv_buf_t</span> <span class="n">bufs</span><span class="p">[],</span>
                         <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">nbufs</span><span class="p">,</span>
                         <span class="n">int64_t</span> <span class="n">offset</span><span class="p">,</span>
                         <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_fs_unlink</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                           <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span>
                           <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span>
                           <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_fs_write</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                          <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span>
                          <span class="n">uv_file</span> <span class="n">file</span><span class="p">,</span>
                          <span class="n">const</span> <span class="n">uv_buf_t</span> <span class="n">bufs</span><span class="p">[],</span>
                          <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">nbufs</span><span class="p">,</span>
                          <span class="n">int64_t</span> <span class="n">offset</span><span class="p">,</span>
                          <span class="n">uv_fs_cb</span> <span class="n">cb</span><span class="p">);</span>
<span class="o">/*</span>
 <span class="o">*</span> <span class="n">This</span> <span class="n">flag</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="k">with</span> <span class="n">uv_fs_copyfile</span><span class="p">()</span> <span class="n">to</span> <span class="k">return</span> <span class="n">an</span> <span class="n">error</span> <span class="k">if</span> <span class="n">the</span>
 <span class="o">*</span> <span class="n">destination</span> <span class="n">already</span> <span class="n">exists</span><span class="o">.</span>
 <span class="o">*/</span>
<span class="c1">#define UV_FS_COPYFILE_EXCL   0x0001</span>

<span class="o">/*</span>
 <span class="o">*</span> <span class="n">This</span> <span class="n">flag</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="k">with</span> <span class="n">uv_fs_copyfile</span><span class="p">()</span> <span class="n">to</span> <span class="n">attempt</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">reflink</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="buffers-and-streams">
<span id="id1"></span><h5>Buffers and Streams<a class="headerlink" href="#buffers-and-streams" title="Permalink to this headline">¶</a></h5>
<p>The basic I/O handle in libuv is the stream (<code class="docutils literal notranslate"><span class="pre">uv_stream_t</span></code>). TCP sockets, UDP
sockets, and pipes for file I/O and IPC are all treated as stream subclasses.</p>
<p>Streams are initialized using custom functions for each subclass, then operated
upon using</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">uv_read_start</span><span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">,</span> <span class="n">uv_alloc_cb</span> <span class="n">alloc_cb</span><span class="p">,</span> <span class="n">uv_read_cb</span> <span class="n">read_cb</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">uv_read_stop</span><span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">uv_write</span><span class="p">(</span><span class="n">uv_write_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">uv_buf_t</span> <span class="n">bufs</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbufs</span><span class="p">,</span> <span class="n">uv_write_cb</span> <span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<p>The stream based functions are simpler to use than the filesystem ones and
libuv will automatically keep reading from a stream when <code class="docutils literal notranslate"><span class="pre">uv_read_start()</span></code> is
called once, until <code class="docutils literal notranslate"><span class="pre">uv_read_stop()</span></code> is called.</p>
<p>The discrete unit of data is the buffer – <code class="docutils literal notranslate"><span class="pre">uv_buf_t</span></code>. This is simply
a collection of a pointer to bytes (<code class="docutils literal notranslate"><span class="pre">uv_buf_t.base</span></code>) and the length
(<code class="docutils literal notranslate"><span class="pre">uv_buf_t.len</span></code>). The <code class="docutils literal notranslate"><span class="pre">uv_buf_t</span></code> is lightweight and passed around by value.
What does require management is the actual bytes, which have to be allocated
and freed by the application.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">THIS PROGRAM DOES NOT ALWAYS WORK, NEED SOMETHING BETTER**</p>
</div>
<p>To demonstrate streams we will need to use <code class="docutils literal notranslate"><span class="pre">uv_pipe_t</span></code>. This allows streaming
local files <a class="footnote-reference" href="#id4" id="id2">[2]</a>. Here is a simple tee utility using libuv.  Doing all operations
asynchronously shows the power of evented I/O. The two writes won’t block each
other, but we have to be careful to copy over the buffer data to ensure we don’t
free a buffer until it has been written.</p>
<p>The program is to be executed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">uvtee</span> <span class="o">&lt;</span><span class="n">output_file</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>We start off opening pipes on the files we require. libuv pipes to a file are
opened as bidirectional by default.</p>
<p class="rubric">uvtee/main.c - read on pipes</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>
<span class="hll">
</span><span class="hll">    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stdin_pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>    <span class="n">uv_pipe_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stdin_pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stdout_pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">uv_pipe_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stdout_pipe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="n">uv_fs_t</span> <span class="n">file_req</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">uv_fs_open</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_req</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mi">0644</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">uv_pipe_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_pipe</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
<span class="hll">
</span>    <span class="n">uv_read_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stdin_pipe</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">read_stdin</span><span class="p">);</span>

    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The third argument of <code class="docutils literal notranslate"><span class="pre">uv_pipe_init()</span></code> should be set to 1 for IPC using named
pipes. This is covered in <a class="reference internal" href="index.html#document-guide/processes"><span class="doc">Processes</span></a>. The <code class="docutils literal notranslate"><span class="pre">uv_pipe_open()</span></code> call
associates the pipe with the file descriptor, in this case <code class="docutils literal notranslate"><span class="pre">0</span></code> (standard
input).</p>
<p>We start monitoring <code class="docutils literal notranslate"><span class="pre">stdin</span></code>. The <code class="docutils literal notranslate"><span class="pre">alloc_buffer</span></code> callback is invoked as new
buffers are required to hold incoming data. <code class="docutils literal notranslate"><span class="pre">read_stdin</span></code> will be called with
these buffers.</p>
<p class="rubric">uvtee/main.c - reading buffers</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">alloc_buffer</span><span class="p">(</span><span class="n">uv_handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">suggested_size</span><span class="p">,</span> <span class="n">uv_buf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">uv_buf_init</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">suggested_size</span><span class="p">),</span> <span class="n">suggested_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">read_stdin</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="n">const</span> <span class="n">uv_buf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="n">UV_EOF</span><span class="p">){</span>
            <span class="o">//</span> <span class="n">end</span> <span class="n">of</span> <span class="n">file</span>
            <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stdin_pipe</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
            <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stdout_pipe</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
            <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">file_pipe</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_data</span><span class="p">((</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">stdout_pipe</span><span class="p">,</span> <span class="n">nread</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">on_stdout_write</span><span class="p">);</span>
        <span class="n">write_data</span><span class="p">((</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">file_pipe</span><span class="p">,</span> <span class="n">nread</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">on_file_write</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">OK</span> <span class="n">to</span> <span class="n">free</span> <span class="n">buffer</span> <span class="k">as</span> <span class="n">write_data</span> <span class="n">copies</span> <span class="n">it</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The standard <code class="docutils literal notranslate"><span class="pre">malloc</span></code> is sufficient here, but you can use any memory allocation
scheme. For example, node.js uses its own slab allocator which associates
buffers with V8 objects.</p>
<p>The read callback <code class="docutils literal notranslate"><span class="pre">nread</span></code> parameter is less than 0 on any error. This error
might be EOF, in which case we close all the streams, using the generic close
function <code class="docutils literal notranslate"><span class="pre">uv_close()</span></code> which deals with the handle based on its internal type.
Otherwise <code class="docutils literal notranslate"><span class="pre">nread</span></code> is a non-negative number and we can attempt to write that
many bytes to the output streams. Finally remember that buffer allocation and
deallocation is application responsibility, so we free the data.</p>
<p>The allocation callback may return a buffer with length zero if it fails to
allocate memory. In this case, the read callback is invoked with error
UV_ENOBUFS. libuv will continue to attempt to read the stream though, so you
must explicitly call <code class="docutils literal notranslate"><span class="pre">uv_close()</span></code> if you want to stop when allocation fails.</p>
<p>The read callback may be called with <code class="docutils literal notranslate"><span class="pre">nread</span> <span class="pre">=</span> <span class="pre">0</span></code>, indicating that at this
point there is nothing to be read. Most applications will just ignore this.</p>
<p class="rubric">uvtee/main.c - Write to pipe</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">uv_write_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span> <span class="n">write_req_t</span><span class="p">;</span>

<span class="n">void</span> <span class="n">free_write_req</span><span class="p">(</span><span class="n">uv_write_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">write_req_t</span> <span class="o">*</span><span class="n">wr</span> <span class="o">=</span> <span class="p">(</span><span class="n">write_req_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">wr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">.</span><span class="n">base</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">wr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">on_stdout_write</span><span class="p">(</span><span class="n">uv_write_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free_write_req</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">on_file_write</span><span class="p">(</span><span class="n">uv_write_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free_write_req</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">write_data</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uv_write_cb</span> <span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">write_req_t</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="n">write_req_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">write_req_t</span><span class="p">));</span>
    <span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">uv_buf_init</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">uv_write</span><span class="p">((</span><span class="n">uv_write_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span><span class="n">dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">write_data()</span></code> makes a copy of the buffer obtained from read. This buffer
does not get passed through to the write callback trigged on write completion. To
get around this we wrap a write request and a buffer in <code class="docutils literal notranslate"><span class="pre">write_req_t</span></code> and
unwrap it in the callbacks. We make a copy so we can free the two buffers from
the two calls to <code class="docutils literal notranslate"><span class="pre">write_data</span></code> independently of each other. While acceptable
for a demo program like this, you’ll probably want smarter memory management,
like reference counted buffers or a pool of buffers in any major application.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>If your program is meant to be used with other programs it may knowingly or
unknowingly be writing to a pipe. This makes it susceptible to <a class="reference external" href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#The_special_problem_of_SIGPIPE">aborting on
receiving a SIGPIPE</a>. It is a good idea to insert:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">in the initialization stages of your application.</p>
</div>
</div>
<div class="section" id="file-change-events">
<h5>File change events<a class="headerlink" href="#file-change-events" title="Permalink to this headline">¶</a></h5>
<p>All modern operating systems provide APIs to put watches on individual files or
directories and be informed when the files are modified. libuv wraps common
file change notification libraries <a class="footnote-reference" href="#fsnotify" id="id3">[1]</a>. This is one of the more
inconsistent parts of libuv. File change notification systems are themselves
extremely varied across platforms so getting everything working everywhere is
difficult. To demonstrate, I’m going to build a simple utility which runs
a command whenever any of the watched files change:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">onchange</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file1</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">file2</span><span class="p">]</span> <span class="o">...</span>
</pre></div>
</div>
<p>The file change notification is started using <code class="docutils literal notranslate"><span class="pre">uv_fs_event_init()</span></code>:</p>
<p class="rubric">onchange/main.c - The setup</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Usage: </span><span class="si">%s</span><span class="s2"> &lt;command&gt; &lt;file1&gt; [file2 ...]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>
    <span class="n">command</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Adding watch on </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">]);</span>
        <span class="n">uv_fs_event_t</span> <span class="o">*</span><span class="n">fs_event_req</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_fs_event_t</span><span class="p">));</span>
        <span class="n">uv_fs_event_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">fs_event_req</span><span class="p">);</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">recursive</span> <span class="n">flag</span> <span class="n">watches</span> <span class="n">subdirectories</span> <span class="n">too</span><span class="o">.</span>
<span class="hll">        <span class="n">uv_fs_event_start</span><span class="p">(</span><span class="n">fs_event_req</span><span class="p">,</span> <span class="n">run_command</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">],</span> <span class="n">UV_FS_EVENT_RECURSIVE</span><span class="p">);</span>
</span>    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The third argument is the actual file or directory to monitor. The last
argument, <code class="docutils literal notranslate"><span class="pre">flags</span></code>, can be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="o">*</span> <span class="n">path</span> <span class="n">argument</span> <span class="n">points</span> <span class="n">to</span> <span class="n">a</span> <span class="n">directory</span><span class="o">.</span>

<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_fs_readlink</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UV_FS_EVENT_WATCH_ENTRY</span></code> and <code class="docutils literal notranslate"><span class="pre">UV_FS_EVENT_STAT</span></code> don’t do anything (yet).
<code class="docutils literal notranslate"><span class="pre">UV_FS_EVENT_RECURSIVE</span></code> will start watching subdirectories as well on
supported platforms.</p>
<p>The callback will receive the following arguments:</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">uv_fs_event_t</span> <span class="pre">*handle</span></code> - The handle. The <code class="docutils literal notranslate"><span class="pre">path</span></code> field of the handle
is the file on which the watch was set.</li>
<li><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*filename</span></code> - If a directory is being monitored, this is the
file which was changed. Only non-<code class="docutils literal notranslate"><span class="pre">null</span></code> on Linux and Windows. May be <code class="docutils literal notranslate"><span class="pre">null</span></code>
even on those platforms.</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code> - one of <code class="docutils literal notranslate"><span class="pre">UV_RENAME</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_CHANGE</span></code>, or a bitwise OR of</dt>
<dd>both.</dd>
</dl>
</li>
<li><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code> - Currently 0.</li>
</ol>
</div></blockquote>
<p>In our example we simply print the arguments and run the command using
<code class="docutils literal notranslate"><span class="pre">system()</span></code>.</p>
<p class="rubric">onchange/main.c - file change notification callback</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span>void run_command(uv_fs_event_t *handle, const char *filename, int events, int status) {
    char path[1024];
    size_t size = 1023;
    // Does not handle error if path is longer than 1023.
    uv_fs_event_getpath(handle, path, &amp;size);
    path[size] = &#39;\0&#39;;

    fprintf(stderr, &quot;Change detected in %s: &quot;, path);
    if (events &amp; UV_RENAME)
        fprintf(stderr, &quot;renamed&quot;);
    if (events &amp; UV_CHANGE)
        fprintf(stderr, &quot;changed&quot;);

    fprintf(stderr, &quot; %s\n&quot;, filename ? filename : &quot;&quot;);
    system(command);
}
</pre></div>
</td></tr></table></div>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="fsnotify" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>inotify on Linux, FSEvents on Darwin, kqueue on BSDs,
ReadDirectoryChangesW on Windows, event ports on Solaris, unsupported on Cygwin</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>see <a class="reference internal" href="index.html#pipes"><span class="std std-ref">Pipes</span></a></td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-guide/networking"></span><div class="section" id="networking">
<h4>Networking<a class="headerlink" href="#networking" title="Permalink to this headline">¶</a></h4>
<p>Networking in libuv is not much different from directly using the BSD socket
interface, some things are easier, all are non-blocking, but the concepts stay
the same. In addition libuv offers utility functions to abstract the annoying,
repetitive and low-level tasks like setting up sockets using the BSD socket
structures, DNS lookup, and tweaking various socket parameters.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">uv_tcp_t</span></code> and <code class="docutils literal notranslate"><span class="pre">uv_udp_t</span></code> structures are used for network I/O.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The code samples in this chapter exist to show certain libuv APIs. They are
not examples of good quality code. They leak memory and don’t always close
connections properly.</p>
</div>
<div class="section" id="tcp">
<h5>TCP<a class="headerlink" href="#tcp" title="Permalink to this headline">¶</a></h5>
<p>TCP is a connection oriented, stream protocol and is therefore based on the
libuv streams infrastructure.</p>
<div class="section" id="server">
<h6>Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h6>
<p>Server sockets proceed by:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">uv_tcp_init</span></code> the TCP handle.</li>
<li><code class="docutils literal notranslate"><span class="pre">uv_tcp_bind</span></code> it.</li>
<li>Call <code class="docutils literal notranslate"><span class="pre">uv_listen</span></code> on the handle to have a callback invoked whenever a new
connection is established by a client.</li>
<li>Use <code class="docutils literal notranslate"><span class="pre">uv_accept</span></code> to accept the connection.</li>
<li>Use <a class="reference internal" href="index.html#buffers-and-streams"><span class="std std-ref">stream operations</span></a> to communicate with the
client.</li>
</ol>
<p>Here is a simple echo server</p>
<p class="rubric">tcp-echo-server/main.c - The listen socket</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span>        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="n">on_close</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="hll">
</span><span class="hll"><span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span>    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>
<span class="hll">
</span><span class="hll">    <span class="n">uv_tcp_t</span> <span class="n">server</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">);</span>
</span><span class="hll">
</span>    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="n">DEFAULT_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>

    <span class="n">uv_tcp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nb">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">DEFAULT_BACKLOG</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Listen error </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>You can see the utility function <code class="docutils literal notranslate"><span class="pre">uv_ip4_addr</span></code> being used to convert from
a human readable IP address, port pair to the sockaddr_in structure required by
the BSD socket APIs. The reverse can be obtained using <code class="docutils literal notranslate"><span class="pre">uv_ip4_name</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are <code class="docutils literal notranslate"><span class="pre">uv_ip6_*</span></code> analogues for the ip4 functions.</p>
</div>
<p>Most of the setup functions are synchronous since they are CPU-bound.
<code class="docutils literal notranslate"><span class="pre">uv_listen</span></code> is where we return to libuv’s callback style. The second
arguments is the backlog queue – the maximum length of queued connections.</p>
<p>When a connection is initiated by clients, the callback is required to set up
a handle for the client socket and associate the handle using <code class="docutils literal notranslate"><span class="pre">uv_accept</span></code>.
In this case we also establish interest in reading from this stream.</p>
<p class="rubric">tcp-echo-server/main.c - Accepting the client</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
    free(buf-&gt;base);
}

void on_new_connection(uv_stream_t *server, int status) {
    if (status &lt; 0) {
        fprintf(stderr, &quot;New connection error %s\n&quot;, uv_strerror(status));
        // error!
<span class="hll">        return;
</span><span class="hll">    }
</span>
    uv_tcp_t *client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
    uv_tcp_init(loop, client);
    if (uv_accept(server, (uv_stream_t*) client) == 0) {
        uv_read_start((uv_stream_t*) client, alloc_buffer, echo_read);
    }
</pre></div>
</td></tr></table></div>
<p>The remaining set of functions is very similar to the streams example and can
be found in the code. Just remember to call <code class="docutils literal notranslate"><span class="pre">uv_close</span></code> when the socket isn’t
required. This can be done even in the <code class="docutils literal notranslate"><span class="pre">uv_listen</span></code> callback if you are not
interested in accepting the connection.</p>
</div>
<div class="section" id="client">
<h6>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h6>
<p>Where you do bind/listen/accept on the server, on the client side it’s simply
a matter of calling <code class="docutils literal notranslate"><span class="pre">uv_tcp_connect</span></code>. The same <code class="docutils literal notranslate"><span class="pre">uv_connect_cb</span></code> style
callback of <code class="docutils literal notranslate"><span class="pre">uv_listen</span></code> is used by <code class="docutils literal notranslate"><span class="pre">uv_tcp_connect</span></code>. Try:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_tcp_t</span><span class="o">*</span> <span class="n">socket</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
<span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">socket</span><span class="p">);</span>

<span class="n">uv_connect_t</span><span class="o">*</span> <span class="n">connect</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_connect_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_connect_t</span><span class="p">));</span>

<span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">dest</span><span class="p">;</span>
<span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>

<span class="n">uv_tcp_connect</span><span class="p">(</span><span class="n">connect</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">on_connect</span></code> will be called after the connection is established. The
callback receives the <code class="docutils literal notranslate"><span class="pre">uv_connect_t</span></code> struct, which has a member <code class="docutils literal notranslate"><span class="pre">.handle</span></code>
pointing to the socket.</p>
</div>
</div>
<div class="section" id="udp">
<h5>UDP<a class="headerlink" href="#udp" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol</a> offers connectionless, unreliable network
communication. Hence libuv doesn’t offer a stream. Instead libuv provides
non-blocking UDP support via the <cite>uv_udp_t</cite> handle (for receiving) and
<cite>uv_udp_send_t</cite> request (for sending) and related functions. That said, the
actual API for reading/writing is very similar to normal stream reads. To look
at how UDP can be used, the example shows the first stage of obtaining an IP
address from a <a class="reference external" href="http://tools.ietf.org/html/rfc2131">DHCP</a> server – DHCP Discover.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You will have to run <cite>udp-dhcp</cite> as <strong>root</strong> since it uses well known port
numbers below 1024.</p>
</div>
<p class="rubric">udp-dhcp/main.c - Setup and send UDP packets</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_udp_t</span> <span class="n">send_socket</span><span class="p">;</span>
<span class="n">uv_udp_t</span> <span class="n">recv_socket</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>
<span class="hll">
</span>    <span class="n">uv_udp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">);</span>
<span class="hll">    <span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">recv_addr</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_addr</span><span class="p">);</span>
</span>    <span class="n">uv_udp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">recv_addr</span><span class="p">,</span> <span class="n">UV_UDP_REUSEADDR</span><span class="p">);</span>
    <span class="n">uv_udp_recv_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>

    <span class="n">uv_udp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_socket</span><span class="p">);</span>
    <span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">broadcast_addr</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">broadcast_addr</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_udp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">broadcast_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>    <span class="n">uv_udp_set_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="hll">    <span class="n">uv_udp_send_t</span> <span class="n">send_req</span><span class="p">;</span>
</span>    <span class="n">uv_buf_t</span> <span class="n">discover_msg</span> <span class="o">=</span> <span class="n">make_discover_msg</span><span class="p">();</span>

    <span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">send_addr</span><span class="p">;</span>
    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;255.255.255.255&quot;</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_addr</span><span class="p">);</span>
    <span class="n">uv_udp_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">discover_msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">send_addr</span><span class="p">,</span> <span class="n">on_send</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The IP address <code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code> is used to bind to all interfaces. The IP
address <code class="docutils literal notranslate"><span class="pre">255.255.255.255</span></code> is a broadcast address meaning that packets
will be sent to all interfaces on the subnet.  port <code class="docutils literal notranslate"><span class="pre">0</span></code> means that the OS
randomly assigns a port.</p>
</div>
<p>First we setup the receiving socket to bind on all interfaces on port 68 (DHCP
client) and start a read on it. This will read back responses from any DHCP
server that replies. We use the UV_UDP_REUSEADDR flag to play nice with any
other system DHCP clients that are running on this computer on the same port.
Then we setup a similar send socket and use <code class="docutils literal notranslate"><span class="pre">uv_udp_send</span></code> to send
a <em>broadcast message</em> on port 67 (DHCP server).</p>
<p>It is <strong>necessary</strong> to set the broadcast flag, otherwise you will get an
<code class="docutils literal notranslate"><span class="pre">EACCES</span></code> error <a class="footnote-reference" href="#id5" id="id1">[1]</a>. The exact message being sent is not relevant to this
book and you can study the code if you are interested. As usual the read and
write callbacks will receive a status code of &lt; 0 if something went wrong.</p>
<p>Since UDP sockets are not connected to a particular peer, the read callback
receives an extra parameter about the sender of the packet.</p>
<p><code class="docutils literal notranslate"><span class="pre">nread</span></code> may be zero if there is no more data to be read. If <code class="docutils literal notranslate"><span class="pre">addr</span></code> is NULL,
it indicates there is nothing to read (the callback shouldn’t do anything), if
not NULL, it indicates that an empty datagram was received from the host at
<code class="docutils literal notranslate"><span class="pre">addr</span></code>. The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter may be <code class="docutils literal notranslate"><span class="pre">UV_UDP_PARTIAL</span></code> if the buffer
provided by your allocator was not large enough to hold the data. <em>In this case
the OS will discard the data that could not fit</em> (That’s UDP for you!).</p>
<p class="rubric">udp-dhcp/main.c - Reading packets</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="hll"><span class="n">void</span> <span class="n">on_read</span><span class="p">(</span><span class="n">uv_udp_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="n">const</span> <span class="n">uv_buf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Read error </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">nread</span><span class="p">));</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">char</span> <span class="n">sender</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">uv_ip4_name</span><span class="p">((</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Recv from </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sender</span><span class="p">);</span>

    <span class="o">//</span> <span class="o">...</span> <span class="n">DHCP</span> <span class="n">specific</span> <span class="n">code</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="n">as_integer</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ipbin</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">as_integer</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
    <span class="n">unsigned</span> <span class="n">char</span> <span class="n">ip</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipbin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Offered IP </span><span class="si">%d</span><span class="s2">.</span><span class="si">%d</span><span class="s2">.</span><span class="si">%d</span><span class="s2">.</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_udp_recv_stop</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="udp-options">
<h6>UDP Options<a class="headerlink" href="#udp-options" title="Permalink to this headline">¶</a></h6>
<div class="section" id="time-to-live">
<h7>Time-to-live<a class="headerlink" href="#time-to-live" title="Permalink to this headline">¶</a></h7>
<p>The TTL of packets sent on the socket can be changed using <code class="docutils literal notranslate"><span class="pre">uv_udp_set_ttl</span></code>.</p>
</div>
<div class="section" id="ipv6-stack-only">
<h7>IPv6 stack only<a class="headerlink" href="#ipv6-stack-only" title="Permalink to this headline">¶</a></h7>
<p>IPv6 sockets can be used for both IPv4 and IPv6 communication. If you want to
restrict the socket to IPv6 only, pass the <code class="docutils literal notranslate"><span class="pre">UV_UDP_IPV6ONLY</span></code> flag to
<code class="docutils literal notranslate"><span class="pre">uv_udp_bind</span></code> <a class="footnote-reference" href="#id6" id="id2">[2]</a>.</p>
</div>
<div class="section" id="multicast">
<h7>Multicast<a class="headerlink" href="#multicast" title="Permalink to this headline">¶</a></h7>
<p>A socket can (un)subscribe to a multicast group using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                               <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span>
                               <span class="n">unsigned</span> <span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">membership</span></code> is <code class="docutils literal notranslate"><span class="pre">UV_JOIN_GROUP</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_LEAVE_GROUP</span></code>.</p>
<p>The concepts of multicasting are nicely explained in <a class="reference external" href="http://www.tldp.org/HOWTO/Multicast-HOWTO-2.html">this guide</a>.</p>
<p>Local loopback of multicast packets is enabled by default <a class="footnote-reference" href="#id7" id="id3">[3]</a>, use
<code class="docutils literal notranslate"><span class="pre">uv_udp_set_multicast_loop</span></code> to switch it off.</p>
<p>The packet time-to-live for multicast packets can be changed using
<code class="docutils literal notranslate"><span class="pre">uv_udp_set_multicast_ttl</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="querying-dns">
<h5>Querying DNS<a class="headerlink" href="#querying-dns" title="Permalink to this headline">¶</a></h5>
<p>libuv provides asynchronous DNS resolution. For this it provides its own
<code class="docutils literal notranslate"><span class="pre">getaddrinfo</span></code> replacement <a class="footnote-reference" href="#id8" id="id4">[4]</a>. In the callback you can
perform normal socket operations on the retrieved addresses. Let’s connect to
Freenode to see an example of DNS resolution.</p>
<p class="rubric">dns/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>
    <span class="n">hints</span><span class="o">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
    <span class="n">hints</span><span class="o">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>
    <span class="n">hints</span><span class="o">.</span><span class="n">ai_protocol</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
    <span class="n">hints</span><span class="o">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">uv_getaddrinfo_t</span> <span class="n">resolver</span><span class="p">;</span>
<span class="hll">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;irc.freenode.net is... &quot;</span><span class="p">);</span>
</span>    <span class="nb">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_getaddrinfo</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resolver</span><span class="p">,</span> <span class="n">on_resolved</span><span class="p">,</span> <span class="s2">&quot;irc.freenode.net&quot;</span><span class="p">,</span> <span class="s2">&quot;6667&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;getaddrinfo call error </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>If <code class="docutils literal notranslate"><span class="pre">uv_getaddrinfo</span></code> returns non-zero, something went wrong in the setup and
your callback won’t be invoked at all. All arguments can be freed immediately
after <code class="docutils literal notranslate"><span class="pre">uv_getaddrinfo</span></code> returns. The <cite>hostname</cite>, <cite>servname</cite> and <cite>hints</cite>
structures are documented in <a class="reference external" href="getaddrinfo">the getaddrinfo man page</a>. The
callback can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in which case the function will run synchronously.</p>
<p>In the resolver callback, you can pick any IP from the linked list of <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">addrinfo(s)</span></code>. This also demonstrates <code class="docutils literal notranslate"><span class="pre">uv_tcp_connect</span></code>. It is necessary to
call <code class="docutils literal notranslate"><span class="pre">uv_freeaddrinfo</span></code> in the callback.</p>
<p class="rubric">dns/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">on_resolved</span><span class="p">(</span><span class="n">uv_getaddrinfo_t</span> <span class="o">*</span><span class="n">resolver</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;getaddrinfo callback error </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

<span class="hll">    <span class="n">char</span> <span class="n">addr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">};</span>
</span>    <span class="n">uv_ip4_name</span><span class="p">((</span><span class="n">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">uv_connect_t</span> <span class="o">*</span><span class="n">connect_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_connect_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_connect_t</span><span class="p">));</span>
    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">socket</span><span class="p">);</span>

<span class="hll">    <span class="n">uv_tcp_connect</span><span class="p">(</span><span class="n">connect_req</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
</span>
    <span class="n">uv_freeaddrinfo</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>libuv also provides the inverse <a class="reference external" href="http://docs.libuv.org/en/v1.x/dns.html#c.uv_getnameinfo">uv_getnameinfo</a>.</p>
</div>
<div class="section" id="network-interfaces">
<h5>Network interfaces<a class="headerlink" href="#network-interfaces" title="Permalink to this headline">¶</a></h5>
<p>Information about the system’s network interfaces can be obtained through libuv
using <code class="docutils literal notranslate"><span class="pre">uv_interface_addresses</span></code>. This simple program just prints out all the
interface details so you get an idea of the fields that are available. This is
useful to allow your service to bind to IP addresses when it starts.</p>
<p class="rubric">interfaces/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;uv.h&gt;

int main() {
    char buf[512];
    uv_interface_address_t *info;
    int count, i;

<span class="hll">    uv_interface_addresses(&amp;info, &amp;count);
</span>    i = count;

    printf(&quot;Number of interfaces: %d\n&quot;, count);
    while (i--) {
        uv_interface_address_t interface = info[i];

        printf(&quot;Name: %s\n&quot;, interface.name);
<span class="hll">        printf(&quot;Internal? %s\n&quot;, interface.is_internal ? &quot;Yes&quot; : &quot;No&quot;);
</span>        
        if (interface.address.address4.sin_family == AF_INET) {
            uv_ip4_name(&amp;interface.address.address4, buf, sizeof(buf));
            printf(&quot;IPv4 address: %s\n&quot;, buf);
        }
        else if (interface.address.address4.sin_family == AF_INET6) {
            uv_ip6_name(&amp;interface.address.address6, buf, sizeof(buf));
            printf(&quot;IPv6 address: %s\n&quot;, buf);
        }

        printf(&quot;\n&quot;);
    }

    uv_free_interface_addresses(info, count);
    return 0;
}
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">is_internal</span></code> is true for loopback interfaces. Note that if a physical
interface has multiple IPv4/IPv6 addresses, the name will be reported multiple
times, with each address being reported once.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://beej.us/guide/bgnet/output/html/multipage/advanced.html#broadcast">http://beej.us/guide/bgnet/output/html/multipage/advanced.html#broadcast</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>on Windows only supported on Windows Vista and later.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1">http://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>libuv use the system <code class="docutils literal notranslate"><span class="pre">getaddrinfo</span></code> in the libuv threadpool. libuv
v0.8.0 and earlier also included <a class="reference external" href="http://c-ares.haxx.se">c-ares</a> as an alternative, but this has been
removed in v0.9.0.</td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-guide/threads"></span><div class="section" id="threads">
<h4>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h4>
<p>Wait a minute? Why are we on threads? Aren’t event loops supposed to be <strong>the
way</strong> to do <em>web-scale programming</em>? Well… no. Threads are still the medium in
which processors do their jobs. Threads are therefore mighty useful sometimes, even
though you might have to wade through various synchronization primitives.</p>
<p>Threads are used internally to fake the asynchronous nature of all of the system
calls. libuv also uses threads to allow you, the application, to perform a task
asynchronously that is actually blocking, by spawning a thread and collecting
the result when it is done.</p>
<p>Today there are two predominant thread libraries: the Windows threads
implementation and POSIX’s <a class="reference external" href="http://man7.org/linux/man-pages/man7/pthreads.7.html">pthreads</a>. libuv’s thread API is analogous to
the pthreads API and often has similar semantics.</p>
<p>A notable aspect of libuv’s thread facilities is that it is a self contained
section within libuv. Whereas other features intimately depend on the event
loop and callback principles, threads are complete agnostic, they block as
required, signal errors directly via return values, and, as shown in the
<a class="reference internal" href="#thread-create-example"><span class="std std-ref">first example</span></a>, don’t even require a running
event loop.</p>
<p>libuv’s thread API is also very limited since the semantics and syntax of
threads are different on all platforms, with different levels of completeness.</p>
<p>This chapter makes the following assumption: <strong>There is only one event loop,
running in one thread (the main thread)</strong>. No other thread interacts
with the event loop (except using <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code>).</p>
<div class="section" id="core-thread-operations">
<h5>Core thread operations<a class="headerlink" href="#core-thread-operations" title="Permalink to this headline">¶</a></h5>
<p>There isn’t much here, you just start a thread using <code class="docutils literal notranslate"><span class="pre">uv_thread_create()</span></code> and
wait for it to close using <code class="docutils literal notranslate"><span class="pre">uv_thread_join()</span></code>.</p>
<p class="rubric" id="thread-create-example">thread-create/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">tracklen</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_thread_t</span> <span class="n">hare_id</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_thread_t</span> <span class="n">tortoise_id</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hare_id</span><span class="p">,</span> <span class="n">hare</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracklen</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tortoise_id</span><span class="p">,</span> <span class="n">tortoise</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracklen</span><span class="p">);</span>
</span><span class="hll">
</span>    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hare_id</span><span class="p">);</span>
    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tortoise_id</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">uv_thread_t</span></code> is just an alias for <code class="docutils literal notranslate"><span class="pre">pthread_t</span></code> on Unix, but this is an
implementation detail, avoid depending on it to always be true.</p>
</div>
<p>The second parameter is the function which will serve as the entry point for
the thread, the last parameter is a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> argument which can be used to pass
custom parameters to the thread. The function <code class="docutils literal notranslate"><span class="pre">hare</span></code> will now run in a separate
thread, scheduled pre-emptively by the operating system:</p>
<p class="rubric">thread-create/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">hare</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="nb">int</span> <span class="n">tracklen</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
</span>    <span class="k">while</span> <span class="p">(</span><span class="n">tracklen</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tracklen</span><span class="o">--</span><span class="p">;</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Hare ran another step</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Hare done running!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">pthread_join()</span></code> which allows the target thread to pass back a value to
the calling thread using a second parameter, <code class="docutils literal notranslate"><span class="pre">uv_thread_join()</span></code> does not. To
send values use <a class="reference internal" href="#inter-thread-communication"><span class="std std-ref">Inter-thread communication</span></a>.</p>
</div>
<div class="section" id="synchronization-primitives">
<h5>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h5>
<p>This section is purposely spartan. This book is not about threads, so I only
catalogue any surprises in the libuv APIs here. For the rest you can look at
the pthreads <a class="reference external" href="pthreads">man pages</a>.</p>
<div class="section" id="mutexes">
<h6>Mutexes<a class="headerlink" href="#mutexes" title="Permalink to this headline">¶</a></h6>
<p>The mutex functions are a <strong>direct</strong> map to the pthread equivalents.</p>
<p class="rubric">libuv mutex functions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">/*</span>
 <span class="o">*</span> <span class="n">uv_fs_stat</span><span class="p">()</span> <span class="n">based</span> <span class="n">polling</span> <span class="n">file</span> <span class="n">watcher</span><span class="o">.</span>
 <span class="o">*/</span>
<span class="n">struct</span> <span class="n">uv_fs_poll_s</span> <span class="p">{</span>
  <span class="n">UV_HANDLE_FIELDS</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">uv_mutex_init()</span></code>, <code class="docutils literal notranslate"><span class="pre">uv_mutex_init_recursive()</span></code> and <code class="docutils literal notranslate"><span class="pre">uv_mutex_trylock()</span></code>
functions will return 0 on success, and an error code otherwise.</p>
<p>If <cite>libuv</cite> has been compiled with debugging enabled, <code class="docutils literal notranslate"><span class="pre">uv_mutex_destroy()</span></code>,
<code class="docutils literal notranslate"><span class="pre">uv_mutex_lock()</span></code> and <code class="docutils literal notranslate"><span class="pre">uv_mutex_unlock()</span></code> will <code class="docutils literal notranslate"><span class="pre">abort()</span></code> on error.
Similarly <code class="docutils literal notranslate"><span class="pre">uv_mutex_trylock()</span></code> will abort if the error is anything <em>other
than</em> <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>.</p>
<p>Recursive mutexes are supported, but you should not rely on them. Also, they
should not be used with <code class="docutils literal notranslate"><span class="pre">uv_cond_t</span></code> variables.</p>
<p>The default BSD mutex implementation will raise an error if a thread which has
locked a mutex attempts to lock it again. For example, a construct like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_mutex_init</span><span class="p">(</span><span class="n">a_mutex</span><span class="p">);</span>
<span class="n">uv_mutex_lock</span><span class="p">(</span><span class="n">a_mutex</span><span class="p">);</span>
<span class="n">uv_thread_create</span><span class="p">(</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">a_mutex</span><span class="p">);</span>
<span class="n">uv_mutex_lock</span><span class="p">(</span><span class="n">a_mutex</span><span class="p">);</span>
<span class="o">//</span> <span class="n">more</span> <span class="n">things</span> <span class="n">here</span>
</pre></div>
</div>
<p>can be used to wait until another thread initializes some stuff and then
unlocks <code class="docutils literal notranslate"><span class="pre">a_mutex</span></code> but will lead to your program crashing if in debug mode, or
return an error in the second call to <code class="docutils literal notranslate"><span class="pre">uv_mutex_lock()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Mutexes on Windows are always recursive.</p>
</div>
</div>
<div class="section" id="locks">
<h6>Locks<a class="headerlink" href="#locks" title="Permalink to this headline">¶</a></h6>
<p>Read-write locks are a more granular access mechanism. Two readers can access
shared memory at the same time. A writer may not acquire the lock when it is
held by a reader. A reader or writer may not acquire a lock when a writer is
holding it. Read-write locks are frequently used in databases. Here is a toy
example.</p>
<p class="rubric">locks/main.c - simple rwlocks</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="n">uv_barrier_t</span> <span class="n">blocker</span><span class="p">;</span>
<span class="n">uv_rwlock_t</span> <span class="n">numlock</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">shared_num</span><span class="p">;</span>

<span class="n">void</span> <span class="n">reader</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">uv_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numlock</span><span class="p">);</span>
</span>        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Reader </span><span class="si">%d</span><span class="s2">: acquired lock</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Reader </span><span class="si">%d</span><span class="s2">: shared num = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">shared_num</span><span class="p">);</span>
<span class="hll">        <span class="n">uv_rwlock_rdunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numlock</span><span class="p">);</span>
</span>        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Reader </span><span class="si">%d</span><span class="s2">: released lock</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">uv_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">writer</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">uv_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numlock</span><span class="p">);</span>
</span>        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Writer </span><span class="si">%d</span><span class="s2">: acquired lock</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
        <span class="n">shared_num</span><span class="o">++</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Writer </span><span class="si">%d</span><span class="s2">: incremented shared num = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">shared_num</span><span class="p">);</span>
<span class="hll">        <span class="n">uv_rwlock_wrunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numlock</span><span class="p">);</span>
</span>        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Writer </span><span class="si">%d</span><span class="s2">: released lock</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">uv_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">uv_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">shared_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numlock</span><span class="p">);</span>
</span>
    <span class="n">uv_thread_t</span> <span class="n">threads</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="nb">int</span> <span class="n">thread_nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">writer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">uv_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="p">);</span>
    <span class="n">uv_barrier_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="p">);</span>

<span class="hll">    <span class="n">uv_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numlock</span><span class="p">);</span>
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Run this and observe how the readers will sometimes overlap. In case of
multiple writers, schedulers will usually give them higher priority, so if you
add two writers, you’ll see that both writers tend to finish first before the
readers get a chance again.</p>
<p>We also use barriers in the above example so that the main thread can wait for
all readers and writers to indicate they have ended.</p>
</div>
<div class="section" id="others">
<h6>Others<a class="headerlink" href="#others" title="Permalink to this headline">¶</a></h6>
<p>libuv also supports <a class="reference external" href="http://en.wikipedia.org/wiki/Semaphore_(programming)">semaphores</a>, <a class="reference external" href="http://en.wikipedia.org/wiki/Condition_variable#Waiting_and_signaling">condition variables</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">barriers</a> with APIs
very similar to their pthread counterparts.</p>
<p>In addition, libuv provides a convenience function <code class="docutils literal notranslate"><span class="pre">uv_once()</span></code>. Multiple
threads can attempt to call <code class="docutils literal notranslate"><span class="pre">uv_once()</span></code> with a given guard and a function
pointer, <strong>only the first one will win, the function will be called once and
only once</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Initialize</span> <span class="n">guard</span> <span class="o">*/</span>
<span class="n">static</span> <span class="n">uv_once_t</span> <span class="n">once_only</span> <span class="o">=</span> <span class="n">UV_ONCE_INIT</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="o">...</span> <span class="n">work</span> <span class="o">*/</span>
    <span class="n">uv_once</span><span class="p">(</span><span class="n">once_only</span><span class="p">,</span> <span class="n">increment</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="o">...</span> <span class="n">work</span> <span class="o">*/</span>
    <span class="n">uv_once</span><span class="p">(</span><span class="n">once_only</span><span class="p">,</span> <span class="n">increment</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="o">...</span> <span class="n">spawn</span> <span class="n">threads</span> <span class="o">*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After all threads are done, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p id="libuv-work-queue">libuv v0.11.11 onwards also added a <code class="docutils literal notranslate"><span class="pre">uv_key_t</span></code> struct and <a class="reference external" href="http://docs.libuv.org/en/v1.x/threading.html#thread-local-storage">api</a> for
thread-local storage.</p>
</div>
</div>
<div class="section" id="id1">
<h5>libuv work queue<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">uv_queue_work()</span></code> is a convenience function that allows an application to run
a task in a separate thread, and have a callback that is triggered when the
task is done. A seemingly simple function, what makes <code class="docutils literal notranslate"><span class="pre">uv_queue_work()</span></code>
tempting is that it allows potentially any third-party libraries to be used
with the event-loop paradigm. When you use event loops, it is <em>imperative to
make sure that no function which runs periodically in the loop thread blocks
when performing I/O or is a serious CPU hog</em>, because this means that the loop
slows down and events are not being handled at full capacity.</p>
<p>However, a lot of existing code out there features blocking functions (for example
a routine which performs I/O under the hood) to be used with threads if you
want responsiveness (the classic ‘one thread per client’ server model), and
getting them to play with an event loop library generally involves rolling your
own system of running the task in a separate thread.  libuv just provides
a convenient abstraction for this.</p>
<p>Here is a simple example inspired by <a class="reference external" href="http://teddziuba.github.io/2011/10/node-js-is-cancer.html">node.js is cancer</a>. We are going to
calculate fibonacci numbers, sleeping a bit along the way, but run it in
a separate thread so that the blocking and CPU bound task does not prevent the
event loop from performing other activities.</p>
<p class="rubric">queue-work/main.c - lazy fibonacci</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">fib</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">long</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">fib_</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">th fibonacci is </span><span class="si">%lu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fib</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">after_fib</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Done calculating </span><span class="si">%d</span><span class="s2">th fibonacci</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The actual task function is simple, nothing to show that it is going to be
run in a separate thread. The <code class="docutils literal notranslate"><span class="pre">uv_work_t</span></code> structure is the clue. You can pass
arbitrary data through it using the <code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">data</span></code> field and use it to
communicate to and from the thread. But be sure you are using proper locks if
you are changing things while both threads may be running.</p>
<p>The trigger is <code class="docutils literal notranslate"><span class="pre">uv_queue_work</span></code>:</p>
<p class="rubric">queue-work/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="nb">int</span> <span class="n">data</span><span class="p">[</span><span class="n">FIB_UNTIL</span><span class="p">];</span>
    <span class="n">uv_work_t</span> <span class="n">req</span><span class="p">[</span><span class="n">FIB_UNTIL</span><span class="p">];</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FIB_UNTIL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">req</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="hll">        <span class="n">uv_queue_work</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fib</span><span class="p">,</span> <span class="n">after_fib</span><span class="p">);</span>
</span>    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The thread function will be launched in a separate thread, passed the
<code class="docutils literal notranslate"><span class="pre">uv_work_t</span></code> structure and once the function returns, the <em>after</em> function
will be called on the thread the event loop is running in. It will be passed
the same structure.</p>
<p>For writing wrappers to blocking libraries, a common <a class="reference internal" href="index.html#baton"><span class="std std-ref">pattern</span></a>
is to use a baton to exchange data.</p>
<p>Since libuv version <cite>0.9.4</cite> an additional function, <code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code>, is
available. This allows you to cancel tasks on the libuv work queue. Only tasks
that <em>are yet to be started</em> can be cancelled. If a task has <em>already started
executing, or it has finished executing</em>, <code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code> <strong>will fail</strong>.</p>
<p><code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code> is useful to cleanup pending tasks if the user requests
termination. For example, a music player may queue up multiple directories to
be scanned for audio files. If the user terminates the program, it should quit
quickly and not wait until all pending requests are run.</p>
<p>Let’s modify the fibonacci example to demonstrate <code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code>. We first set
up a signal handler for termination.</p>
<p class="rubric">queue-cancel/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="nb">int</span> <span class="n">data</span><span class="p">[</span><span class="n">FIB_UNTIL</span><span class="p">];</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FIB_UNTIL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">fib_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">uv_queue_work</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fib_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fib</span><span class="p">,</span> <span class="n">after_fib</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">uv_signal_t</span> <span class="n">sig</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>When the user triggers the signal by pressing <code class="docutils literal notranslate"><span class="pre">Ctrl+C</span></code> we send
<code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code> to all the workers. <code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code> will return <code class="docutils literal notranslate"><span class="pre">0</span></code> for those that are already executing or finished.</p>
<p class="rubric">queue-cancel/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">signal_handler</span><span class="p">(</span><span class="n">uv_signal_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Signal received!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FIB_UNTIL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">uv_cancel</span><span class="p">((</span><span class="n">uv_req_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">fib_reqs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span>    <span class="p">}</span>
    <span class="n">uv_signal_stop</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>For tasks that do get cancelled successfully, the <em>after</em> function is called
with <code class="docutils literal notranslate"><span class="pre">status</span></code> set to <code class="docutils literal notranslate"><span class="pre">UV_ECANCELED</span></code>.</p>
<p class="rubric">queue-cancel/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">after_fib</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">UV_ECANCELED</span><span class="p">)</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Calculation of </span><span class="si">%d</span><span class="s2"> cancelled.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">uv_cancel()</span></code> can also be used with <code class="docutils literal notranslate"><span class="pre">uv_fs_t</span></code> and <code class="docutils literal notranslate"><span class="pre">uv_getaddrinfo_t</span></code>
requests. For the filesystem family of functions, <code class="docutils literal notranslate"><span class="pre">uv_fs_t.errorno</span></code> will be
set to <code class="docutils literal notranslate"><span class="pre">UV_ECANCELED</span></code>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">A well designed program would have a way to terminate long running workers
that have already started executing. Such a worker could periodically check
for a variable that only the main process sets to signal termination.</p>
</div>
</div>
<div class="section" id="inter-thread-communication">
<span id="id2"></span><h5>Inter-thread communication<a class="headerlink" href="#inter-thread-communication" title="Permalink to this headline">¶</a></h5>
<p>Sometimes you want various threads to actually send each other messages <em>while</em>
they are running. For example you might be running some long duration task in
a separate thread (perhaps using <code class="docutils literal notranslate"><span class="pre">uv_queue_work</span></code>) but want to notify progress
to the main thread. This is a simple example of having a download manager
informing the user of the status of running downloads.</p>
<p class="rubric">progress/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="hll"><span class="n">uv_async_t</span> <span class="k">async</span><span class="p">;</span>
</span><span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_work_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10240</span><span class="p">;</span>
    <span class="n">req</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">;</span>
<span class="hll">
</span>    <span class="n">uv_async_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">async</span><span class="p">,</span> <span class="n">print_progress</span><span class="p">);</span>
    <span class="n">uv_queue_work</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">fake_download</span><span class="p">,</span> <span class="n">after</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The async thread communication works <em>on loops</em> so although any thread can be
the message sender, only threads with libuv loops can be receivers (or rather
the loop is the receiver). libuv will invoke the callback (<code class="docutils literal notranslate"><span class="pre">print_progress</span></code>)
with the async watcher whenever it receives a message.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is important to realize that since the message send is <em>async</em>, the callback
may be invoked immediately after <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code> is called in another
thread, or it may be invoked after some time. libuv may also combine
multiple calls to <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code> and invoke your callback only once. The
only guarantee that libuv makes is – The callback function is called <em>at
least once</em> after the call to <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code>. If you have no pending
calls to <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code>, the callback won’t be called. If you make two
or more calls, and libuv hasn’t had a chance to run the callback yet, it
<em>may</em> invoke your callback <em>only once</em> for the multiple invocations of
<code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code>. Your callback will never be called twice for just one
event.</p>
</div>
<p class="rubric">progress/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">percentage</span><span class="p">;</span>

<span class="n">void</span> <span class="n">fake_download</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="nb">int</span> <span class="n">downloaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">downloaded</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">percentage</span> <span class="o">=</span> <span class="n">downloaded</span><span class="o">*</span><span class="mf">100.0</span><span class="o">/</span><span class="n">size</span><span class="p">;</span>
</span><span class="hll">        <span class="k">async</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">percentage</span><span class="p">;</span>
</span>        <span class="n">uv_async_send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">async</span><span class="p">);</span>

        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">downloaded</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">200</span><span class="o">+</span><span class="n">random</span><span class="p">())</span><span class="o">%</span><span class="mi">1000</span><span class="p">;</span> <span class="o">//</span> <span class="n">can</span> <span class="n">only</span> <span class="n">download</span> <span class="nb">max</span> <span class="mi">1000</span><span class="nb">bytes</span><span class="o">/</span><span class="n">sec</span><span class="p">,</span>
                                           <span class="o">//</span> <span class="n">but</span> <span class="n">at</span> <span class="n">least</span> <span class="n">a</span> <span class="mi">200</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In the download function, we modify the progress indicator and queue the message
for delivery with <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code>. Remember: <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code> is also
non-blocking and will return immediately.</p>
<p class="rubric">progress/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">print_progress</span><span class="p">(</span><span class="n">uv_async_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">double</span> <span class="n">percentage</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">double</span><span class="o">*</span><span class="p">)</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Downloaded </span><span class="si">%.2f%%</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">percentage</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>The callback is a standard libuv pattern, extracting the data from the watcher.</p>
<p>Finally it is important to remember to clean up the watcher.</p>
<p class="rubric">progress/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">after</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="nb">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Download complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
</span>    <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="k">async</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>After this example, which showed the abuse of the <code class="docutils literal notranslate"><span class="pre">data</span></code> field, <a class="reference external" href="https://github.com/bnoordhuis">bnoordhuis</a>
pointed out that using the <code class="docutils literal notranslate"><span class="pre">data</span></code> field is not thread safe, and
<code class="docutils literal notranslate"><span class="pre">uv_async_send()</span></code> is actually only meant to wake up the event loop. Use
a mutex or rwlock to ensure accesses are performed in the right order.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">mutexes and rwlocks <strong>DO NOT</strong> work inside a signal handler, whereas
<code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code> does.</p>
</div>
<p>One use case where <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code> is required is when interoperating with
libraries that require thread affinity for their functionality. For example in
node.js, a v8 engine instance, contexts and its objects are bound to the thread
that the v8 instance was started in. Interacting with v8 data structures from
another thread can lead to undefined results. Now consider some node.js module
which binds a third party library. It may go something like this:</p>
<ol class="arabic">
<li><p class="first">In node, the third party library is set up with a JavaScript callback to be
invoked for more information:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">lib</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s1">&#39;lib&#39;</span><span class="p">);</span>
<span class="n">lib</span><span class="o">.</span><span class="n">on_progress</span><span class="p">(</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Progress&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="n">lib</span><span class="o">.</span><span class="n">do</span><span class="p">();</span>

<span class="o">//</span> <span class="n">do</span> <span class="n">other</span> <span class="n">stuff</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">lib.do</span></code> is supposed to be non-blocking but the third party lib is
blocking, so the binding uses <code class="docutils literal notranslate"><span class="pre">uv_queue_work</span></code>.</p>
</li>
<li><p class="first">The actual work being done in a separate thread wants to invoke the progress
callback, but cannot directly call into v8 to interact with JavaScript. So
it uses <code class="docutils literal notranslate"><span class="pre">uv_async_send</span></code>.</p>
</li>
<li><p class="first">The async callback, invoked in the main loop thread, which is the v8 thread,
then interacts with v8 to invoke the JavaScript callback.</p>
</li>
</ol>
<hr class="docutils" />
</div>
</div>
<span id="document-guide/processes"></span><div class="section" id="processes">
<h4>Processes<a class="headerlink" href="#processes" title="Permalink to this headline">¶</a></h4>
<p>libuv offers considerable child process management, abstracting the platform
differences and allowing communication with the child process using streams or
named pipes.</p>
<p>A common idiom in Unix is for every process to do one thing and do it well. In
such a case, a process often uses multiple child processes to achieve tasks
(similar to using pipes in shells). A multi-process model with messages
may also be easier to reason about compared to one with threads and shared
memory.</p>
<p>A common refrain against event-based programs is that they cannot take
advantage of multiple cores in modern computers. In a multi-threaded program
the kernel can perform scheduling and assign different threads to different
cores, improving performance. But an event loop has only one thread.  The
workaround can be to launch multiple processes instead, with each process
running an event loop, and each process getting assigned to a separate CPU
core.</p>
<div class="section" id="spawning-child-processes">
<h5>Spawning child processes<a class="headerlink" href="#spawning-child-processes" title="Permalink to this headline">¶</a></h5>
<p>The simplest case is when you simply want to launch a process and know when it
exits. This is achieved using <code class="docutils literal notranslate"><span class="pre">uv_spawn</span></code>.</p>
<p class="rubric">spawn/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_process_t</span> <span class="n">child_req</span><span class="p">;</span>
<span class="n">uv_process_options_t</span> <span class="n">options</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mkdir&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;test-dir&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
<span class="hll">
</span>    <span class="n">options</span><span class="o">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
<span class="hll">    <span class="n">options</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="s2">&quot;mkdir&quot;</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="nb">int</span> <span class="n">r</span><span class="p">;</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">)))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Launched process with ID </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">child_req</span><span class="o">.</span><span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">options</span></code> is implicitly initialized with zeros since it is a global
variable.  If you change <code class="docutils literal notranslate"><span class="pre">options</span></code> to a local variable, remember to
initialize it to null out all unused fields:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_process_options_t</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">uv_process_t</span></code> struct only acts as the handle, all options are set via
<code class="docutils literal notranslate"><span class="pre">uv_process_options_t</span></code>. To simply launch a process, you need to set only the
<code class="docutils literal notranslate"><span class="pre">file</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code> fields. <code class="docutils literal notranslate"><span class="pre">file</span></code> is the program to execute. Since
<code class="docutils literal notranslate"><span class="pre">uv_spawn</span></code> uses <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man3/exec.3.html">execvp</a> internally, there is no need to supply the full
path. Finally as per underlying conventions, <strong>the arguments array has to be
one larger than the number of arguments, with the last element being NULL</strong>.</p>
<p>After the call to <code class="docutils literal notranslate"><span class="pre">uv_spawn</span></code>, <code class="docutils literal notranslate"><span class="pre">uv_process_t.pid</span></code> will contain the process
ID of the child process.</p>
<p>The exit callback will be invoked with the <em>exit status</em> and the type of <em>signal</em>
which caused the exit.</p>
<p class="rubric">spawn/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">on_exit</span><span class="p">(</span><span class="n">uv_process_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">exit_status</span><span class="p">,</span> <span class="nb">int</span> <span class="n">term_signal</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Process exited with status %&quot;</span> <span class="n">PRId64</span> <span class="s2">&quot;, signal </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">,</span> <span class="n">term_signal</span><span class="p">);</span>
</span>    <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>It is <strong>required</strong> to close the process watcher after the process exits.</p>
</div>
<div class="section" id="changing-process-parameters">
<h5>Changing process parameters<a class="headerlink" href="#changing-process-parameters" title="Permalink to this headline">¶</a></h5>
<p>Before the child process is launched you can control the execution environment
using fields in <code class="docutils literal notranslate"><span class="pre">uv_process_options_t</span></code>.</p>
<div class="section" id="change-execution-directory">
<h6>Change execution directory<a class="headerlink" href="#change-execution-directory" title="Permalink to this headline">¶</a></h6>
<p>Set <code class="docutils literal notranslate"><span class="pre">uv_process_options_t.cwd</span></code> to the corresponding directory.</p>
</div>
<div class="section" id="set-environment-variables">
<h6>Set environment variables<a class="headerlink" href="#set-environment-variables" title="Permalink to this headline">¶</a></h6>
<p><code class="docutils literal notranslate"><span class="pre">uv_process_options_t.env</span></code> is a null-terminated array of strings, each of the
form <code class="docutils literal notranslate"><span class="pre">VAR=VALUE</span></code> used to set up the environment variables for the process. Set
this to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> to inherit the environment from the parent (this) process.</p>
</div>
<div class="section" id="option-flags">
<h6>Option flags<a class="headerlink" href="#option-flags" title="Permalink to this headline">¶</a></h6>
<p>Setting <code class="docutils literal notranslate"><span class="pre">uv_process_options_t.flags</span></code> to a bitwise OR of the following flags,
modifies the child process behaviour:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">UV_PROCESS_SETUID</span></code> - sets the child’s execution user ID to <code class="docutils literal notranslate"><span class="pre">uv_process_options_t.uid</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">UV_PROCESS_SETGID</span></code> - sets the child’s execution group ID to <code class="docutils literal notranslate"><span class="pre">uv_process_options_t.gid</span></code>.</li>
</ul>
<p>Changing the UID/GID is only supported on Unix, <code class="docutils literal notranslate"><span class="pre">uv_spawn</span></code> will fail on
Windows with <code class="docutils literal notranslate"><span class="pre">UV_ENOTSUP</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</span></code> - No quoting or escaping of
<code class="docutils literal notranslate"><span class="pre">uv_process_options_t.args</span></code> is done on Windows. Ignored on Unix.</li>
<li><code class="docutils literal notranslate"><span class="pre">UV_PROCESS_DETACHED</span></code> - Starts the child process in a new session, which
will keep running after the parent process exits. See example below.</li>
</ul>
</div>
</div>
<div class="section" id="detaching-processes">
<h5>Detaching processes<a class="headerlink" href="#detaching-processes" title="Permalink to this headline">¶</a></h5>
<p>Passing the flag <code class="docutils literal notranslate"><span class="pre">UV_PROCESS_DETACHED</span></code> can be used to launch daemons, or
child processes which are independent of the parent so that the parent exiting
does not affect it.</p>
<p class="rubric">detach/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;sleep&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;100&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="n">options</span><span class="o">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="n">options</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="s2">&quot;sleep&quot;</span><span class="p">;</span>
    <span class="n">options</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
<span class="hll">    <span class="n">options</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_PROCESS_DETACHED</span><span class="p">;</span>
</span>
    <span class="nb">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Launched sleep with PID </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">child_req</span><span class="o">.</span><span class="n">pid</span><span class="p">);</span>
</span>    <span class="n">uv_unref</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Just remember that the handle is still monitoring the child, so your program
won’t exit. Use <code class="docutils literal notranslate"><span class="pre">uv_unref()</span></code> if you want to be more <em>fire-and-forget</em>.</p>
</div>
<div class="section" id="sending-signals-to-processes">
<h5>Sending signals to processes<a class="headerlink" href="#sending-signals-to-processes" title="Permalink to this headline">¶</a></h5>
<p>libuv wraps the standard <code class="docutils literal notranslate"><span class="pre">kill(2)</span></code> system call on Unix and implements one
with similar semantics on Windows, with <em>one caveat</em>: all of <code class="docutils literal notranslate"><span class="pre">SIGTERM</span></code>,
<code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> and <code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code>, lead to termination of the process. The signature
of <code class="docutils literal notranslate"><span class="pre">uv_kill</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_err_t</span> <span class="n">uv_kill</span><span class="p">(</span><span class="nb">int</span> <span class="n">pid</span><span class="p">,</span> <span class="nb">int</span> <span class="n">signum</span><span class="p">);</span>
</pre></div>
</div>
<p>For processes started using libuv, you may use <code class="docutils literal notranslate"><span class="pre">uv_process_kill</span></code> instead,
which accepts the <code class="docutils literal notranslate"><span class="pre">uv_process_t</span></code> watcher as the first argument, rather than
the pid. In this case, <strong>remember to call</strong> <code class="docutils literal notranslate"><span class="pre">uv_close</span></code> on the watcher.</p>
</div>
<div class="section" id="signals">
<h5>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h5>
<p>libuv provides wrappers around Unix signals with <a class="reference external" href="http://docs.libuv.org/en/v1.x/signal.html#signal">some Windows support</a> as well.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">uv_signal_init()</span></code> to initialize
a handle and associate it with a loop. To listen for particular signals on
that handler, use <code class="docutils literal notranslate"><span class="pre">uv_signal_start()</span></code> with the handler function. Each handler
can only be associated with one signal number, with subsequent calls to
<code class="docutils literal notranslate"><span class="pre">uv_signal_start()</span></code> overwriting earlier associations. Use <code class="docutils literal notranslate"><span class="pre">uv_signal_stop()</span></code> to
stop watching. Here is a small example demonstrating the various possibilities:</p>
<p class="rubric">signal/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;unistd.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">create_loop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uv_loop_init</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">signal_handler</span><span class="p">(</span><span class="n">uv_signal_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="nb">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Signal received: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">signum</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_signal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="o">//</span> <span class="n">two</span> <span class="n">signal</span> <span class="n">handlers</span> <span class="ow">in</span> <span class="n">one</span> <span class="n">loop</span>
<span class="n">void</span> <span class="n">thread1_worker</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop1</span> <span class="o">=</span> <span class="n">create_loop</span><span class="p">();</span>

    <span class="n">uv_signal_t</span> <span class="n">sig1a</span><span class="p">,</span> <span class="n">sig1b</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig1a</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig1a</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig1b</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig1b</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">two</span> <span class="n">signal</span> <span class="n">handlers</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">its</span> <span class="n">own</span> <span class="n">loop</span>
<span class="n">void</span> <span class="n">thread2_worker</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop2</span> <span class="o">=</span> <span class="n">create_loop</span><span class="p">();</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop3</span> <span class="o">=</span> <span class="n">create_loop</span><span class="p">();</span>

    <span class="n">uv_signal_t</span> <span class="n">sig2</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig2</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig2</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="n">uv_signal_t</span> <span class="n">sig3</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig3</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig3</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">uv_run</span><span class="p">(</span><span class="n">loop2</span><span class="p">,</span> <span class="n">UV_RUN_NOWAIT</span><span class="p">)</span> <span class="o">||</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop3</span><span class="p">,</span> <span class="n">UV_RUN_NOWAIT</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;PID </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="n">uv_thread_t</span> <span class="n">thread1</span><span class="p">,</span> <span class="n">thread2</span><span class="p">;</span>

    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">,</span> <span class="n">thread1_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2</span><span class="p">,</span> <span class="n">thread2_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">uv_run(loop,</span> <span class="pre">UV_RUN_NOWAIT)</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">uv_run(loop,</span> <span class="pre">UV_RUN_ONCE)</span></code>
in that it will process only one event. UV_RUN_ONCE blocks if there are no
pending events, while UV_RUN_NOWAIT will return immediately. We use NOWAIT
so that one of the loops isn’t starved because the other one has no pending
activity.</p>
</div>
<p>Send <code class="docutils literal notranslate"><span class="pre">SIGUSR1</span></code> to the process, and you’ll find the handler being invoked
4 times, one for each <code class="docutils literal notranslate"><span class="pre">uv_signal_t</span></code>. The handler just stops each handle,
so that the program exits. This sort of dispatch to all handlers is very
useful. A server using multiple event loops could ensure that all data was
safely saved before termination, simply by every loop adding a watcher for
<code class="docutils literal notranslate"><span class="pre">SIGINT</span></code>.</p>
</div>
<div class="section" id="child-process-i-o">
<h5>Child Process I/O<a class="headerlink" href="#child-process-i-o" title="Permalink to this headline">¶</a></h5>
<p>A normal, newly spawned process has its own set of file descriptors, with 0,
1 and 2 being <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> respectively. Sometimes you
may want to share file descriptors with the child. For example, perhaps your
applications launches a sub-command and you want any errors to go in the log
file, but ignore <code class="docutils literal notranslate"><span class="pre">stdout</span></code>. For this you’d like to have <code class="docutils literal notranslate"><span class="pre">stderr</span></code> of the
child be the same as the stderr of the parent. In this case, libuv supports
<em>inheriting</em> file descriptors. In this sample, we invoke the test program,
which is:</p>
<p class="rubric">proc-streams/test.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;This is stderr</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;This is stdout</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The actual program <code class="docutils literal notranslate"><span class="pre">proc-streams</span></code> runs this while sharing only <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.
The file descriptors of the child process are set using the <code class="docutils literal notranslate"><span class="pre">stdio</span></code> field in
<code class="docutils literal notranslate"><span class="pre">uv_process_options_t</span></code>. First set the <code class="docutils literal notranslate"><span class="pre">stdio_count</span></code> field to the number of
file descriptors being set. <code class="docutils literal notranslate"><span class="pre">uv_process_options_t.stdio</span></code> is an array of
<code class="docutils literal notranslate"><span class="pre">uv_stdio_container_t</span></code>, which is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="n">UV_EXTERN</span> <span class="nb">int</span> <span class="n">uv_getaddrinfo</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                             <span class="n">uv_getaddrinfo_t</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span>
                             <span class="n">uv_getaddrinfo_cb</span> <span class="n">getaddrinfo_cb</span><span class="p">,</span>
                             <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span>
                             <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">service</span><span class="p">,</span>
                             <span class="n">const</span> <span class="n">struct</span> <span class="n">addrinfo</span><span class="o">*</span> <span class="n">hints</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="n">void</span> <span class="n">uv_freeaddrinfo</span><span class="p">(</span><span class="n">struct</span> <span class="n">addrinfo</span><span class="o">*</span> <span class="n">ai</span><span class="p">);</span>

</pre></div>
</div>
<p>where flags can have several values. Use <code class="docutils literal notranslate"><span class="pre">UV_IGNORE</span></code> if it isn’t going to be
used. If the first three <code class="docutils literal notranslate"><span class="pre">stdio</span></code> fields are marked as <code class="docutils literal notranslate"><span class="pre">UV_IGNORE</span></code> they’ll
redirect to <code class="docutils literal notranslate"><span class="pre">/dev/null</span></code>.</p>
<p>Since we want to pass on an existing descriptor, we’ll use <code class="docutils literal notranslate"><span class="pre">UV_INHERIT_FD</span></code>.
Then we set the <code class="docutils literal notranslate"><span class="pre">fd</span></code> to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p>
<p class="rubric">proc-streams/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span>
<span class="hll">
</span>    <span class="n">options</span><span class="o">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
<span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_FD</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span>    <span class="n">options</span><span class="o">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>

    <span class="n">options</span><span class="o">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
    <span class="n">options</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">options</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

    <span class="nb">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>If you run <code class="docutils literal notranslate"><span class="pre">proc-stream</span></code> you’ll see that only the line “This is stderr” will
be displayed. Try marking <code class="docutils literal notranslate"><span class="pre">stdout</span></code> as being inherited and see the output.</p>
<p>It is dead simple to apply this redirection to streams.  By setting <code class="docutils literal notranslate"><span class="pre">flags</span></code>
to <code class="docutils literal notranslate"><span class="pre">UV_INHERIT_STREAM</span></code> and setting <code class="docutils literal notranslate"><span class="pre">data.stream</span></code> to the stream in the
parent process, the child process can treat that stream as standard I/O. This
can be used to implement something like <a class="reference external" href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>.</p>
<p>A sample CGI script/executable is:</p>
<p class="rubric">cgi/tick.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;unistd.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;tick</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;BOOM!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The CGI server combines the concepts from this chapter and <a class="reference internal" href="index.html#document-guide/networking"><span class="doc">Networking</span></a> so
that every client is sent ten ticks after which that connection is closed.</p>
<p class="rubric">cgi/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
void on_new_connection(uv_stream_t *server, int status) {
    if (status == -1) {
        // error!
        return;
    }

    uv_tcp_t *client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
    uv_tcp_init(loop, client);
<span class="hll">    if (uv_accept(server, (uv_stream_t*) client) == 0) {
</span>        invoke_cgi_script(client);
    }
    else {
        uv_close((uv_handle_t*) client, NULL);
    }
</pre></div>
</td></tr></table></div>
<p>Here we simply accept the TCP connection and pass on the socket (<em>stream</em>) to
<code class="docutils literal notranslate"><span class="pre">invoke_cgi_script</span></code>.</p>
<p class="rubric">cgi/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="o">/*</span> <span class="o">...</span> <span class="n">finding</span> <span class="n">the</span> <span class="n">executable</span> <span class="n">path</span> <span class="ow">and</span> <span class="n">setting</span> <span class="n">up</span> <span class="n">arguments</span> <span class="o">...</span> <span class="o">*/</span>

    <span class="n">options</span><span class="o">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_STREAM</span><span class="p">;</span>
</span>    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
    <span class="n">options</span><span class="o">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>

    <span class="n">options</span><span class="o">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">cleanup_handles</span><span class="p">;</span>
    <span class="n">options</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">options</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

<span class="hll">    <span class="o">//</span> <span class="n">Set</span> <span class="n">this</span> <span class="n">so</span> <span class="n">we</span> <span class="n">can</span> <span class="n">close</span> <span class="n">the</span> <span class="n">socket</span> <span class="n">after</span> <span class="n">the</span> <span class="n">child</span> <span class="n">process</span> <span class="n">exits</span><span class="o">.</span>
</span>    <span class="n">child_req</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
<span class="hll">    <span class="nb">int</span> <span class="n">r</span><span class="p">;</span>
</span>    <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">stdout</span></code> of the CGI script is set to the socket so that whatever our tick
script prints, gets sent to the client. By using processes, we can offload the
read/write buffering to the operating system, so in terms of convenience this
is great. Just be warned that creating processes is a costly task.</p>
</div>
<div class="section" id="pipes">
<span id="id1"></span><h5>Pipes<a class="headerlink" href="#pipes" title="Permalink to this headline">¶</a></h5>
<p>libuv’s <code class="docutils literal notranslate"><span class="pre">uv_pipe_t</span></code> structure is slightly confusing to Unix programmers,
because it immediately conjures up <code class="docutils literal notranslate"><span class="pre">|</span></code> and <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man7/pipe.7.html">pipe(7)</a>. But <code class="docutils literal notranslate"><span class="pre">uv_pipe_t</span></code> is
not related to anonymous pipes, rather it is an IPC mechanism. <code class="docutils literal notranslate"><span class="pre">uv_pipe_t</span></code>
can be backed by a <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man7/unix.7.html">Unix Domain Socket</a> or <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365590(v=vs.85).aspx">Windows Named Pipe</a> to allow
multiple processes to communicate. This is discussed below.</p>
<div class="section" id="parent-child-ipc">
<h6>Parent-child IPC<a class="headerlink" href="#parent-child-ipc" title="Permalink to this headline">¶</a></h6>
<p>A parent and child can have one or two way communication over a pipe created by
settings <code class="docutils literal notranslate"><span class="pre">uv_stdio_container_t.flags</span></code> to a bit-wise combination of
<code class="docutils literal notranslate"><span class="pre">UV_CREATE_PIPE</span></code> and <code class="docutils literal notranslate"><span class="pre">UV_READABLE_PIPE</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_WRITABLE_PIPE</span></code>. The
read/write flag is from the perspective of the child process.</p>
</div>
<div class="section" id="arbitrary-process-ipc">
<h6>Arbitrary process IPC<a class="headerlink" href="#arbitrary-process-ipc" title="Permalink to this headline">¶</a></h6>
<p>Since domain sockets <a class="footnote-reference" href="#id3" id="id2">[1]</a> can have a well known name and a location in the
file-system they can be used for IPC between unrelated processes. The <a class="reference external" href="http://www.freedesktop.org/wiki/Software/dbus">D-BUS</a>
system used by open source desktop environments uses domain sockets for event
notification. Various applications can then react when a contact comes online
or new hardware is detected. The MySQL server also runs a domain socket on
which clients can interact with it.</p>
<p>When using domain sockets, a client-server pattern is usually followed with the
creator/owner of the socket acting as the server. After the initial setup,
messaging is no different from TCP, so we’ll re-use the echo server example.</p>
<p class="rubric">pipe-echo-server/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">remove_sock</span><span class="p">(</span><span class="nb">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uv_fs_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">uv_fs_unlink</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">PIPENAME</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="hll"><span class="p">}</span>
</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_pipe_t</span> <span class="n">server</span><span class="p">;</span>
</span>    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">remove_sock</span><span class="p">);</span>
<span class="hll">
</span>    <span class="nb">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">uv_pipe_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">PIPENAME</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Bind error </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Listen error </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We name the socket <code class="docutils literal notranslate"><span class="pre">echo.sock</span></code> which means it will be created in the local
directory. This socket now behaves no different from TCP sockets as far as
the stream API is concerned. You can test this server using <a class="reference external" href="http://www.dest-unreach.org/socat/">socat</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ socat - /path/to/socket
</pre></div>
</div>
<p>A client which wants to connect to a domain socket will use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">uv_pipe_connect</span><span class="p">(</span><span class="n">uv_connect_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">uv_connect_cb</span> <span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">name</span></code> will be <code class="docutils literal notranslate"><span class="pre">echo.sock</span></code> or similar. On Unix systems, <code class="docutils literal notranslate"><span class="pre">name</span></code> must
point to a valid file (e.g. <code class="docutils literal notranslate"><span class="pre">/tmp/echo.sock</span></code>). On Windows, <code class="docutils literal notranslate"><span class="pre">name</span></code> follows a
<code class="docutils literal notranslate"><span class="pre">\\?\pipe\echo.sock</span></code> format.</p>
</div>
<div class="section" id="sending-file-descriptors-over-pipes">
<h6>Sending file descriptors over pipes<a class="headerlink" href="#sending-file-descriptors-over-pipes" title="Permalink to this headline">¶</a></h6>
<p>The cool thing about domain sockets is that file descriptors can be exchanged
between processes by sending them over a domain socket. This allows processes
to hand off their I/O to other processes. Applications include load-balancing
servers, worker processes and other ways to make optimum use of CPU. libuv only
supports sending <strong>TCP sockets or other pipes</strong> over pipes for now.</p>
<p>To demonstrate, we will look at a echo server implementation that hands of
clients to worker processes in a round-robin fashion. This program is a bit
involved, and while only snippets are included in the book, it is recommended
to read the full code to really understand it.</p>
<p>The worker process is quite simple, since the file-descriptor is handed over to
it by the master.</p>
<p class="rubric">multi-echo-server/worker.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_pipe_t</span> <span class="n">queue</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>
<span class="hll">
</span><span class="hll">    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/*</span> <span class="n">ipc</span> <span class="o">*/</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_pipe_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>    <span class="n">uv_read_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">queue</span></code> is the pipe connected to the master process on the other end, along
which new file descriptors get sent. It is important to set the <code class="docutils literal notranslate"><span class="pre">ipc</span></code>
argument of <code class="docutils literal notranslate"><span class="pre">uv_pipe_init</span></code> to 1 to indicate this pipe will be used for
inter-process communication! Since the master will write the file handle to the
standard input of the worker, we connect the pipe to <code class="docutils literal notranslate"><span class="pre">stdin</span></code> using
<code class="docutils literal notranslate"><span class="pre">uv_pipe_open</span></code>.</p>
<p class="rubric">multi-echo-server/worker.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>void on_new_connection(uv_stream_t *q, ssize_t nread, const uv_buf_t *buf) {
    if (nread &lt; 0) {
        if (nread != UV_EOF)
            fprintf(stderr, &quot;Read error %s\n&quot;, uv_err_name(nread));
        uv_close((uv_handle_t*) q, NULL);
        return;
    }

    uv_pipe_t *pipe = (uv_pipe_t*) q;
<span class="hll">    if (!uv_pipe_pending_count(pipe)) {
</span>        fprintf(stderr, &quot;No pending count\n&quot;);
        return;
    }

<span class="hll">    uv_handle_type pending = uv_pipe_pending_type(pipe);
</span>    assert(pending == UV_TCP);

    uv_tcp_t *client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
    uv_tcp_init(loop, client);
<span class="hll">    if (uv_accept(q, (uv_stream_t*) client) == 0) {
</span>        uv_os_fd_t fd;
        uv_fileno((const uv_handle_t*) client, &amp;fd);
        fprintf(stderr, &quot;Worker %d: Accepted fd %d\n&quot;, getpid(), fd);
        uv_read_start((uv_stream_t*) client, alloc_buffer, echo_read);
    }
    else {
        uv_close((uv_handle_t*) client, NULL);
    }
}
</pre></div>
</td></tr></table></div>
<p>First we call <code class="docutils literal notranslate"><span class="pre">uv_pipe_pending_count()</span></code> to ensure that a handle is available
to read out. If your program could deal with different types of handles,
<code class="docutils literal notranslate"><span class="pre">uv_pipe_pending_type()</span></code> can be used to determine the type.
Although <code class="docutils literal notranslate"><span class="pre">accept</span></code> seems odd in this code, it actually makes sense. What
<code class="docutils literal notranslate"><span class="pre">accept</span></code> traditionally does is get a file descriptor (the client) from
another file descriptor (The listening socket). Which is exactly what we do
here. Fetch the file descriptor (<code class="docutils literal notranslate"><span class="pre">client</span></code>) from <code class="docutils literal notranslate"><span class="pre">queue</span></code>. From this point
the worker does standard echo server stuff.</p>
<p>Turning now to the master, let’s take a look at how the workers are launched to
allow load balancing.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">child_worker</span> <span class="p">{</span>
    <span class="n">uv_process_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">uv_process_options_t</span> <span class="n">options</span><span class="p">;</span>
    <span class="n">uv_pipe_t</span> <span class="n">pipe</span><span class="p">;</span>
<span class="p">}</span> <span class="o">*</span><span class="n">workers</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">child_worker</span></code> structure wraps the process, and the pipe between the
master and the individual process.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">setup_workers</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">round_robin_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="o">//</span> <span class="o">...</span>

    <span class="o">//</span> <span class="n">launch</span> <span class="n">same</span> <span class="n">number</span> <span class="n">of</span> <span class="n">workers</span> <span class="k">as</span> <span class="n">number</span> <span class="n">of</span> <span class="n">CPUs</span>
    <span class="n">uv_cpu_info_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">cpu_count</span><span class="p">;</span>
    <span class="n">uv_cpu_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_count</span><span class="p">);</span>
    <span class="n">uv_free_cpu_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">);</span>

    <span class="n">child_worker_count</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">;</span>

    <span class="n">workers</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">child_worker</span><span class="p">),</span> <span class="n">cpu_count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cpu_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">struct</span> <span class="n">child_worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">workers</span><span class="p">[</span><span class="n">cpu_count</span><span class="p">];</span>
<span class="hll">        <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span>
        <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="hll">        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_CREATE_PIPE</span> <span class="o">|</span> <span class="n">UV_READABLE_PIPE</span><span class="p">;</span>
</span><span class="hll">        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
</span>        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_FD</span><span class="p">;</span>
        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="o">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="o">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="o">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">close_process_handle</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

        <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">);</span> 
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Started worker </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">req</span><span class="o">.</span><span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In setting up the workers, we use the nifty libuv function <code class="docutils literal notranslate"><span class="pre">uv_cpu_info</span></code> to
get the number of CPUs so we can launch an equal number of workers. Again it is
important to initialize the pipe acting as the IPC channel with the third
argument as 1. We then indicate that the child process’ <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is to be
a readable pipe (from the point of view of the child). Everything is
straightforward till here. The workers are launched and waiting for file
descriptors to be written to their standard input.</p>
<p>It is in <code class="docutils literal notranslate"><span class="pre">on_new_connection</span></code> (the TCP infrastructure is initialized in
<code class="docutils literal notranslate"><span class="pre">main()</span></code>), that we accept the client socket and pass it along to the next
worker in the round-robin.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>void on_new_connection(uv_stream_t *server, int status) {
    if (status == -1) {
        // error!
        return;
    }

    uv_tcp_t *client = (uv_tcp_t*) malloc(sizeof(uv_tcp_t));
    uv_tcp_init(loop, client);
<span class="hll">    if (uv_accept(server, (uv_stream_t*) client) == 0) {
</span>        uv_write_t *write_req = (uv_write_t*) malloc(sizeof(uv_write_t));
        dummy_buf = uv_buf_init(&quot;a&quot;, 1);
<span class="hll">        struct child_worker *worker = &amp;workers[round_robin_counter];
</span><span class="hll">        uv_write2(write_req, (uv_stream_t*) &amp;worker-&gt;pipe, &amp;dummy_buf, 1, (uv_stream_t*) client, NULL);
</span>        round_robin_counter = (round_robin_counter + 1) % child_worker_count;
    }
    else {
        uv_close((uv_handle_t*) client, NULL);
    }
}
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">uv_write2</span></code> call handles all the abstraction and it is simply a matter of
passing in the handle (<code class="docutils literal notranslate"><span class="pre">client</span></code>) as the right argument. With this our
multi-process echo server is operational.</p>
<p>Thanks to Kyle for <a class="reference external" href="https://github.com/nikhilm/uvbook/issues/56">pointing out</a> that <code class="docutils literal notranslate"><span class="pre">uv_write2()</span></code> requires a non-empty
buffer even when sending handles.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>In this section domain sockets stands in for named pipes on Windows as
well.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<span id="document-guide/eventloops"></span><div class="section" id="advanced-event-loops">
<h4>Advanced event loops<a class="headerlink" href="#advanced-event-loops" title="Permalink to this headline">¶</a></h4>
<p>libuv provides considerable user control over event loops, and you can achieve
interesting results by juggling multiple loops. You can also embed libuv’s
event loop into another event loop based library – imagine a Qt based UI, and
Qt’s event loop driving a libuv backend which does intensive system level
tasks.</p>
<div class="section" id="stopping-an-event-loop">
<h5>Stopping an event loop<a class="headerlink" href="#stopping-an-event-loop" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code> can be used to stop an event loop. The earliest the loop will
stop running is <em>on the next iteration</em>, possibly later. This means that events
that are ready to be processed in this iteration of the loop will still be
processed, so <code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code> can’t be used as a kill switch. When <code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code>
is called, the loop <strong>won’t</strong> block for i/o on this iteration. The semantics of
these things can be a bit difficult to understand, so let’s look at
<code class="docutils literal notranslate"><span class="pre">uv_run()</span></code> where all the control flow occurs.</p>
<p class="rubric">src/unix/core.c - uv_run</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span>

int uv_is_closing(const uv_handle_t* handle) {
  return uv__is_closing(handle);
}


int uv_backend_fd(const uv_loop_t* loop) {
  return loop-&gt;backend_fd;
<span class="hll">}
</span>

int uv_backend_timeout(const uv_loop_t* loop) {
  if (loop-&gt;stop_flag != 0)
    return 0;

  if (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop))
    return 0;
<span class="hll">
</span>  if (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles))
<span class="hll">    return 0;
</span></pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">stop_flag</span></code> is set by <code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code>. Now all libuv callbacks are invoked
within the event loop, which is why invoking <code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code> in them will still
lead to this iteration of the loop occurring. First libuv updates timers, then
runs pending timer, idle and prepare callbacks, and invokes any pending I/O
callbacks. If you were to call <code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code> in any of them, <code class="docutils literal notranslate"><span class="pre">stop_flag</span></code>
would be set. This causes <code class="docutils literal notranslate"><span class="pre">uv_backend_timeout()</span></code> to return <code class="docutils literal notranslate"><span class="pre">0</span></code>, which is
why the loop does not block on I/O. If on the other hand, you called
<code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code> in one of the check handlers, I/O has already finished and is not
affected.</p>
<p><code class="docutils literal notranslate"><span class="pre">uv_stop()</span></code> is useful to shutdown a loop when a result has been computed or
there is an error, without having to ensure that all handlers are stopped one
by one.</p>
<p>Here is a simple example that stops the loop and demonstrates how the current
iteration of the loop still takes places.</p>
<p class="rubric">uvstop/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="n">int64_t</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">idle_cb</span><span class="p">(</span><span class="n">uv_idle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Idle callback</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">uv_stop</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">());</span>
</span>        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;uv_stop() called</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">prep_cb</span><span class="p">(</span><span class="n">uv_prepare_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Prep callback</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uv_idle_t</span> <span class="n">idler</span><span class="p">;</span>
    <span class="n">uv_prepare_t</span> <span class="n">prep</span><span class="p">;</span>

    <span class="n">uv_idle_init</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">idler</span><span class="p">);</span>
    <span class="n">uv_idle_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idler</span><span class="p">,</span> <span class="n">idle_cb</span><span class="p">);</span>

    <span class="n">uv_prepare_init</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">prep</span><span class="p">);</span>
    <span class="n">uv_prepare_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep</span><span class="p">,</span> <span class="n">prep_cb</span><span class="p">);</span>

    <span class="n">uv_run</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">(),</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<span id="document-guide/utilities"></span><div class="section" id="utilities">
<h4>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h4>
<p>This chapter catalogues tools and techniques which are useful for common tasks.
The <a class="reference external" href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#COMMON_OR_USEFUL_IDIOMS_OR_BOTH">libev man page</a> already covers some patterns which can be adopted to
libuv through simple API changes. It also covers parts of the libuv API that
don’t require entire chapters dedicated to them.</p>
<div class="section" id="timers">
<h5>Timers<a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h5>
<p>Timers invoke the callback after a certain time has elapsed since the timer was
started. libuv timers can also be set to invoke at regular intervals instead of
just once.</p>
<p>Simple use is to init a watcher and start it with a <code class="docutils literal notranslate"><span class="pre">timeout</span></code>, and optional <code class="docutils literal notranslate"><span class="pre">repeat</span></code>.
Timers can be stopped at any time.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">uv_timer_t</span> <span class="n">timer_req</span><span class="p">;</span>

<span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer_req</span><span class="p">);</span>
<span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_req</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
</pre></div>
</div>
<p>will start a repeating timer, which first starts 5 seconds (the <code class="docutils literal notranslate"><span class="pre">timeout</span></code>) after the execution
of <code class="docutils literal notranslate"><span class="pre">uv_timer_start</span></code>, then repeats every 2 seconds (the <code class="docutils literal notranslate"><span class="pre">repeat</span></code>). Use:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">uv_timer_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer_req</span><span class="p">);</span>
</pre></div>
</div>
<p>to stop the timer. This can be used safely from within the callback as well.</p>
<p>The repeat interval can be modified at any time with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_timer_set_repeat</span><span class="p">(</span><span class="n">uv_timer_t</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">repeat</span><span class="p">);</span>
</pre></div>
</div>
<p>which will take effect <strong>when possible</strong>. If this function is called from
a timer callback, it means:</p>
<ul class="simple">
<li>If the timer was non-repeating, the timer has already been stopped. Use
<code class="docutils literal notranslate"><span class="pre">uv_timer_start</span></code> again.</li>
<li>If the timer is repeating, the next timeout has already been scheduled, so
the old repeat interval will be used once more before the timer switches to
the new interval.</li>
</ul>
<p>The utility function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">uv_timer_again</span><span class="p">(</span><span class="n">uv_timer_t</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>applies <strong>only to repeating timers</strong> and is equivalent to stopping the timer
and then starting it with both initial <code class="docutils literal notranslate"><span class="pre">timeout</span></code> and <code class="docutils literal notranslate"><span class="pre">repeat</span></code> set to the
old <code class="docutils literal notranslate"><span class="pre">repeat</span></code> value. If the timer hasn’t been started it fails (error code
<code class="docutils literal notranslate"><span class="pre">UV_EINVAL</span></code>) and returns -1.</p>
<p>An actual timer example is in the <a class="reference internal" href="#reference-count"><span class="std std-ref">reference count section</span></a>.</p>
</div>
<div class="section" id="event-loop-reference-count">
<span id="reference-count"></span><h5>Event loop reference count<a class="headerlink" href="#event-loop-reference-count" title="Permalink to this headline">¶</a></h5>
<p>The event loop only runs as long as there are active handles. This system
works by having every handle increase the reference count of the event loop
when it is started and decreasing the reference count when stopped. It is also
possible to manually change the reference count of handles using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">uv_ref</span><span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">);</span>
<span class="n">void</span> <span class="n">uv_unref</span><span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>These functions can be used to allow a loop to exit even when a watcher is
active or to use custom objects to keep the loop alive.</p>
<p>The latter can be used with interval timers. You might have a garbage collector
which runs every X seconds, or your network service might send a heartbeat to
others periodically, but you don’t want to have to stop them along all clean
exit paths or error scenarios. Or you want the program to exit when all your
other watchers are done. In that case just unref the timer immediately after
creation so that if it is the only watcher running then <code class="docutils literal notranslate"><span class="pre">uv_run</span></code> will still
exit.</p>
<p>This is also used in node.js where some libuv methods are being bubbled up to
the JS API. A <code class="docutils literal notranslate"><span class="pre">uv_handle_t</span></code> (the superclass of all watchers) is created per
JS object and can be ref/unrefed.</p>
<p class="rubric">ref-timer/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_timer_t</span> <span class="n">gc_req</span><span class="p">;</span>
<span class="n">uv_timer_t</span> <span class="n">fake_job_req</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_req</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_unref</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gc_req</span><span class="p">);</span>
</span>
    <span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gc_req</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">could</span> <span class="n">actually</span> <span class="n">be</span> <span class="n">a</span> <span class="n">TCP</span> <span class="n">download</span> <span class="ow">or</span> <span class="n">something</span>
    <span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_job_req</span><span class="p">);</span>
    <span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_job_req</span><span class="p">,</span> <span class="n">fake_job</span><span class="p">,</span> <span class="mi">9000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We initialize the garbage collector timer, then immediately <code class="docutils literal notranslate"><span class="pre">unref</span></code> it.
Observe how after 9 seconds, when the fake job is done, the program
automatically exits, even though the garbage collector is still running.</p>
</div>
<div class="section" id="idler-pattern">
<h5>Idler pattern<a class="headerlink" href="#idler-pattern" title="Permalink to this headline">¶</a></h5>
<p>The callbacks of idle handles are invoked once per event loop. The idle
callback can be used to perform some very low priority activity. For example,
you could dispatch a summary of the daily application performance to the
developers for analysis during periods of idleness, or use the application’s
CPU time to perform SETI calculations :) An idle watcher is also useful in
a GUI application. Say you are using an event loop for a file download. If the
TCP socket is still being established and no other events are present your
event loop will pause (<strong>block</strong>), which means your progress bar will freeze
and the user will face an unresponsive application. In such a case queue up and
idle watcher to keep the UI operational.</p>
<p class="rubric">idle-compute/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_fs_t</span> <span class="n">stdin_watcher</span><span class="p">;</span>
<span class="n">uv_idle_t</span> <span class="n">idler</span><span class="p">;</span>
<span class="n">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_idle_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idler</span><span class="p">);</span>

    <span class="n">uv_buf_t</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">uv_buf_init</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
    <span class="n">uv_fs_read</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stdin_watcher</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_type</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_idle_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idler</span><span class="p">,</span> <span class="n">crunch_away</span><span class="p">);</span>
</span>    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Here we initialize the idle watcher and queue it up along with the actual
events we are interested in. <code class="docutils literal notranslate"><span class="pre">crunch_away</span></code> will now be called repeatedly
until the user types something and presses Return. Then it will be interrupted
for a brief amount as the loop deals with the input data, after which it will
keep calling the idle callback again.</p>
<p class="rubric">idle-compute/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">crunch_away</span><span class="p">(</span><span class="n">uv_idle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Compute</span> <span class="n">extra</span><span class="o">-</span><span class="n">terrestrial</span> <span class="n">life</span>
    <span class="o">//</span> <span class="n">fold</span> <span class="n">proteins</span>
    <span class="o">//</span> <span class="n">computer</span> <span class="n">another</span> <span class="n">digit</span> <span class="n">of</span> <span class="n">PI</span>
    <span class="o">//</span> <span class="ow">or</span> <span class="n">similar</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Computing PI...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">just</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">overwhelming</span> <span class="n">your</span> <span class="n">terminal</span> <span class="n">emulator</span>
    <span class="n">uv_idle_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="passing-data-to-worker-thread">
<span id="baton"></span><h5>Passing data to worker thread<a class="headerlink" href="#passing-data-to-worker-thread" title="Permalink to this headline">¶</a></h5>
<p>When using <code class="docutils literal notranslate"><span class="pre">uv_queue_work</span></code> you’ll usually need to pass complex data through
to the worker thread. The solution is to use a <code class="docutils literal notranslate"><span class="pre">struct</span></code> and set
<code class="docutils literal notranslate"><span class="pre">uv_work_t.data</span></code> to point to it. A slight variation is to have the
<code class="docutils literal notranslate"><span class="pre">uv_work_t</span></code> itself as the first member of this struct (called a baton <a class="footnote-reference" href="#id3" id="id1">[1]</a>).
This allows cleaning up the work request and all the data in one free call.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ftp_baton</span> <span class="p">{</span>
<span class="hll">    <span class="n">uv_work_t</span> <span class="n">req</span><span class="p">;</span>
</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">ftp_baton</span> <span class="o">*</span><span class="n">baton</span> <span class="o">=</span> <span class="p">(</span><span class="n">ftp_baton</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ftp_baton</span><span class="p">));</span>
<span class="hll"><span class="n">baton</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">baton</span><span class="p">;</span>
</span><span class="n">baton</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">&quot;my.webhost.com&quot;</span><span class="p">);</span>
<span class="n">baton</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="n">uv_queue_work</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baton</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">ftp_session</span><span class="p">,</span> <span class="n">ftp_cleanup</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Here we create the baton and queue the task.</p>
<p>Now the task function can extract the data it needs:</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">ftp_session</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="n">ftp_baton</span> <span class="o">*</span><span class="n">baton</span> <span class="o">=</span> <span class="p">(</span><span class="n">ftp_baton</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Connecting to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">baton</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ftp_cleanup</span><span class="p">(</span><span class="n">uv_work_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ftp_baton</span> <span class="o">*</span><span class="n">baton</span> <span class="o">=</span> <span class="p">(</span><span class="n">ftp_baton</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

    <span class="n">free</span><span class="p">(</span><span class="n">baton</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="hll">    <span class="n">free</span><span class="p">(</span><span class="n">baton</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We then free the baton which also frees the watcher.</p>
</div>
<div class="section" id="external-i-o-with-polling">
<h5>External I/O with polling<a class="headerlink" href="#external-i-o-with-polling" title="Permalink to this headline">¶</a></h5>
<p>Usually third-party libraries will handle their own I/O, and keep track of
their sockets and other files internally. In this case it isn’t possible to use
the standard stream I/O operations, but the library can still be integrated
into the libuv event loop. All that is required is that the library allow you
to access the underlying file descriptors and provide functions that process
tasks in small increments as decided by your application. Some libraries though
will not allow such access, providing only a standard blocking function which
will perform the entire I/O transaction and only then return. It is unwise to
use these in the event loop thread, use the <span class="xref std std-ref">libuv-work-queue</span> instead. Of
course, this will also mean losing granular control on the library.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">uv_poll</span></code> section of libuv simply watches file descriptors using the
operating system notification mechanism. In some sense, all the I/O operations
that libuv implements itself are also backed by <code class="docutils literal notranslate"><span class="pre">uv_poll</span></code> like code. Whenever
the OS notices a change of state in file descriptors being polled, libuv will
invoke the associated callback.</p>
<p>Here we will walk through a simple download manager that will use <a class="reference external" href="http://curl.haxx.se/libcurl/">libcurl</a> to
download files. Rather than give all control to libcurl, we’ll instead be
using the libuv event loop, and use the non-blocking, async <a class="reference external" href="http://curl.haxx.se/libcurl/c/libcurl-multi.html">multi</a> interface to
progress with the download whenever libuv notifies of I/O readiness.</p>
<p class="rubric">uvwget/main.c - The setup</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;assert.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>
<span class="c1">#include &lt;curl/curl.h&gt;</span>

<span class="hll"><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
</span><span class="n">CURLM</span> <span class="o">*</span><span class="n">curl_handle</span><span class="p">;</span>
<span class="n">uv_timer_t</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">curl_global_init</span><span class="p">(</span><span class="n">CURL_GLOBAL_ALL</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Could not init cURL</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="hll">    <span class="p">}</span>
</span>
    <span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
<span class="hll">
</span><span class="hll">    <span class="n">curl_handle</span> <span class="o">=</span> <span class="n">curl_multi_init</span><span class="p">();</span>
</span>    <span class="n">curl_multi_setopt</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="n">CURLMOPT_SOCKETFUNCTION</span><span class="p">,</span> <span class="n">handle_socket</span><span class="p">);</span>
    <span class="n">curl_multi_setopt</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="n">CURLMOPT_TIMERFUNCTION</span><span class="p">,</span> <span class="n">start_timeout</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">add_download</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">],</span> <span class="n">argc</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
    <span class="n">curl_multi_cleanup</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The way each library is integrated with libuv will vary. In the case of
libcurl, we can register two callbacks. The socket callback <code class="docutils literal notranslate"><span class="pre">handle_socket</span></code>
is invoked whenever the state of a socket changes and we have to start polling
it. <code class="docutils literal notranslate"><span class="pre">start_timeout</span></code> is called by libcurl to notify us of the next timeout
interval, after which we should drive libcurl forward regardless of I/O status.
This is so that libcurl can handle errors or do whatever else is required to
get the download moving.</p>
<p>Our downloader is to be invoked as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./uvwget [url1] [url2] ...
</pre></div>
</div>
<p>So we add each argument as an URL</p>
<p class="rubric">uvwget/main.c - Adding urls</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">add_download</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span> <span class="nb">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.download&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="n">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

    <span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Error opening </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

<span class="hll">    <span class="n">CURL</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">curl_easy_init</span><span class="p">();</span>
</span><span class="hll">    <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CURLOPT_WRITEDATA</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
</span>    <span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CURLOPT_URL</span><span class="p">,</span> <span class="n">url</span><span class="p">);</span>
    <span class="n">curl_multi_add_handle</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Added download </span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We let libcurl directly write the data to a file, but much more is possible if
you so desire.</p>
<p><code class="docutils literal notranslate"><span class="pre">start_timeout</span></code> will be called immediately the first time by libcurl, so
things are set in motion. This simply starts a libuv <a class="reference external" href="Timers">timer</a> which
drives <code class="docutils literal notranslate"><span class="pre">curl_multi_socket_action</span></code> with <code class="docutils literal notranslate"><span class="pre">CURL_SOCKET_TIMEOUT</span></code> whenever it
times out. <code class="docutils literal notranslate"><span class="pre">curl_multi_socket_action</span></code> is what drives libcurl, and what we
call whenever sockets change state. But before we go into that, we need to poll
on sockets whenever <code class="docutils literal notranslate"><span class="pre">handle_socket</span></code> is called.</p>
<p class="rubric">uvwget/main.c - Setting up polling</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
<span class="n">void</span> <span class="n">start_timeout</span><span class="p">(</span><span class="n">CURLM</span> <span class="o">*</span><span class="n">multi</span><span class="p">,</span> <span class="n">long</span> <span class="n">timeout_ms</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">timeout_ms</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">timeout_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">/*</span> <span class="mi">0</span> <span class="n">means</span> <span class="n">directly</span> <span class="n">call</span> <span class="n">socket_action</span><span class="p">,</span> <span class="n">but</span> <span class="n">we</span><span class="s1">&#39;ll do it in a bit */</span>
    <span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">on_timeout</span><span class="p">,</span> <span class="n">timeout_ms</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">handle_socket</span><span class="p">(</span><span class="n">CURL</span> <span class="o">*</span><span class="n">easy</span><span class="p">,</span> <span class="n">curl_socket_t</span> <span class="n">s</span><span class="p">,</span> <span class="nb">int</span> <span class="n">action</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">socketp</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="n">curl_context_t</span> <span class="o">*</span><span class="n">curl_context</span><span class="p">;</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">CURL_POLL_IN</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">CURL_POLL_OUT</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="k">if</span> <span class="p">(</span><span class="n">socketp</span><span class="p">)</span> <span class="p">{</span>
</span>            <span class="n">curl_context</span> <span class="o">=</span> <span class="p">(</span><span class="n">curl_context_t</span><span class="o">*</span><span class="p">)</span> <span class="n">socketp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
<span class="hll">            <span class="n">curl_context</span> <span class="o">=</span> <span class="n">create_curl_context</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span>            <span class="n">curl_multi_assign</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">curl_context</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">case</span> <span class="n">CURL_POLL_IN</span><span class="p">:</span>
</span>            <span class="n">uv_poll_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curl_context</span><span class="o">-&gt;</span><span class="n">poll_handle</span><span class="p">,</span> <span class="n">UV_READABLE</span><span class="p">,</span> <span class="n">curl_perform</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
<span class="hll">        <span class="n">case</span> <span class="n">CURL_POLL_OUT</span><span class="p">:</span>
</span>            <span class="n">uv_poll_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curl_context</span><span class="o">-&gt;</span><span class="n">poll_handle</span><span class="p">,</span> <span class="n">UV_WRITABLE</span><span class="p">,</span> <span class="n">curl_perform</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">case</span> <span class="n">CURL_POLL_REMOVE</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">socketp</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">uv_poll_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">curl_context_t</span><span class="o">*</span><span class="p">)</span><span class="n">socketp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">poll_handle</span><span class="p">);</span>
                <span class="n">destroy_curl_context</span><span class="p">((</span><span class="n">curl_context_t</span><span class="o">*</span><span class="p">)</span> <span class="n">socketp</span><span class="p">);</span>                
                <span class="n">curl_multi_assign</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">default</span><span class="p">:</span>
            <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We are interested in the socket fd <code class="docutils literal notranslate"><span class="pre">s</span></code>, and the <code class="docutils literal notranslate"><span class="pre">action</span></code>. For every socket
we create a <code class="docutils literal notranslate"><span class="pre">uv_poll_t</span></code> handle if it doesn’t exist, and associate it with the
socket using <code class="docutils literal notranslate"><span class="pre">curl_multi_assign</span></code>. This way <code class="docutils literal notranslate"><span class="pre">socketp</span></code> points to it whenever
the callback is invoked.</p>
<p>In the case that the download is done or fails, libcurl requests removal of the
poll. So we stop and free the poll handle.</p>
<p>Depending on what events libcurl wishes to watch for, we start polling with
<code class="docutils literal notranslate"><span class="pre">UV_READABLE</span></code> or <code class="docutils literal notranslate"><span class="pre">UV_WRITABLE</span></code>. Now libuv will invoke the poll callback
whenever the socket is ready for reading or writing. Calling <code class="docutils literal notranslate"><span class="pre">uv_poll_start</span></code>
multiple times on the same handle is acceptable, it will just update the events
mask with the new value. <code class="docutils literal notranslate"><span class="pre">curl_perform</span></code> is the crux of this program.</p>
<p class="rubric">uvwget/main.c - Driving libcurl.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span>void curl_perform(uv_poll_t *req, int status, int events) {
<span class="hll">    uv_timer_stop(&amp;timeout);
</span>    int running_handles;
    int flags = 0;
    if (status &lt; 0)                      flags = CURL_CSELECT_ERR;
<span class="hll">    if (!status &amp;&amp; events &amp; UV_READABLE) flags |= CURL_CSELECT_IN;
</span><span class="hll">    if (!status &amp;&amp; events &amp; UV_WRITABLE) flags |= CURL_CSELECT_OUT;
</span>
    curl_context_t *context;

    context = (curl_context_t*)req;
<span class="hll">
</span>    curl_multi_socket_action(curl_handle, context-&gt;sockfd, flags, &amp;running_handles);
    check_multi_info();   
}
</pre></div>
</td></tr></table></div>
<p>The first thing we do is to stop the timer, since there has been some progress
in the interval. Then depending on what event triggered the callback, we set
the correct flags. Then we call <code class="docutils literal notranslate"><span class="pre">curl_multi_socket_action</span></code> with the socket
that progressed and the flags informing about what events happened. At this
point libcurl does all of its internal tasks in small increments, and will
attempt to return as fast as possible, which is exactly what an evented program
wants in its main thread. libcurl keeps queueing messages into its own queue
about transfer progress. In our case we are only interested in transfers that
are completed. So we extract these messages, and clean up handles whose
transfers are done.</p>
<p class="rubric">uvwget/main.c - Reading transfer status.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">check_multi_info</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">done_url</span><span class="p">;</span>
    <span class="n">CURLMsg</span> <span class="o">*</span><span class="n">message</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">pending</span><span class="p">;</span>

<span class="hll">    <span class="k">while</span> <span class="p">((</span><span class="n">message</span> <span class="o">=</span> <span class="n">curl_multi_info_read</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="p">)))</span> <span class="p">{</span>
</span>        <span class="n">switch</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">CURLMSG_DONE</span><span class="p">:</span>
<span class="hll">            <span class="n">curl_easy_getinfo</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">easy_handle</span><span class="p">,</span> <span class="n">CURLINFO_EFFECTIVE_URL</span><span class="p">,</span>
</span><span class="hll">                            <span class="o">&amp;</span><span class="n">done_url</span><span class="p">);</span>
</span>            <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> DONE</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">done_url</span><span class="p">);</span>

<span class="hll">            <span class="n">curl_multi_remove_handle</span><span class="p">(</span><span class="n">curl_handle</span><span class="p">,</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">easy_handle</span><span class="p">);</span>
</span><span class="hll">            <span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">easy_handle</span><span class="p">);</span>
</span>            <span class="k">break</span><span class="p">;</span>

        <span class="n">default</span><span class="p">:</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;CURLMSG default</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
            <span class="n">abort</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="check-prepare-watchers">
<h5>Check &amp; Prepare watchers<a class="headerlink" href="#check-prepare-watchers" title="Permalink to this headline">¶</a></h5>
<p>TODO</p>
</div>
<div class="section" id="loading-libraries">
<h5>Loading libraries<a class="headerlink" href="#loading-libraries" title="Permalink to this headline">¶</a></h5>
<p>libuv provides a cross platform API to dynamically load <a class="reference external" href="http://en.wikipedia.org/wiki/Shared_library#Shared_libraries">shared libraries</a>.
This can be used to implement your own plugin/extension/module system and is
used by node.js to implement <code class="docutils literal notranslate"><span class="pre">require()</span></code> support for bindings. The usage is
quite simple as long as your library exports the right symbols. Be careful with
sanity and security checks when loading third party code, otherwise your
program will behave unpredictably. This example implements a very simple
plugin system which does nothing except print the name of the plugin.</p>
<p>Let us first look at the interface provided to plugin authors.</p>
<p class="rubric">plugin/plugin.h</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#ifndef UVBOOK_PLUGIN_SYSTEM</span>
<span class="c1">#define UVBOOK_PLUGIN_SYSTEM</span>

<span class="o">//</span> <span class="n">Plugin</span> <span class="n">authors</span> <span class="n">should</span> <span class="n">use</span> <span class="n">this</span> <span class="n">to</span> <span class="n">register</span> <span class="n">their</span> <span class="n">plugins</span> <span class="k">with</span> <span class="n">mfp</span><span class="o">.</span>
<span class="n">void</span> <span class="n">mfp_register</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="c1">#endif</span>
</pre></div>
</td></tr></table></div>
<p>You can similarly add more functions that plugin authors can use to do useful
things in your application <a class="footnote-reference" href="#id4" id="id2">[2]</a>. A sample plugin using this API is:</p>
<p class="rubric">plugin/hello.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &quot;plugin.h&quot;</span>

<span class="n">void</span> <span class="n">initialize</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mfp_register</span><span class="p">(</span><span class="s2">&quot;Hello World!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Our interface defines that all plugins should have an <code class="docutils literal notranslate"><span class="pre">initialize</span></code> function
which will be called by the application. This plugin is compiled as a shared
library and can be loaded by running our application:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./plugin libhello.dylib
Loading libhello.dylib
Registered plugin &quot;Hello World!&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The shared library filename will be different depending on platforms. On
Linux it is <code class="docutils literal notranslate"><span class="pre">libhello.so</span></code>.</p>
</div>
<p>This is done by using <code class="docutils literal notranslate"><span class="pre">uv_dlopen</span></code> to first load the shared library
<code class="docutils literal notranslate"><span class="pre">libhello.dylib</span></code>. Then we get access to the <code class="docutils literal notranslate"><span class="pre">initialize</span></code> function using
<code class="docutils literal notranslate"><span class="pre">uv_dlsym</span></code> and invoke it.</p>
<p class="rubric">plugin/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &quot;plugin.h&quot;</span>

<span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init_plugin_function</span><span class="p">)();</span>

<span class="n">void</span> <span class="n">mfp_register</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Registered plugin </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Usage: </span><span class="si">%s</span><span class="s2"> [plugin1] [plugin2] ...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="hll">    <span class="n">uv_lib_t</span> <span class="o">*</span><span class="n">lib</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_lib_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">uv_lib_t</span><span class="p">));</span>
</span>    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Loading </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">]);</span>
<span class="hll">        <span class="k">if</span> <span class="p">(</span><span class="n">uv_dlopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">],</span> <span class="n">lib</span><span class="p">))</span> <span class="p">{</span>
</span>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Error: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_dlerror</span><span class="p">(</span><span class="n">lib</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">init_plugin_function</span> <span class="n">init_plugin</span><span class="p">;</span>
<span class="hll">        <span class="k">if</span> <span class="p">(</span><span class="n">uv_dlsym</span><span class="p">(</span><span class="n">lib</span><span class="p">,</span> <span class="s2">&quot;initialize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">init_plugin</span><span class="p">))</span> <span class="p">{</span>
</span>            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;dlsym error: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">uv_dlerror</span><span class="p">(</span><span class="n">lib</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">init_plugin</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">uv_dlopen</span></code> expects a path to the shared library and sets the opaque
<code class="docutils literal notranslate"><span class="pre">uv_lib_t</span></code> pointer. It returns 0 on success, -1 on error. Use <code class="docutils literal notranslate"><span class="pre">uv_dlerror</span></code>
to get the error message.</p>
<p><code class="docutils literal notranslate"><span class="pre">uv_dlsym</span></code> stores a pointer to the symbol in the second argument in the third
argument. <code class="docutils literal notranslate"><span class="pre">init_plugin_function</span></code> is a function pointer to the sort of
function we are looking for in the application’s plugins.</p>
</div>
<div class="section" id="tty">
<h5>TTY<a class="headerlink" href="#tty" title="Permalink to this headline">¶</a></h5>
<p>Text terminals have supported basic formatting for a long time, with a <a class="reference external" href="http://en.wikipedia.org/wiki/ANSI_escape_sequences">pretty
standardised</a> command set. This formatting is often used by programs to
improve the readability of terminal output. For example <code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">--colour</span></code>.
libuv provides the <code class="docutils literal notranslate"><span class="pre">uv_tty_t</span></code> abstraction (a stream) and related functions to
implement the ANSI escape codes across all platforms. By this I mean that libuv
converts ANSI codes to the Windows equivalent, and provides functions to get
terminal information.</p>
<p>The first thing to do is to initialize a <code class="docutils literal notranslate"><span class="pre">uv_tty_t</span></code> with the file descriptor
it reads/writes from. This is achieved with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">uv_tty_init</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span><span class="p">,</span> <span class="n">uv_tty_t</span><span class="o">*</span><span class="p">,</span> <span class="n">uv_file</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">int</span> <span class="n">readable</span><span class="p">)</span>
</pre></div>
</div>
<p>Set <code class="docutils literal notranslate"><span class="pre">readable</span></code> to true if you plan to use <code class="docutils literal notranslate"><span class="pre">uv_read_start()</span></code> on the stream.</p>
<p>It is then best to use <code class="docutils literal notranslate"><span class="pre">uv_tty_set_mode</span></code> to set the mode to <em>normal</em>
which enables most TTY formatting, flow-control and other settings. <a class="reference external" href="http://docs.libuv.org/en/v1.x/tty.html#c.uv_tty_mode_t">Other</a> modes
are also available.</p>
<p>Remember to call <code class="docutils literal notranslate"><span class="pre">uv_tty_reset_mode</span></code> when your program exits to restore the
state of the terminal. Just good manners. Another set of good manners is to be
aware of redirection. If the user redirects the output of your command to
a file, control sequences should not be written as they impede readability and
<code class="docutils literal notranslate"><span class="pre">grep</span></code>. To check if the file descriptor is indeed a TTY, call
<code class="docutils literal notranslate"><span class="pre">uv_guess_handle</span></code> with the file descriptor and compare the return value with
<code class="docutils literal notranslate"><span class="pre">UV_TTY</span></code>.</p>
<p>Here is a simple example which prints white text on a red background:</p>
<p class="rubric">tty/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;string.h&gt;</span>
<span class="c1">#include &lt;unistd.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_tty_t</span> <span class="n">tty</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_tty_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_tty_set_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="n">UV_TTY_MODE_NORMAL</span><span class="p">);</span>
</span>    
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_guess_handle</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">UV_TTY</span><span class="p">)</span> <span class="p">{</span>
</span>        <span class="n">uv_write_t</span> <span class="n">req</span><span class="p">;</span>
        <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">;</span>
<span class="hll">        <span class="n">buf</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[41;37m&quot;</span><span class="p">;</span>
</span>        <span class="n">buf</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">base</span><span class="p">);</span>
        <span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">uv_write_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">buf</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;Hello TTY</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="n">buf</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">base</span><span class="p">);</span>
    <span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_tty_reset_mode</span><span class="p">();</span>
</span>    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The final TTY helper is <code class="docutils literal notranslate"><span class="pre">uv_tty_get_winsize()</span></code> which is used to get the
width and height of the terminal and returns <code class="docutils literal notranslate"><span class="pre">0</span></code> on success. Here is a small
program which does some animation using the function and character position
escape codes.</p>
<p class="rubric">tty-gravity/main.c</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;string.h&gt;</span>
<span class="c1">#include &lt;unistd.h&gt;</span>
<span class="c1">#include &lt;uv.h&gt;</span>

<span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_tty_t</span> <span class="n">tty</span><span class="p">;</span>
<span class="n">uv_timer_t</span> <span class="n">tick</span><span class="p">;</span>
<span class="n">uv_write_t</span> <span class="n">write_req</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;  Hello TTY  &quot;</span><span class="p">;</span>

<span class="n">void</span> <span class="n">update</span><span class="p">(</span><span class="n">uv_timer_t</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">500</span><span class="p">];</span>

    <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">buf</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="hll">    <span class="n">buf</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[2J</span><span class="se">\033</span><span class="s2">[H</span><span class="se">\033</span><span class="s2">[</span><span class="si">%d</span><span class="s2">B</span><span class="se">\033</span><span class="s2">[</span><span class="si">%lu</span><span class="s2">C</span><span class="se">\033</span><span class="s2">[42;37m</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
</span>                            <span class="n">pos</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">message</span><span class="p">);</span>
    <span class="n">uv_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">write_req</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

<span class="hll">    <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uv_tty_reset_mode</span><span class="p">();</span>
        <span class="n">uv_timer_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tick</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_tty_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">uv_tty_set_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_tty_get_winsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Could not get TTY information</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="n">uv_tty_reset_mode</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Width </span><span class="si">%d</span><span class="s2">, height </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tick</span><span class="p">);</span>
    <span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tick</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The escape codes are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>2</em> J</td>
<td>Clear part of the screen, 2 is entire screen</td>
</tr>
<tr class="row-odd"><td>H</td>
<td>Moves cursor to certain position, default top-left</td>
</tr>
<tr class="row-even"><td><em>n</em> B</td>
<td>Moves cursor down by n lines</td>
</tr>
<tr class="row-odd"><td><em>n</em> C</td>
<td>Moves cursor right by n columns</td>
</tr>
<tr class="row-even"><td>m</td>
<td>Obeys string of display settings, in this case green background (40+2), white text (30+7)</td>
</tr>
</tbody>
</table>
<p>As you can see this is very useful to produce nicely formatted output, or even
console based arcade games if that tickles your fancy. For fancier control you
can try <a class="reference external" href="http://www.gnu.org/software/ncurses/ncurses.html">ncurses</a>.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>I was first introduced to the term baton in this context, in Konstantin
Käfer’s excellent slides on writing node.js bindings –
<a class="reference external" href="http://kkaefer.github.com/node-cpp-modules/#baton">http://kkaefer.github.com/node-cpp-modules/#baton</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>mfp is My Fancy Plugin</td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-guide/about"></span><div class="section" id="about">
<h4>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://nikhilism.com">Nikhil Marathe</a> started writing this book one
afternoon (June 16, 2012) when he didn’t feel like programming. He had recently
been stung by the lack of good documentation on libuv while working on
<a class="reference external" href="https://github.com/nikhilm/node-taglib">node-taglib</a>. Although reference
documentation was present, there were no comprehensive tutorials. This book is
the output of that need and tries to be accurate. That said, the book may have
mistakes. Pull requests are encouraged.</p>
<p>Nikhil is indebted to Marc Lehmann’s comprehensive <a class="reference external" href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod">man page</a> about libev which
describes much of the semantics of the two libraries.</p>
<p>This book was made using <a class="reference external" href="http://sphinx.pocoo.org/">Sphinx</a> and <a class="reference external" href="http://www.vim.org">vim</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In 2017 the libuv project incorporated the Nikhil’s work into the official
documentation and it’s maintained there henceforth.</p>
</div>
</div>
</div>
</div>
<span id="document-upgrading"></span><div class="section" id="upgrading">
<span id="id1"></span><h3>Upgrading<a class="headerlink" href="#upgrading" title="Permalink to this headline">¶</a></h3>
<p>Migration guides for different libuv versions, starting with 1.0.</p>
<div class="toctree-wrapper compound">
<span id="document-migration_010_100"></span><div class="section" id="libuv-0-10-1-0-0-migration-guide">
<span id="migration-010-100"></span><h4>libuv 0.10 -&gt; 1.0.0 migration guide<a class="headerlink" href="#libuv-0-10-1-0-0-migration-guide" title="Permalink to this headline">¶</a></h4>
<p>Some APIs changed quite a bit throughout the 1.0.0 development process. Here
is a migration guide for the most significant changes that happened after 0.10
was released.</p>
<div class="section" id="loop-initialization-and-closing">
<h5>Loop initialization and closing<a class="headerlink" href="#loop-initialization-and-closing" title="Permalink to this headline">¶</a></h5>
<p>In libuv 0.10 (and previous versions), loops were created with <cite>uv_loop_new</cite>, which
allocated memory for a new loop and initialized it; and destroyed with <cite>uv_loop_delete</cite>,
which destroyed the loop and freed the memory. Starting with 1.0, those are deprecated
and the user is responsible for allocating the memory and then initializing the loop.</p>
<p>libuv 0.10</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>
<span class="o">...</span>
<span class="n">uv_loop_delete</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</pre></div>
</div>
<p>libuv 1.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span> <span class="o">*</span><span class="n">loop</span><span class="p">);</span>
<span class="n">uv_loop_init</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">uv_loop_close</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Error handling was omitted for brevity. Check the documentation for <a class="reference internal" href="index.html#c.uv_loop_init" title="uv_loop_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_loop_init()</span></code></a>
and <a class="reference internal" href="index.html#c.uv_loop_close" title="uv_loop_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_loop_close()</span></code></a>.</p>
</div>
</div>
<div class="section" id="error-handling">
<h5>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h5>
<p>Error handling had a major overhaul in libuv 1.0. In general, functions and status parameters
would get 0 for success and -1 for failure on libuv 0.10, and the user had to use <cite>uv_last_error</cite>
to fetch the error code, which was a positive number.</p>
<p>In 1.0, functions and status parameters contain the actual error code, which is 0 for success, or
a negative number in case of error.</p>
<p>libuv 0.10</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">assume</span> <span class="s1">&#39;server&#39;</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">TCP</span> <span class="n">server</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">listening</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">server</span><span class="p">,</span> <span class="mi">511</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uv_err_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">uv_last_error</span><span class="p">(</span><span class="n">uv_default_loop</span><span class="p">());</span>
  <span class="o">/*</span> <span class="n">err</span><span class="o">.</span><span class="n">code</span> <span class="n">contains</span> <span class="n">UV_EADDRINUSE</span> <span class="o">*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>libuv 1.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">assume</span> <span class="s1">&#39;server&#39;</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">TCP</span> <span class="n">server</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">listening</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">server</span><span class="p">,</span> <span class="mi">511</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">/*</span> <span class="n">r</span> <span class="n">contains</span> <span class="n">UV_EADDRINUSE</span> <span class="o">*/</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="threadpool-changes">
<h5>Threadpool changes<a class="headerlink" href="#threadpool-changes" title="Permalink to this headline">¶</a></h5>
<p>In libuv 0.10 Unix used a threadpool which defaulted to 4 threads, while Windows used the
<cite>QueueUserWorkItem</cite> API, which uses a Windows internal threadpool, which defaults to 512
threads per process.</p>
<p>In 1.0, we unified both implementations, so Windows now uses the same implementation Unix
does. The threadpool size can be set by exporting the <code class="docutils literal notranslate"><span class="pre">UV_THREADPOOL_SIZE</span></code> environment
variable. See <a class="reference internal" href="index.html#threadpool"><span class="std std-ref">Thread pool work scheduling</span></a>.</p>
</div>
<div class="section" id="allocation-callback-api-change">
<h5>Allocation callback API change<a class="headerlink" href="#allocation-callback-api-change" title="Permalink to this headline">¶</a></h5>
<p>In libuv 0.10 the callback had to return a filled <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_buf_t</span></code></a> by value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uv_buf_t</span> <span class="n">alloc_cb</span><span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">uv_buf_init</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In libuv 1.0 a pointer to a buffer is passed to the callback, which the user
needs to fill:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">alloc_cb</span><span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">buf</span><span class="o">-&gt;</span><span class="nb">len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unification-of-ipv4-ipv6-apis">
<h5>Unification of IPv4 / IPv6 APIs<a class="headerlink" href="#unification-of-ipv4-ipv6-apis" title="Permalink to this headline">¶</a></h5>
<p>libuv 1.0 unified the IPv4 and IPv6 APIS. There is no longer a <cite>uv_tcp_bind</cite> and <cite>uv_tcp_bind6</cite>
duality, there is only <a class="reference internal" href="index.html#c.uv_tcp_bind" title="uv_tcp_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_tcp_bind()</span></code></a> now.</p>
<p>IPv4 functions took <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code> structures by value, and IPv6 functions took
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code>. Now functions take a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr*</span></code> (note it’s a pointer).
It can be stack allocated.</p>
<p>libuv 0.10</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">uv_tcp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
</pre></div>
</div>
<p>libuv 1.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
<span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s2">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">uv_tcp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The IPv4 and IPv6 struct creating functions (<a class="reference internal" href="index.html#c.uv_ip4_addr" title="uv_ip4_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_ip4_addr()</span></code></a> and <a class="reference internal" href="index.html#c.uv_ip6_addr" title="uv_ip6_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_ip6_addr()</span></code></a>)
have also changed, make sure you check the documentation.</p>
<dl class="docutils">
<dt>..note::</dt>
<dd>This change applies to all functions that made a distinction between IPv4 and IPv6
addresses.</dd>
</dl>
</div>
<div class="section" id="streams-udp-data-receive-callback-api-change">
<h5>Streams / UDP  data receive callback API change<a class="headerlink" href="#streams-udp-data-receive-callback-api-change" title="Permalink to this headline">¶</a></h5>
<p>The streams and UDP data receive callbacks now get a pointer to a <a class="reference internal" href="index.html#c.uv_buf_t" title="uv_buf_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">uv_buf_t</span></code></a> buffer,
not a structure by value.</p>
<p>libuv 0.10</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">on_read</span><span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
             <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
             <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">recv_cb</span><span class="p">(</span><span class="n">uv_udp_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
             <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
             <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">,</span>
             <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span>
             <span class="n">unsigned</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>libuv 1.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">on_read</span><span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
             <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">recv_cb</span><span class="p">(</span><span class="n">uv_udp_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
             <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">struct</span> <span class="n">sockaddr</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span>
             <span class="n">unsigned</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="receiving-handles-over-pipes-api-change">
<h5>Receiving handles over pipes API change<a class="headerlink" href="#receiving-handles-over-pipes-api-change" title="Permalink to this headline">¶</a></h5>
<p>In libuv 0.10 (and earlier versions) the <cite>uv_read2_start</cite> function was used to start reading
data on a pipe, which could also result in the reception of handles over it. The callback
for such function looked like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">on_read</span><span class="p">(</span><span class="n">uv_pipe_t</span><span class="o">*</span> <span class="n">pipe</span><span class="p">,</span>
             <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
             <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">,</span>
             <span class="n">uv_handle_type</span> <span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In libuv 1.0, <cite>uv_read2_start</cite> was removed, and the user needs to check if there are pending
handles using <a class="reference internal" href="index.html#c.uv_pipe_pending_count" title="uv_pipe_pending_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_pipe_pending_count()</span></code></a> and <a class="reference internal" href="index.html#c.uv_pipe_pending_type" title="uv_pipe_pending_type"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_pipe_pending_type()</span></code></a> while in
the read callback:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">on_read</span><span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
             <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">uv_buf_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">uv_pipe_pending_count</span><span class="p">((</span><span class="n">uv_pipe_t</span><span class="o">*</span><span class="p">)</span> <span class="n">handle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pending</span> <span class="o">=</span> <span class="n">uv_pipe_pending_type</span><span class="p">((</span><span class="n">uv_pipe_t</span><span class="o">*</span><span class="p">)</span> <span class="n">handle</span><span class="p">);</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="extracting-the-file-descriptor-out-of-a-handle">
<h5>Extracting the file descriptor out of a handle<a class="headerlink" href="#extracting-the-file-descriptor-out-of-a-handle" title="Permalink to this headline">¶</a></h5>
<p>While it wasn’t supported by the API, users often accessed the libuv internals in
order to get access to the file descriptor of a TCP handle, for example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fd</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="o">.</span><span class="n">fd</span><span class="p">;</span>
</pre></div>
</div>
<p>This is now properly exposed through the <a class="reference internal" href="index.html#c.uv_fileno" title="uv_fileno"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fileno()</span></code></a> function.</p>
</div>
<div class="section" id="uv-fs-readdir-rename-and-api-change">
<h5>uv_fs_readdir rename and API change<a class="headerlink" href="#uv-fs-readdir-rename-and-api-change" title="Permalink to this headline">¶</a></h5>
<p><cite>uv_fs_readdir</cite> returned a list of strings in the <cite>req-&gt;ptr</cite> field upon completion in
libuv 0.10. In 1.0, this function got renamed to <a class="reference internal" href="index.html#c.uv_fs_scandir" title="uv_fs_scandir"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_scandir()</span></code></a>, since it’s
actually implemented using <code class="docutils literal notranslate"><span class="pre">scandir(3)</span></code>.</p>
<p>In addition, instead of allocating a full list strings, the user is able to get one
result at a time by using the <a class="reference internal" href="index.html#c.uv_fs_scandir_next" title="uv_fs_scandir_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">uv_fs_scandir_next()</span></code></a> function. This function
does not need to make a roundtrip to the threadpool, because libuv will keep the
list of <em>dents</em> returned by <code class="docutils literal notranslate"><span class="pre">scandir(3)</span></code> around.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="downloads">
<h2>Downloads<a class="headerlink" href="#downloads" title="Permalink to this headline">¶</a></h2>
<p>libuv can be downloaded from <a class="reference external" href="http://dist.libuv.org/dist/">here</a>.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Installation instructions can be found in <a class="reference external" href="https://github.com/libuv/libuv/blob/master/README.md">the README</a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html#document-index">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html#document-index">Table Of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-design">Design overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-guide">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-upgrading">Upgrading</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">libuv 1.20.4-dev documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-present, libuv contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>